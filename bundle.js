/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/entry.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/lodash.debounce/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.debounce/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcz9mN2ZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash.debounce/index.js\n");

/***/ }),

/***/ "./node_modules/nouislider/distribute/nouislider.js":
/*!**********************************************************!*\
  !*** ./node_modules/nouislider/distribute/nouislider.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! nouislider - 12.1.0 - 10/25/2018 */\n(function(factory) {\r\n    if (true) {\r\n        // AMD. Register as an anonymous module.\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    } else {}\r\n})(function() {\r\n    \"use strict\";\r\n\r\n    var VERSION = \"12.1.0\";\r\n\r\n    function isValidFormatter(entry) {\r\n        return typeof entry === \"object\" && typeof entry.to === \"function\" && typeof entry.from === \"function\";\r\n    }\r\n\r\n    function removeElement(el) {\r\n        el.parentElement.removeChild(el);\r\n    }\r\n\r\n    function isSet(value) {\r\n        return value !== null && value !== undefined;\r\n    }\r\n\r\n    // Bindable version\r\n    function preventDefault(e) {\r\n        e.preventDefault();\r\n    }\r\n\r\n    // Removes duplicates from an array.\r\n    function unique(array) {\r\n        return array.filter(function(a) {\r\n            return !this[a] ? (this[a] = true) : false;\r\n        }, {});\r\n    }\r\n\r\n    // Round a value to the closest 'to'.\r\n    function closest(value, to) {\r\n        return Math.round(value / to) * to;\r\n    }\r\n\r\n    // Current position of an element relative to the document.\r\n    function offset(elem, orientation) {\r\n        var rect = elem.getBoundingClientRect();\r\n        var doc = elem.ownerDocument;\r\n        var docElem = doc.documentElement;\r\n        var pageOffset = getPageOffset(doc);\r\n\r\n        // getBoundingClientRect contains left scroll in Chrome on Android.\r\n        // I haven't found a feature detection that proves this. Worst case\r\n        // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.\r\n        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {\r\n            pageOffset.x = 0;\r\n        }\r\n\r\n        return orientation\r\n            ? rect.top + pageOffset.y - docElem.clientTop\r\n            : rect.left + pageOffset.x - docElem.clientLeft;\r\n    }\r\n\r\n    // Checks whether a value is numerical.\r\n    function isNumeric(a) {\r\n        return typeof a === \"number\" && !isNaN(a) && isFinite(a);\r\n    }\r\n\r\n    // Sets a class and removes it after [duration] ms.\r\n    function addClassFor(element, className, duration) {\r\n        if (duration > 0) {\r\n            addClass(element, className);\r\n            setTimeout(function() {\r\n                removeClass(element, className);\r\n            }, duration);\r\n        }\r\n    }\r\n\r\n    // Limits a value to 0 - 100\r\n    function limit(a) {\r\n        return Math.max(Math.min(a, 100), 0);\r\n    }\r\n\r\n    // Wraps a variable as an array, if it isn't one yet.\r\n    // Note that an input array is returned by reference!\r\n    function asArray(a) {\r\n        return Array.isArray(a) ? a : [a];\r\n    }\r\n\r\n    // Counts decimals\r\n    function countDecimals(numStr) {\r\n        numStr = String(numStr);\r\n        var pieces = numStr.split(\".\");\r\n        return pieces.length > 1 ? pieces[1].length : 0;\r\n    }\r\n\r\n    // http://youmightnotneedjquery.com/#add_class\r\n    function addClass(el, className) {\r\n        if (el.classList) {\r\n            el.classList.add(className);\r\n        } else {\r\n            el.className += \" \" + className;\r\n        }\r\n    }\r\n\r\n    // http://youmightnotneedjquery.com/#remove_class\r\n    function removeClass(el, className) {\r\n        if (el.classList) {\r\n            el.classList.remove(className);\r\n        } else {\r\n            el.className = el.className.replace(\r\n                new RegExp(\"(^|\\\\b)\" + className.split(\" \").join(\"|\") + \"(\\\\b|$)\", \"gi\"),\r\n                \" \"\r\n            );\r\n        }\r\n    }\r\n\r\n    // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/\r\n    function hasClass(el, className) {\r\n        return el.classList\r\n            ? el.classList.contains(className)\r\n            : new RegExp(\"\\\\b\" + className + \"\\\\b\").test(el.className);\r\n    }\r\n\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes\r\n    function getPageOffset(doc) {\r\n        var supportPageOffset = window.pageXOffset !== undefined;\r\n        var isCSS1Compat = (doc.compatMode || \"\") === \"CSS1Compat\";\r\n        var x = supportPageOffset\r\n            ? window.pageXOffset\r\n            : isCSS1Compat\r\n                ? doc.documentElement.scrollLeft\r\n                : doc.body.scrollLeft;\r\n        var y = supportPageOffset\r\n            ? window.pageYOffset\r\n            : isCSS1Compat\r\n                ? doc.documentElement.scrollTop\r\n                : doc.body.scrollTop;\r\n\r\n        return {\r\n            x: x,\r\n            y: y\r\n        };\r\n    }\r\n\r\n    // we provide a function to compute constants instead\r\n    // of accessing window.* as soon as the module needs it\r\n    // so that we do not compute anything if not needed\r\n    function getActions() {\r\n        // Determine the events to bind. IE11 implements pointerEvents without\r\n        // a prefix, which breaks compatibility with the IE10 implementation.\r\n        return window.navigator.pointerEnabled\r\n            ? {\r\n                  start: \"pointerdown\",\r\n                  move: \"pointermove\",\r\n                  end: \"pointerup\"\r\n              }\r\n            : window.navigator.msPointerEnabled\r\n                ? {\r\n                      start: \"MSPointerDown\",\r\n                      move: \"MSPointerMove\",\r\n                      end: \"MSPointerUp\"\r\n                  }\r\n                : {\r\n                      start: \"mousedown touchstart\",\r\n                      move: \"mousemove touchmove\",\r\n                      end: \"mouseup touchend\"\r\n                  };\r\n    }\r\n\r\n    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n    // Issue #785\r\n    function getSupportsPassive() {\r\n        var supportsPassive = false;\r\n\r\n        /* eslint-disable */\r\n        try {\r\n            var opts = Object.defineProperty({}, \"passive\", {\r\n                get: function() {\r\n                    supportsPassive = true;\r\n                }\r\n            });\r\n\r\n            window.addEventListener(\"test\", null, opts);\r\n        } catch (e) {}\r\n        /* eslint-enable */\r\n\r\n        return supportsPassive;\r\n    }\r\n\r\n    function getSupportsTouchActionNone() {\r\n        return window.CSS && CSS.supports && CSS.supports(\"touch-action\", \"none\");\r\n    }\r\n\r\n    // Value calculation\r\n\r\n    // Determine the size of a sub-range in relation to a full range.\r\n    function subRangeRatio(pa, pb) {\r\n        return 100 / (pb - pa);\r\n    }\r\n\r\n    // (percentage) How many percent is this value of this range?\r\n    function fromPercentage(range, value) {\r\n        return (value * 100) / (range[1] - range[0]);\r\n    }\r\n\r\n    // (percentage) Where is this value on this range?\r\n    function toPercentage(range, value) {\r\n        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0]);\r\n    }\r\n\r\n    // (value) How much is this percentage on this range?\r\n    function isPercentage(range, value) {\r\n        return (value * (range[1] - range[0])) / 100 + range[0];\r\n    }\r\n\r\n    // Range conversion\r\n\r\n    function getJ(value, arr) {\r\n        var j = 1;\r\n\r\n        while (value >= arr[j]) {\r\n            j += 1;\r\n        }\r\n\r\n        return j;\r\n    }\r\n\r\n    // (percentage) Input a value, find where, on a scale of 0-100, it applies.\r\n    function toStepping(xVal, xPct, value) {\r\n        if (value >= xVal.slice(-1)[0]) {\r\n            return 100;\r\n        }\r\n\r\n        var j = getJ(value, xVal);\r\n        var va = xVal[j - 1];\r\n        var vb = xVal[j];\r\n        var pa = xPct[j - 1];\r\n        var pb = xPct[j];\r\n\r\n        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);\r\n    }\r\n\r\n    // (value) Input a percentage, find where it is on the specified range.\r\n    function fromStepping(xVal, xPct, value) {\r\n        // There is no range group that fits 100\r\n        if (value >= 100) {\r\n            return xVal.slice(-1)[0];\r\n        }\r\n\r\n        var j = getJ(value, xPct);\r\n        var va = xVal[j - 1];\r\n        var vb = xVal[j];\r\n        var pa = xPct[j - 1];\r\n        var pb = xPct[j];\r\n\r\n        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));\r\n    }\r\n\r\n    // (percentage) Get the step that applies at a certain value.\r\n    function getStep(xPct, xSteps, snap, value) {\r\n        if (value === 100) {\r\n            return value;\r\n        }\r\n\r\n        var j = getJ(value, xPct);\r\n        var a = xPct[j - 1];\r\n        var b = xPct[j];\r\n\r\n        // If 'snap' is set, steps are used as fixed points on the slider.\r\n        if (snap) {\r\n            // Find the closest position, a or b.\r\n            if (value - a > (b - a) / 2) {\r\n                return b;\r\n            }\r\n\r\n            return a;\r\n        }\r\n\r\n        if (!xSteps[j - 1]) {\r\n            return value;\r\n        }\r\n\r\n        return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);\r\n    }\r\n\r\n    // Entry parsing\r\n\r\n    function handleEntryPoint(index, value, that) {\r\n        var percentage;\r\n\r\n        // Wrap numerical input in an array.\r\n        if (typeof value === \"number\") {\r\n            value = [value];\r\n        }\r\n\r\n        // Reject any invalid input, by testing whether value is an array.\r\n        if (!Array.isArray(value)) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'range' contains invalid value.\");\r\n        }\r\n\r\n        // Covert min/max syntax to 0 and 100.\r\n        if (index === \"min\") {\r\n            percentage = 0;\r\n        } else if (index === \"max\") {\r\n            percentage = 100;\r\n        } else {\r\n            percentage = parseFloat(index);\r\n        }\r\n\r\n        // Check for correct input.\r\n        if (!isNumeric(percentage) || !isNumeric(value[0])) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'range' value isn't numeric.\");\r\n        }\r\n\r\n        // Store values.\r\n        that.xPct.push(percentage);\r\n        that.xVal.push(value[0]);\r\n\r\n        // NaN will evaluate to false too, but to keep\r\n        // logging clear, set step explicitly. Make sure\r\n        // not to override the 'step' setting with false.\r\n        if (!percentage) {\r\n            if (!isNaN(value[1])) {\r\n                that.xSteps[0] = value[1];\r\n            }\r\n        } else {\r\n            that.xSteps.push(isNaN(value[1]) ? false : value[1]);\r\n        }\r\n\r\n        that.xHighestCompleteStep.push(0);\r\n    }\r\n\r\n    function handleStepPoint(i, n, that) {\r\n        // Ignore 'false' stepping.\r\n        if (!n) {\r\n            return true;\r\n        }\r\n\r\n        // Factor to range ratio\r\n        that.xSteps[i] =\r\n            fromPercentage([that.xVal[i], that.xVal[i + 1]], n) / subRangeRatio(that.xPct[i], that.xPct[i + 1]);\r\n\r\n        var totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i];\r\n        var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);\r\n        var step = that.xVal[i] + that.xNumSteps[i] * highestStep;\r\n\r\n        that.xHighestCompleteStep[i] = step;\r\n    }\r\n\r\n    // Interface\r\n\r\n    function Spectrum(entry, snap, singleStep) {\r\n        this.xPct = [];\r\n        this.xVal = [];\r\n        this.xSteps = [singleStep || false];\r\n        this.xNumSteps = [false];\r\n        this.xHighestCompleteStep = [];\r\n\r\n        this.snap = snap;\r\n\r\n        var index;\r\n        var ordered = []; // [0, 'min'], [1, '50%'], [2, 'max']\r\n\r\n        // Map the object keys to an array.\r\n        for (index in entry) {\r\n            if (entry.hasOwnProperty(index)) {\r\n                ordered.push([entry[index], index]);\r\n            }\r\n        }\r\n\r\n        // Sort all entries by value (numeric sort).\r\n        if (ordered.length && typeof ordered[0][0] === \"object\") {\r\n            ordered.sort(function(a, b) {\r\n                return a[0][0] - b[0][0];\r\n            });\r\n        } else {\r\n            ordered.sort(function(a, b) {\r\n                return a[0] - b[0];\r\n            });\r\n        }\r\n\r\n        // Convert all entries to subranges.\r\n        for (index = 0; index < ordered.length; index++) {\r\n            handleEntryPoint(ordered[index][1], ordered[index][0], this);\r\n        }\r\n\r\n        // Store the actual step values.\r\n        // xSteps is sorted in the same order as xPct and xVal.\r\n        this.xNumSteps = this.xSteps.slice(0);\r\n\r\n        // Convert all numeric steps to the percentage of the subrange they represent.\r\n        for (index = 0; index < this.xNumSteps.length; index++) {\r\n            handleStepPoint(index, this.xNumSteps[index], this);\r\n        }\r\n    }\r\n\r\n    Spectrum.prototype.getMargin = function(value) {\r\n        var step = this.xNumSteps[0];\r\n\r\n        if (step && (value / step) % 1 !== 0) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'limit', 'margin' and 'padding' must be divisible by step.\");\r\n        }\r\n\r\n        return this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;\r\n    };\r\n\r\n    Spectrum.prototype.toStepping = function(value) {\r\n        value = toStepping(this.xVal, this.xPct, value);\r\n\r\n        return value;\r\n    };\r\n\r\n    Spectrum.prototype.fromStepping = function(value) {\r\n        return fromStepping(this.xVal, this.xPct, value);\r\n    };\r\n\r\n    Spectrum.prototype.getStep = function(value) {\r\n        value = getStep(this.xPct, this.xSteps, this.snap, value);\r\n\r\n        return value;\r\n    };\r\n\r\n    Spectrum.prototype.getNearbySteps = function(value) {\r\n        var j = getJ(value, this.xPct);\r\n\r\n        return {\r\n            stepBefore: {\r\n                startValue: this.xVal[j - 2],\r\n                step: this.xNumSteps[j - 2],\r\n                highestStep: this.xHighestCompleteStep[j - 2]\r\n            },\r\n            thisStep: {\r\n                startValue: this.xVal[j - 1],\r\n                step: this.xNumSteps[j - 1],\r\n                highestStep: this.xHighestCompleteStep[j - 1]\r\n            },\r\n            stepAfter: {\r\n                startValue: this.xVal[j],\r\n                step: this.xNumSteps[j],\r\n                highestStep: this.xHighestCompleteStep[j]\r\n            }\r\n        };\r\n    };\r\n\r\n    Spectrum.prototype.countStepDecimals = function() {\r\n        var stepDecimals = this.xNumSteps.map(countDecimals);\r\n        return Math.max.apply(null, stepDecimals);\r\n    };\r\n\r\n    // Outside testing\r\n    Spectrum.prototype.convert = function(value) {\r\n        return this.getStep(this.toStepping(value));\r\n    };\r\n\r\n    /*\tEvery input option is tested and parsed. This'll prevent\r\n        endless validation in internal methods. These tests are\r\n        structured with an item for every option available. An\r\n        option can be marked as required by setting the 'r' flag.\r\n        The testing function is provided with three arguments:\r\n            - The provided value for the option;\r\n            - A reference to the options object;\r\n            - The name for the option;\r\n\r\n        The testing function returns false when an error is detected,\r\n        or true when everything is OK. It can also modify the option\r\n        object, to make sure all values can be correctly looped elsewhere. */\r\n\r\n    var defaultFormatter = {\r\n        to: function(value) {\r\n            return value !== undefined && value.toFixed(2);\r\n        },\r\n        from: Number\r\n    };\r\n\r\n    function validateFormat(entry) {\r\n        // Any object with a to and from method is supported.\r\n        if (isValidFormatter(entry)) {\r\n            return true;\r\n        }\r\n\r\n        throw new Error(\"noUiSlider (\" + VERSION + \"): 'format' requires 'to' and 'from' methods.\");\r\n    }\r\n\r\n    function testStep(parsed, entry) {\r\n        if (!isNumeric(entry)) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'step' is not numeric.\");\r\n        }\r\n\r\n        // The step option can still be used to set stepping\r\n        // for linear sliders. Overwritten if set in 'range'.\r\n        parsed.singleStep = entry;\r\n    }\r\n\r\n    function testRange(parsed, entry) {\r\n        // Filter incorrect input.\r\n        if (typeof entry !== \"object\" || Array.isArray(entry)) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'range' is not an object.\");\r\n        }\r\n\r\n        // Catch missing start or end.\r\n        if (entry.min === undefined || entry.max === undefined) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): Missing 'min' or 'max' in 'range'.\");\r\n        }\r\n\r\n        // Catch equal start or end.\r\n        if (entry.min === entry.max) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'range' 'min' and 'max' cannot be equal.\");\r\n        }\r\n\r\n        parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);\r\n    }\r\n\r\n    function testStart(parsed, entry) {\r\n        entry = asArray(entry);\r\n\r\n        // Validate input. Values aren't tested, as the public .val method\r\n        // will always provide a valid location.\r\n        if (!Array.isArray(entry) || !entry.length) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'start' option is incorrect.\");\r\n        }\r\n\r\n        // Store the number of handles.\r\n        parsed.handles = entry.length;\r\n\r\n        // When the slider is initialized, the .val method will\r\n        // be called with the start options.\r\n        parsed.start = entry;\r\n    }\r\n\r\n    function testSnap(parsed, entry) {\r\n        // Enforce 100% stepping within subranges.\r\n        parsed.snap = entry;\r\n\r\n        if (typeof entry !== \"boolean\") {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'snap' option must be a boolean.\");\r\n        }\r\n    }\r\n\r\n    function testAnimate(parsed, entry) {\r\n        // Enforce 100% stepping within subranges.\r\n        parsed.animate = entry;\r\n\r\n        if (typeof entry !== \"boolean\") {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'animate' option must be a boolean.\");\r\n        }\r\n    }\r\n\r\n    function testAnimationDuration(parsed, entry) {\r\n        parsed.animationDuration = entry;\r\n\r\n        if (typeof entry !== \"number\") {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'animationDuration' option must be a number.\");\r\n        }\r\n    }\r\n\r\n    function testConnect(parsed, entry) {\r\n        var connect = [false];\r\n        var i;\r\n\r\n        // Map legacy options\r\n        if (entry === \"lower\") {\r\n            entry = [true, false];\r\n        } else if (entry === \"upper\") {\r\n            entry = [false, true];\r\n        }\r\n\r\n        // Handle boolean options\r\n        if (entry === true || entry === false) {\r\n            for (i = 1; i < parsed.handles; i++) {\r\n                connect.push(entry);\r\n            }\r\n\r\n            connect.push(false);\r\n        }\r\n\r\n        // Reject invalid input\r\n        else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'connect' option doesn't match handle count.\");\r\n        } else {\r\n            connect = entry;\r\n        }\r\n\r\n        parsed.connect = connect;\r\n    }\r\n\r\n    function testOrientation(parsed, entry) {\r\n        // Set orientation to an a numerical value for easy\r\n        // array selection.\r\n        switch (entry) {\r\n            case \"horizontal\":\r\n                parsed.ort = 0;\r\n                break;\r\n            case \"vertical\":\r\n                parsed.ort = 1;\r\n                break;\r\n            default:\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'orientation' option is invalid.\");\r\n        }\r\n    }\r\n\r\n    function testMargin(parsed, entry) {\r\n        if (!isNumeric(entry)) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'margin' option must be numeric.\");\r\n        }\r\n\r\n        // Issue #582\r\n        if (entry === 0) {\r\n            return;\r\n        }\r\n\r\n        parsed.margin = parsed.spectrum.getMargin(entry);\r\n\r\n        if (!parsed.margin) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'margin' option is only supported on linear sliders.\");\r\n        }\r\n    }\r\n\r\n    function testLimit(parsed, entry) {\r\n        if (!isNumeric(entry)) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'limit' option must be numeric.\");\r\n        }\r\n\r\n        parsed.limit = parsed.spectrum.getMargin(entry);\r\n\r\n        if (!parsed.limit || parsed.handles < 2) {\r\n            throw new Error(\r\n                \"noUiSlider (\" +\r\n                    VERSION +\r\n                    \"): 'limit' option is only supported on linear sliders with 2 or more handles.\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function testPadding(parsed, entry) {\r\n        if (!isNumeric(entry) && !Array.isArray(entry)) {\r\n            throw new Error(\r\n                \"noUiSlider (\" + VERSION + \"): 'padding' option must be numeric or array of exactly 2 numbers.\"\r\n            );\r\n        }\r\n\r\n        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {\r\n            throw new Error(\r\n                \"noUiSlider (\" + VERSION + \"): 'padding' option must be numeric or array of exactly 2 numbers.\"\r\n            );\r\n        }\r\n\r\n        if (entry === 0) {\r\n            return;\r\n        }\r\n\r\n        if (!Array.isArray(entry)) {\r\n            entry = [entry, entry];\r\n        }\r\n\r\n        // 'getMargin' returns false for invalid values.\r\n        parsed.padding = [parsed.spectrum.getMargin(entry[0]), parsed.spectrum.getMargin(entry[1])];\r\n\r\n        if (parsed.padding[0] === false || parsed.padding[1] === false) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option is only supported on linear sliders.\");\r\n        }\r\n\r\n        if (parsed.padding[0] < 0 || parsed.padding[1] < 0) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must be a positive number(s).\");\r\n        }\r\n\r\n        if (parsed.padding[0] + parsed.padding[1] >= 100) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'padding' option must not exceed 100% of the range.\");\r\n        }\r\n    }\r\n\r\n    function testDirection(parsed, entry) {\r\n        // Set direction as a numerical value for easy parsing.\r\n        // Invert connection for RTL sliders, so that the proper\r\n        // handles get the connect/background classes.\r\n        switch (entry) {\r\n            case \"ltr\":\r\n                parsed.dir = 0;\r\n                break;\r\n            case \"rtl\":\r\n                parsed.dir = 1;\r\n                break;\r\n            default:\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'direction' option was not recognized.\");\r\n        }\r\n    }\r\n\r\n    function testBehaviour(parsed, entry) {\r\n        // Make sure the input is a string.\r\n        if (typeof entry !== \"string\") {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'behaviour' must be a string containing options.\");\r\n        }\r\n\r\n        // Check if the string contains any keywords.\r\n        // None are required.\r\n        var tap = entry.indexOf(\"tap\") >= 0;\r\n        var drag = entry.indexOf(\"drag\") >= 0;\r\n        var fixed = entry.indexOf(\"fixed\") >= 0;\r\n        var snap = entry.indexOf(\"snap\") >= 0;\r\n        var hover = entry.indexOf(\"hover\") >= 0;\r\n        var unconstrained = entry.indexOf(\"unconstrained\") >= 0;\r\n\r\n        if (fixed) {\r\n            if (parsed.handles !== 2) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): 'fixed' behaviour must be used with 2 handles\");\r\n            }\r\n\r\n            // Use margin to enforce fixed state\r\n            testMargin(parsed, parsed.start[1] - parsed.start[0]);\r\n        }\r\n\r\n        if (unconstrained && (parsed.margin || parsed.limit)) {\r\n            throw new Error(\r\n                \"noUiSlider (\" + VERSION + \"): 'unconstrained' behaviour cannot be used with margin or limit\"\r\n            );\r\n        }\r\n\r\n        parsed.events = {\r\n            tap: tap || snap,\r\n            drag: drag,\r\n            fixed: fixed,\r\n            snap: snap,\r\n            hover: hover,\r\n            unconstrained: unconstrained\r\n        };\r\n    }\r\n\r\n    function testTooltips(parsed, entry) {\r\n        if (entry === false) {\r\n            return;\r\n        }\r\n\r\n        if (entry === true) {\r\n            parsed.tooltips = [];\r\n\r\n            for (var i = 0; i < parsed.handles; i++) {\r\n                parsed.tooltips.push(true);\r\n            }\r\n        } else {\r\n            parsed.tooltips = asArray(entry);\r\n\r\n            if (parsed.tooltips.length !== parsed.handles) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): must pass a formatter for all handles.\");\r\n            }\r\n\r\n            parsed.tooltips.forEach(function(formatter) {\r\n                if (\r\n                    typeof formatter !== \"boolean\" &&\r\n                    (typeof formatter !== \"object\" || typeof formatter.to !== \"function\")\r\n                ) {\r\n                    throw new Error(\"noUiSlider (\" + VERSION + \"): 'tooltips' must be passed a formatter or 'false'.\");\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    function testAriaFormat(parsed, entry) {\r\n        parsed.ariaFormat = entry;\r\n        validateFormat(entry);\r\n    }\r\n\r\n    function testFormat(parsed, entry) {\r\n        parsed.format = entry;\r\n        validateFormat(entry);\r\n    }\r\n\r\n    function testKeyboardSupport(parsed, entry) {\r\n        parsed.keyboardSupport = entry;\r\n\r\n        if (typeof entry !== \"boolean\") {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'keyboardSupport' option must be a boolean.\");\r\n        }\r\n    }\r\n\r\n    function testDocumentElement(parsed, entry) {\r\n        // This is an advanced option. Passed values are used without validation.\r\n        parsed.documentElement = entry;\r\n    }\r\n\r\n    function testCssPrefix(parsed, entry) {\r\n        if (typeof entry !== \"string\" && entry !== false) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'cssPrefix' must be a string or `false`.\");\r\n        }\r\n\r\n        parsed.cssPrefix = entry;\r\n    }\r\n\r\n    function testCssClasses(parsed, entry) {\r\n        if (typeof entry !== \"object\") {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): 'cssClasses' must be an object.\");\r\n        }\r\n\r\n        if (typeof parsed.cssPrefix === \"string\") {\r\n            parsed.cssClasses = {};\r\n\r\n            for (var key in entry) {\r\n                if (!entry.hasOwnProperty(key)) {\r\n                    continue;\r\n                }\r\n\r\n                parsed.cssClasses[key] = parsed.cssPrefix + entry[key];\r\n            }\r\n        } else {\r\n            parsed.cssClasses = entry;\r\n        }\r\n    }\r\n\r\n    // Test all developer settings and parse to assumption-safe values.\r\n    function testOptions(options) {\r\n        // To prove a fix for #537, freeze options here.\r\n        // If the object is modified, an error will be thrown.\r\n        // Object.freeze(options);\r\n\r\n        var parsed = {\r\n            margin: 0,\r\n            limit: 0,\r\n            padding: 0,\r\n            animate: true,\r\n            animationDuration: 300,\r\n            ariaFormat: defaultFormatter,\r\n            format: defaultFormatter\r\n        };\r\n\r\n        // Tests are executed in the order they are presented here.\r\n        var tests = {\r\n            step: { r: false, t: testStep },\r\n            start: { r: true, t: testStart },\r\n            connect: { r: true, t: testConnect },\r\n            direction: { r: true, t: testDirection },\r\n            snap: { r: false, t: testSnap },\r\n            animate: { r: false, t: testAnimate },\r\n            animationDuration: { r: false, t: testAnimationDuration },\r\n            range: { r: true, t: testRange },\r\n            orientation: { r: false, t: testOrientation },\r\n            margin: { r: false, t: testMargin },\r\n            limit: { r: false, t: testLimit },\r\n            padding: { r: false, t: testPadding },\r\n            behaviour: { r: true, t: testBehaviour },\r\n            ariaFormat: { r: false, t: testAriaFormat },\r\n            format: { r: false, t: testFormat },\r\n            tooltips: { r: false, t: testTooltips },\r\n            keyboardSupport: { r: true, t: testKeyboardSupport },\r\n            documentElement: { r: false, t: testDocumentElement },\r\n            cssPrefix: { r: true, t: testCssPrefix },\r\n            cssClasses: { r: true, t: testCssClasses }\r\n        };\r\n\r\n        var defaults = {\r\n            connect: false,\r\n            direction: \"ltr\",\r\n            behaviour: \"tap\",\r\n            orientation: \"horizontal\",\r\n            keyboardSupport: true,\r\n            cssPrefix: \"noUi-\",\r\n            cssClasses: {\r\n                target: \"target\",\r\n                base: \"base\",\r\n                origin: \"origin\",\r\n                handle: \"handle\",\r\n                handleLower: \"handle-lower\",\r\n                handleUpper: \"handle-upper\",\r\n                horizontal: \"horizontal\",\r\n                vertical: \"vertical\",\r\n                background: \"background\",\r\n                connect: \"connect\",\r\n                connects: \"connects\",\r\n                ltr: \"ltr\",\r\n                rtl: \"rtl\",\r\n                draggable: \"draggable\",\r\n                drag: \"state-drag\",\r\n                tap: \"state-tap\",\r\n                active: \"active\",\r\n                tooltip: \"tooltip\",\r\n                pips: \"pips\",\r\n                pipsHorizontal: \"pips-horizontal\",\r\n                pipsVertical: \"pips-vertical\",\r\n                marker: \"marker\",\r\n                markerHorizontal: \"marker-horizontal\",\r\n                markerVertical: \"marker-vertical\",\r\n                markerNormal: \"marker-normal\",\r\n                markerLarge: \"marker-large\",\r\n                markerSub: \"marker-sub\",\r\n                value: \"value\",\r\n                valueHorizontal: \"value-horizontal\",\r\n                valueVertical: \"value-vertical\",\r\n                valueNormal: \"value-normal\",\r\n                valueLarge: \"value-large\",\r\n                valueSub: \"value-sub\"\r\n            }\r\n        };\r\n\r\n        // AriaFormat defaults to regular format, if any.\r\n        if (options.format && !options.ariaFormat) {\r\n            options.ariaFormat = options.format;\r\n        }\r\n\r\n        // Run all options through a testing mechanism to ensure correct\r\n        // input. It should be noted that options might get modified to\r\n        // be handled properly. E.g. wrapping integers in arrays.\r\n        Object.keys(tests).forEach(function(name) {\r\n            // If the option isn't set, but it is required, throw an error.\r\n            if (!isSet(options[name]) && defaults[name] === undefined) {\r\n                if (tests[name].r) {\r\n                    throw new Error(\"noUiSlider (\" + VERSION + \"): '\" + name + \"' is required.\");\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);\r\n        });\r\n\r\n        // Forward pips options\r\n        parsed.pips = options.pips;\r\n\r\n        // All recent browsers accept unprefixed transform.\r\n        // We need -ms- for IE9 and -webkit- for older Android;\r\n        // Assume use of -webkit- if unprefixed and -ms- are not supported.\r\n        // https://caniuse.com/#feat=transforms2d\r\n        var d = document.createElement(\"div\");\r\n        var msPrefix = d.style.msTransform !== undefined;\r\n        var noPrefix = d.style.transform !== undefined;\r\n\r\n        parsed.transformRule = noPrefix ? \"transform\" : msPrefix ? \"msTransform\" : \"webkitTransform\";\r\n\r\n        // Pips don't move, so we can place them using left/top.\r\n        var styles = [[\"left\", \"top\"], [\"right\", \"bottom\"]];\r\n\r\n        parsed.style = styles[parsed.dir][parsed.ort];\r\n\r\n        return parsed;\r\n    }\r\n\r\n    function scope(target, options, originalOptions) {\r\n        var actions = getActions();\r\n        var supportsTouchActionNone = getSupportsTouchActionNone();\r\n        var supportsPassive = supportsTouchActionNone && getSupportsPassive();\r\n\r\n        // All variables local to 'scope' are prefixed with 'scope_'\r\n        var scope_Target = target;\r\n        var scope_Locations = [];\r\n        var scope_Base;\r\n        var scope_Handles;\r\n        var scope_HandleNumbers = [];\r\n        var scope_ActiveHandlesCount = 0;\r\n        var scope_Connects;\r\n        var scope_Spectrum = options.spectrum;\r\n        var scope_Values = [];\r\n        var scope_Events = {};\r\n        var scope_Self;\r\n        var scope_Pips;\r\n        var scope_Document = target.ownerDocument;\r\n        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;\r\n        var scope_Body = scope_Document.body;\r\n\r\n        // Pips constants\r\n        var PIPS_NONE = -1;\r\n        var PIPS_NO_VALUE = 0;\r\n        var PIPS_LARGE_VALUE = 1;\r\n        var PIPS_SMALL_VALUE = 2;\r\n\r\n        // For horizontal sliders in standard ltr documents,\r\n        // make .noUi-origin overflow to the left so the document doesn't scroll.\r\n        var scope_DirOffset = scope_Document.dir === \"rtl\" || options.ort === 1 ? 0 : 100;\r\n\r\n        // Creates a node, adds it to target, returns the new node.\r\n        function addNodeTo(addTarget, className) {\r\n            var div = scope_Document.createElement(\"div\");\r\n\r\n            if (className) {\r\n                addClass(div, className);\r\n            }\r\n\r\n            addTarget.appendChild(div);\r\n\r\n            return div;\r\n        }\r\n\r\n        // Append a origin to the base\r\n        function addOrigin(base, handleNumber) {\r\n            var origin = addNodeTo(base, options.cssClasses.origin);\r\n            var handle = addNodeTo(origin, options.cssClasses.handle);\r\n\r\n            handle.setAttribute(\"data-handle\", handleNumber);\r\n\r\n            if (options.keyboardSupport) {\r\n                // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\r\n                // 0 = focusable and reachable\r\n                handle.setAttribute(\"tabindex\", \"0\");\r\n            }\r\n\r\n            handle.setAttribute(\"role\", \"slider\");\r\n            handle.setAttribute(\"aria-orientation\", options.ort ? \"vertical\" : \"horizontal\");\r\n\r\n            if (handleNumber === 0) {\r\n                addClass(handle, options.cssClasses.handleLower);\r\n            } else if (handleNumber === options.handles - 1) {\r\n                addClass(handle, options.cssClasses.handleUpper);\r\n            }\r\n\r\n            return origin;\r\n        }\r\n\r\n        // Insert nodes for connect elements\r\n        function addConnect(base, add) {\r\n            if (!add) {\r\n                return false;\r\n            }\r\n\r\n            return addNodeTo(base, options.cssClasses.connect);\r\n        }\r\n\r\n        // Add handles to the slider base.\r\n        function addElements(connectOptions, base) {\r\n            var connectBase = addNodeTo(base, options.cssClasses.connects);\r\n\r\n            scope_Handles = [];\r\n            scope_Connects = [];\r\n\r\n            scope_Connects.push(addConnect(connectBase, connectOptions[0]));\r\n\r\n            // [::::O====O====O====]\r\n            // connectOptions = [0, 1, 1, 1]\r\n\r\n            for (var i = 0; i < options.handles; i++) {\r\n                // Keep a list of all added handles.\r\n                scope_Handles.push(addOrigin(base, i));\r\n                scope_HandleNumbers[i] = i;\r\n                scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));\r\n            }\r\n        }\r\n\r\n        // Initialize a single slider.\r\n        function addSlider(addTarget) {\r\n            // Apply classes and data to the target.\r\n            addClass(addTarget, options.cssClasses.target);\r\n\r\n            if (options.dir === 0) {\r\n                addClass(addTarget, options.cssClasses.ltr);\r\n            } else {\r\n                addClass(addTarget, options.cssClasses.rtl);\r\n            }\r\n\r\n            if (options.ort === 0) {\r\n                addClass(addTarget, options.cssClasses.horizontal);\r\n            } else {\r\n                addClass(addTarget, options.cssClasses.vertical);\r\n            }\r\n\r\n            return addNodeTo(addTarget, options.cssClasses.base);\r\n        }\r\n\r\n        function addTooltip(handle, handleNumber) {\r\n            if (!options.tooltips[handleNumber]) {\r\n                return false;\r\n            }\r\n\r\n            return addNodeTo(handle.firstChild, options.cssClasses.tooltip);\r\n        }\r\n\r\n        // The tooltips option is a shorthand for using the 'update' event.\r\n        function tooltips() {\r\n            // Tooltips are added with options.tooltips in original order.\r\n            var tips = scope_Handles.map(addTooltip);\r\n\r\n            bindEvent(\"update\", function(values, handleNumber, unencoded) {\r\n                if (!tips[handleNumber]) {\r\n                    return;\r\n                }\r\n\r\n                var formattedValue = values[handleNumber];\r\n\r\n                if (options.tooltips[handleNumber] !== true) {\r\n                    formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);\r\n                }\r\n\r\n                tips[handleNumber].innerHTML = formattedValue;\r\n            });\r\n        }\r\n\r\n        function aria() {\r\n            bindEvent(\"update\", function(values, handleNumber, unencoded, tap, positions) {\r\n                // Update Aria Values for all handles, as a change in one changes min and max values for the next.\r\n                scope_HandleNumbers.forEach(function(index) {\r\n                    var handle = scope_Handles[index];\r\n\r\n                    var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);\r\n                    var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);\r\n\r\n                    var now = positions[index];\r\n\r\n                    // Formatted value for display\r\n                    var text = options.ariaFormat.to(unencoded[index]);\r\n\r\n                    // Map to slider range values\r\n                    min = scope_Spectrum.fromStepping(min).toFixed(1);\r\n                    max = scope_Spectrum.fromStepping(max).toFixed(1);\r\n                    now = scope_Spectrum.fromStepping(now).toFixed(1);\r\n\r\n                    handle.children[0].setAttribute(\"aria-valuemin\", min);\r\n                    handle.children[0].setAttribute(\"aria-valuemax\", max);\r\n                    handle.children[0].setAttribute(\"aria-valuenow\", now);\r\n                    handle.children[0].setAttribute(\"aria-valuetext\", text);\r\n                });\r\n            });\r\n        }\r\n\r\n        function getGroup(mode, values, stepped) {\r\n            // Use the range.\r\n            if (mode === \"range\" || mode === \"steps\") {\r\n                return scope_Spectrum.xVal;\r\n            }\r\n\r\n            if (mode === \"count\") {\r\n                if (values < 2) {\r\n                    throw new Error(\"noUiSlider (\" + VERSION + \"): 'values' (>= 2) required for mode 'count'.\");\r\n                }\r\n\r\n                // Divide 0 - 100 in 'count' parts.\r\n                var interval = values - 1;\r\n                var spread = 100 / interval;\r\n\r\n                values = [];\r\n\r\n                // List these parts and have them handled as 'positions'.\r\n                while (interval--) {\r\n                    values[interval] = interval * spread;\r\n                }\r\n\r\n                values.push(100);\r\n\r\n                mode = \"positions\";\r\n            }\r\n\r\n            if (mode === \"positions\") {\r\n                // Map all percentages to on-range values.\r\n                return values.map(function(value) {\r\n                    return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);\r\n                });\r\n            }\r\n\r\n            if (mode === \"values\") {\r\n                // If the value must be stepped, it needs to be converted to a percentage first.\r\n                if (stepped) {\r\n                    return values.map(function(value) {\r\n                        // Convert to percentage, apply step, return to value.\r\n                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));\r\n                    });\r\n                }\r\n\r\n                // Otherwise, we can simply use the values.\r\n                return values;\r\n            }\r\n        }\r\n\r\n        function generateSpread(density, mode, group) {\r\n            function safeIncrement(value, increment) {\r\n                // Avoid floating point variance by dropping the smallest decimal places.\r\n                return (value + increment).toFixed(7) / 1;\r\n            }\r\n\r\n            var indexes = {};\r\n            var firstInRange = scope_Spectrum.xVal[0];\r\n            var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];\r\n            var ignoreFirst = false;\r\n            var ignoreLast = false;\r\n            var prevPct = 0;\r\n\r\n            // Create a copy of the group, sort it and filter away all duplicates.\r\n            group = unique(\r\n                group.slice().sort(function(a, b) {\r\n                    return a - b;\r\n                })\r\n            );\r\n\r\n            // Make sure the range starts with the first element.\r\n            if (group[0] !== firstInRange) {\r\n                group.unshift(firstInRange);\r\n                ignoreFirst = true;\r\n            }\r\n\r\n            // Likewise for the last one.\r\n            if (group[group.length - 1] !== lastInRange) {\r\n                group.push(lastInRange);\r\n                ignoreLast = true;\r\n            }\r\n\r\n            group.forEach(function(current, index) {\r\n                // Get the current step and the lower + upper positions.\r\n                var step;\r\n                var i;\r\n                var q;\r\n                var low = current;\r\n                var high = group[index + 1];\r\n                var newPct;\r\n                var pctDifference;\r\n                var pctPos;\r\n                var type;\r\n                var steps;\r\n                var realSteps;\r\n                var stepSize;\r\n                var isSteps = mode === \"steps\";\r\n\r\n                // When using 'steps' mode, use the provided steps.\r\n                // Otherwise, we'll step on to the next subrange.\r\n                if (isSteps) {\r\n                    step = scope_Spectrum.xNumSteps[index];\r\n                }\r\n\r\n                // Default to a 'full' step.\r\n                if (!step) {\r\n                    step = high - low;\r\n                }\r\n\r\n                // Low can be 0, so test for false. If high is undefined,\r\n                // we are at the last subrange. Index 0 is already handled.\r\n                if (low === false || high === undefined) {\r\n                    return;\r\n                }\r\n\r\n                // Make sure step isn't 0, which would cause an infinite loop (#654)\r\n                step = Math.max(step, 0.0000001);\r\n\r\n                // Find all steps in the subrange.\r\n                for (i = low; i <= high; i = safeIncrement(i, step)) {\r\n                    // Get the percentage value for the current step,\r\n                    // calculate the size for the subrange.\r\n                    newPct = scope_Spectrum.toStepping(i);\r\n                    pctDifference = newPct - prevPct;\r\n\r\n                    steps = pctDifference / density;\r\n                    realSteps = Math.round(steps);\r\n\r\n                    // This ratio represents the amount of percentage-space a point indicates.\r\n                    // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.\r\n                    // Round the percentage offset to an even number, then divide by two\r\n                    // to spread the offset on both sides of the range.\r\n                    stepSize = pctDifference / realSteps;\r\n\r\n                    // Divide all points evenly, adding the correct number to this subrange.\r\n                    // Run up to <= so that 100% gets a point, event if ignoreLast is set.\r\n                    for (q = 1; q <= realSteps; q += 1) {\r\n                        // The ratio between the rounded value and the actual size might be ~1% off.\r\n                        // Correct the percentage offset by the number of points\r\n                        // per subrange. density = 1 will result in 100 points on the\r\n                        // full range, 2 for 50, 4 for 25, etc.\r\n                        pctPos = prevPct + q * stepSize;\r\n                        indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];\r\n                    }\r\n\r\n                    // Determine the point type.\r\n                    type = group.indexOf(i) > -1 ? PIPS_LARGE_VALUE : isSteps ? PIPS_SMALL_VALUE : PIPS_NO_VALUE;\r\n\r\n                    // Enforce the 'ignoreFirst' option by overwriting the type for 0.\r\n                    if (!index && ignoreFirst) {\r\n                        type = 0;\r\n                    }\r\n\r\n                    if (!(i === high && ignoreLast)) {\r\n                        // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.\r\n                        indexes[newPct.toFixed(5)] = [i, type];\r\n                    }\r\n\r\n                    // Update the percentage count.\r\n                    prevPct = newPct;\r\n                }\r\n            });\r\n\r\n            return indexes;\r\n        }\r\n\r\n        function addMarking(spread, filterFunc, formatter) {\r\n            var element = scope_Document.createElement(\"div\");\r\n\r\n            var valueSizeClasses = [];\r\n            valueSizeClasses[PIPS_NO_VALUE] = options.cssClasses.valueNormal;\r\n            valueSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.valueLarge;\r\n            valueSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.valueSub;\r\n\r\n            var markerSizeClasses = [];\r\n            markerSizeClasses[PIPS_NO_VALUE] = options.cssClasses.markerNormal;\r\n            markerSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.markerLarge;\r\n            markerSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.markerSub;\r\n\r\n            var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];\r\n            var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];\r\n\r\n            addClass(element, options.cssClasses.pips);\r\n            addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);\r\n\r\n            function getClasses(type, source) {\r\n                var a = source === options.cssClasses.value;\r\n                var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;\r\n                var sizeClasses = a ? valueSizeClasses : markerSizeClasses;\r\n\r\n                return source + \" \" + orientationClasses[options.ort] + \" \" + sizeClasses[type];\r\n            }\r\n\r\n            function addSpread(offset, value, type) {\r\n                // Apply the filter function, if it is set.\r\n                type = filterFunc ? filterFunc(value, type) : type;\r\n\r\n                if (type === PIPS_NONE) {\r\n                    return;\r\n                }\r\n\r\n                // Add a marker for every point\r\n                var node = addNodeTo(element, false);\r\n                node.className = getClasses(type, options.cssClasses.marker);\r\n                node.style[options.style] = offset + \"%\";\r\n\r\n                // Values are only appended for points marked '1' or '2'.\r\n                if (type > PIPS_NO_VALUE) {\r\n                    node = addNodeTo(element, false);\r\n                    node.className = getClasses(type, options.cssClasses.value);\r\n                    node.setAttribute(\"data-value\", value);\r\n                    node.style[options.style] = offset + \"%\";\r\n                    node.innerHTML = formatter.to(value);\r\n                }\r\n            }\r\n\r\n            // Append all points.\r\n            Object.keys(spread).forEach(function(offset) {\r\n                addSpread(offset, spread[offset][0], spread[offset][1]);\r\n            });\r\n\r\n            return element;\r\n        }\r\n\r\n        function removePips() {\r\n            if (scope_Pips) {\r\n                removeElement(scope_Pips);\r\n                scope_Pips = null;\r\n            }\r\n        }\r\n\r\n        function pips(grid) {\r\n            // Fix #669\r\n            removePips();\r\n\r\n            var mode = grid.mode;\r\n            var density = grid.density || 1;\r\n            var filter = grid.filter || false;\r\n            var values = grid.values || false;\r\n            var stepped = grid.stepped || false;\r\n            var group = getGroup(mode, values, stepped);\r\n            var spread = generateSpread(density, mode, group);\r\n            var format = grid.format || {\r\n                to: Math.round\r\n            };\r\n\r\n            scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));\r\n\r\n            return scope_Pips;\r\n        }\r\n\r\n        // Shorthand for base dimensions.\r\n        function baseSize() {\r\n            var rect = scope_Base.getBoundingClientRect();\r\n            var alt = \"offset\" + [\"Width\", \"Height\"][options.ort];\r\n            return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];\r\n        }\r\n\r\n        // Handler for attaching events trough a proxy.\r\n        function attachEvent(events, element, callback, data) {\r\n            // This function can be used to 'filter' events to the slider.\r\n            // element is a node, not a nodeList\r\n\r\n            var method = function(e) {\r\n                e = fixEvent(e, data.pageOffset, data.target || element);\r\n\r\n                // fixEvent returns false if this event has a different target\r\n                // when handling (multi-) touch events;\r\n                if (!e) {\r\n                    return false;\r\n                }\r\n\r\n                // doNotReject is passed by all end events to make sure released touches\r\n                // are not rejected, leaving the slider \"stuck\" to the cursor;\r\n                if (scope_Target.hasAttribute(\"disabled\") && !data.doNotReject) {\r\n                    return false;\r\n                }\r\n\r\n                // Stop if an active 'tap' transition is taking place.\r\n                if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {\r\n                    return false;\r\n                }\r\n\r\n                // Ignore right or middle clicks on start #454\r\n                if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {\r\n                    return false;\r\n                }\r\n\r\n                // Ignore right or middle clicks on start #454\r\n                if (data.hover && e.buttons) {\r\n                    return false;\r\n                }\r\n\r\n                // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.\r\n                // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support\r\n                // touch-action: manipulation, but that allows panning, which breaks\r\n                // sliders after zooming/on non-responsive pages.\r\n                // See: https://bugs.webkit.org/show_bug.cgi?id=133112\r\n                if (!supportsPassive) {\r\n                    e.preventDefault();\r\n                }\r\n\r\n                e.calcPoint = e.points[options.ort];\r\n\r\n                // Call the event handler with the event [ and additional data ].\r\n                callback(e, data);\r\n            };\r\n\r\n            var methods = [];\r\n\r\n            // Bind a closure on the target for every event type.\r\n            events.split(\" \").forEach(function(eventName) {\r\n                element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);\r\n                methods.push([eventName, method]);\r\n            });\r\n\r\n            return methods;\r\n        }\r\n\r\n        // Provide a clean event with standardized offset values.\r\n        function fixEvent(e, pageOffset, eventTarget) {\r\n            // Filter the event to register the type, which can be\r\n            // touch, mouse or pointer. Offset changes need to be\r\n            // made on an event specific basis.\r\n            var touch = e.type.indexOf(\"touch\") === 0;\r\n            var mouse = e.type.indexOf(\"mouse\") === 0;\r\n            var pointer = e.type.indexOf(\"pointer\") === 0;\r\n\r\n            var x;\r\n            var y;\r\n\r\n            // IE10 implemented pointer events with a prefix;\r\n            if (e.type.indexOf(\"MSPointer\") === 0) {\r\n                pointer = true;\r\n            }\r\n\r\n            // The only thing one handle should be concerned about is the touches that originated on top of it.\r\n            if (touch) {\r\n                // Returns true if a touch originated on the target.\r\n                var isTouchOnTarget = function(checkTouch) {\r\n                    return checkTouch.target === eventTarget || eventTarget.contains(checkTouch.target);\r\n                };\r\n\r\n                // In the case of touchstart events, we need to make sure there is still no more than one\r\n                // touch on the target so we look amongst all touches.\r\n                if (e.type === \"touchstart\") {\r\n                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);\r\n\r\n                    // Do not support more than one touch per handle.\r\n                    if (targetTouches.length > 1) {\r\n                        return false;\r\n                    }\r\n\r\n                    x = targetTouches[0].pageX;\r\n                    y = targetTouches[0].pageY;\r\n                } else {\r\n                    // In the other cases, find on changedTouches is enough.\r\n                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);\r\n\r\n                    // Cancel if the target touch has not moved.\r\n                    if (!targetTouch) {\r\n                        return false;\r\n                    }\r\n\r\n                    x = targetTouch.pageX;\r\n                    y = targetTouch.pageY;\r\n                }\r\n            }\r\n\r\n            pageOffset = pageOffset || getPageOffset(scope_Document);\r\n\r\n            if (mouse || pointer) {\r\n                x = e.clientX + pageOffset.x;\r\n                y = e.clientY + pageOffset.y;\r\n            }\r\n\r\n            e.pageOffset = pageOffset;\r\n            e.points = [x, y];\r\n            e.cursor = mouse || pointer; // Fix #435\r\n\r\n            return e;\r\n        }\r\n\r\n        // Translate a coordinate in the document to a percentage on the slider\r\n        function calcPointToPercentage(calcPoint) {\r\n            var location = calcPoint - offset(scope_Base, options.ort);\r\n            var proposal = (location * 100) / baseSize();\r\n\r\n            // Clamp proposal between 0% and 100%\r\n            // Out-of-bound coordinates may occur when .noUi-base pseudo-elements\r\n            // are used (e.g. contained handles feature)\r\n            proposal = limit(proposal);\r\n\r\n            return options.dir ? 100 - proposal : proposal;\r\n        }\r\n\r\n        // Find handle closest to a certain percentage on the slider\r\n        function getClosestHandle(proposal) {\r\n            var closest = 100;\r\n            var handleNumber = false;\r\n\r\n            scope_Handles.forEach(function(handle, index) {\r\n                // Disabled handles are ignored\r\n                if (handle.hasAttribute(\"disabled\")) {\r\n                    return;\r\n                }\r\n\r\n                var pos = Math.abs(scope_Locations[index] - proposal);\r\n\r\n                if (pos < closest || (pos === 100 && closest === 100)) {\r\n                    handleNumber = index;\r\n                    closest = pos;\r\n                }\r\n            });\r\n\r\n            return handleNumber;\r\n        }\r\n\r\n        // Fire 'end' when a mouse or pen leaves the document.\r\n        function documentLeave(event, data) {\r\n            if (event.type === \"mouseout\" && event.target.nodeName === \"HTML\" && event.relatedTarget === null) {\r\n                eventEnd(event, data);\r\n            }\r\n        }\r\n\r\n        // Handle movement on document for handle and range drag.\r\n        function eventMove(event, data) {\r\n            // Fix #498\r\n            // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).\r\n            // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero\r\n            // IE9 has .buttons and .which zero on mousemove.\r\n            // Firefox breaks the spec MDN defines.\r\n            if (navigator.appVersion.indexOf(\"MSIE 9\") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {\r\n                return eventEnd(event, data);\r\n            }\r\n\r\n            // Check if we are moving up or down\r\n            var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);\r\n\r\n            // Convert the movement into a percentage of the slider width/height\r\n            var proposal = (movement * 100) / data.baseSize;\r\n\r\n            moveHandles(movement > 0, proposal, data.locations, data.handleNumbers);\r\n        }\r\n\r\n        // Unbind move events on document, call callbacks.\r\n        function eventEnd(event, data) {\r\n            // The handle is no longer active, so remove the class.\r\n            if (data.handle) {\r\n                removeClass(data.handle, options.cssClasses.active);\r\n                scope_ActiveHandlesCount -= 1;\r\n            }\r\n\r\n            // Unbind the move and end events, which are added on 'start'.\r\n            data.listeners.forEach(function(c) {\r\n                scope_DocumentElement.removeEventListener(c[0], c[1]);\r\n            });\r\n\r\n            if (scope_ActiveHandlesCount === 0) {\r\n                // Remove dragging class.\r\n                removeClass(scope_Target, options.cssClasses.drag);\r\n                setZindex();\r\n\r\n                // Remove cursor styles and text-selection events bound to the body.\r\n                if (event.cursor) {\r\n                    scope_Body.style.cursor = \"\";\r\n                    scope_Body.removeEventListener(\"selectstart\", preventDefault);\r\n                }\r\n            }\r\n\r\n            data.handleNumbers.forEach(function(handleNumber) {\r\n                fireEvent(\"change\", handleNumber);\r\n                fireEvent(\"set\", handleNumber);\r\n                fireEvent(\"end\", handleNumber);\r\n            });\r\n        }\r\n\r\n        // Bind move events on document.\r\n        function eventStart(event, data) {\r\n            var handle;\r\n            if (data.handleNumbers.length === 1) {\r\n                var handleOrigin = scope_Handles[data.handleNumbers[0]];\r\n\r\n                // Ignore 'disabled' handles\r\n                if (handleOrigin.hasAttribute(\"disabled\")) {\r\n                    return false;\r\n                }\r\n\r\n                handle = handleOrigin.children[0];\r\n                scope_ActiveHandlesCount += 1;\r\n\r\n                // Mark the handle as 'active' so it can be styled.\r\n                addClass(handle, options.cssClasses.active);\r\n            }\r\n\r\n            // A drag should never propagate up to the 'tap' event.\r\n            event.stopPropagation();\r\n\r\n            // Record the event listeners.\r\n            var listeners = [];\r\n\r\n            // Attach the move and end events.\r\n            var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {\r\n                // The event target has changed so we need to propagate the original one so that we keep\r\n                // relying on it to extract target touches.\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                startCalcPoint: event.calcPoint,\r\n                baseSize: baseSize(),\r\n                pageOffset: event.pageOffset,\r\n                handleNumbers: data.handleNumbers,\r\n                buttonsProperty: event.buttons,\r\n                locations: scope_Locations.slice()\r\n            });\r\n\r\n            var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                doNotReject: true,\r\n                handleNumbers: data.handleNumbers\r\n            });\r\n\r\n            var outEvent = attachEvent(\"mouseout\", scope_DocumentElement, documentLeave, {\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                doNotReject: true,\r\n                handleNumbers: data.handleNumbers\r\n            });\r\n\r\n            // We want to make sure we pushed the listeners in the listener list rather than creating\r\n            // a new one as it has already been passed to the event handlers.\r\n            listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));\r\n\r\n            // Text selection isn't an issue on touch devices,\r\n            // so adding cursor styles can be skipped.\r\n            if (event.cursor) {\r\n                // Prevent the 'I' cursor and extend the range-drag cursor.\r\n                scope_Body.style.cursor = getComputedStyle(event.target).cursor;\r\n\r\n                // Mark the target with a dragging state.\r\n                if (scope_Handles.length > 1) {\r\n                    addClass(scope_Target, options.cssClasses.drag);\r\n                }\r\n\r\n                // Prevent text selection when dragging the handles.\r\n                // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,\r\n                // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,\r\n                // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.\r\n                // The 'cursor' flag is false.\r\n                // See: http://caniuse.com/#search=selectstart\r\n                scope_Body.addEventListener(\"selectstart\", preventDefault, false);\r\n            }\r\n\r\n            data.handleNumbers.forEach(function(handleNumber) {\r\n                fireEvent(\"start\", handleNumber);\r\n            });\r\n        }\r\n\r\n        // Move closest handle to tapped location.\r\n        function eventTap(event) {\r\n            // The tap event shouldn't propagate up\r\n            event.stopPropagation();\r\n\r\n            var proposal = calcPointToPercentage(event.calcPoint);\r\n            var handleNumber = getClosestHandle(proposal);\r\n\r\n            // Tackle the case that all handles are 'disabled'.\r\n            if (handleNumber === false) {\r\n                return false;\r\n            }\r\n\r\n            // Flag the slider as it is now in a transitional state.\r\n            // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.\r\n            if (!options.events.snap) {\r\n                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\r\n            }\r\n\r\n            setHandle(handleNumber, proposal, true, true);\r\n\r\n            setZindex();\r\n\r\n            fireEvent(\"slide\", handleNumber, true);\r\n            fireEvent(\"update\", handleNumber, true);\r\n            fireEvent(\"change\", handleNumber, true);\r\n            fireEvent(\"set\", handleNumber, true);\r\n\r\n            if (options.events.snap) {\r\n                eventStart(event, { handleNumbers: [handleNumber] });\r\n            }\r\n        }\r\n\r\n        // Fires a 'hover' event for a hovered mouse/pen position.\r\n        function eventHover(event) {\r\n            var proposal = calcPointToPercentage(event.calcPoint);\r\n\r\n            var to = scope_Spectrum.getStep(proposal);\r\n            var value = scope_Spectrum.fromStepping(to);\r\n\r\n            Object.keys(scope_Events).forEach(function(targetEvent) {\r\n                if (\"hover\" === targetEvent.split(\".\")[0]) {\r\n                    scope_Events[targetEvent].forEach(function(callback) {\r\n                        callback.call(scope_Self, value);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        // Attach events to several slider parts.\r\n        function bindSliderEvents(behaviour) {\r\n            // Attach the standard drag event to the handles.\r\n            if (!behaviour.fixed) {\r\n                scope_Handles.forEach(function(handle, index) {\r\n                    // These events are only bound to the visual handle\r\n                    // element, not the 'real' origin element.\r\n                    attachEvent(actions.start, handle.children[0], eventStart, {\r\n                        handleNumbers: [index]\r\n                    });\r\n                });\r\n            }\r\n\r\n            // Attach the tap event to the slider base.\r\n            if (behaviour.tap) {\r\n                attachEvent(actions.start, scope_Base, eventTap, {});\r\n            }\r\n\r\n            // Fire hover events\r\n            if (behaviour.hover) {\r\n                attachEvent(actions.move, scope_Base, eventHover, {\r\n                    hover: true\r\n                });\r\n            }\r\n\r\n            // Make the range draggable.\r\n            if (behaviour.drag) {\r\n                scope_Connects.forEach(function(connect, index) {\r\n                    if (connect === false || index === 0 || index === scope_Connects.length - 1) {\r\n                        return;\r\n                    }\r\n\r\n                    var handleBefore = scope_Handles[index - 1];\r\n                    var handleAfter = scope_Handles[index];\r\n                    var eventHolders = [connect];\r\n\r\n                    addClass(connect, options.cssClasses.draggable);\r\n\r\n                    // When the range is fixed, the entire range can\r\n                    // be dragged by the handles. The handle in the first\r\n                    // origin will propagate the start event upward,\r\n                    // but it needs to be bound manually on the other.\r\n                    if (behaviour.fixed) {\r\n                        eventHolders.push(handleBefore.children[0]);\r\n                        eventHolders.push(handleAfter.children[0]);\r\n                    }\r\n\r\n                    eventHolders.forEach(function(eventHolder) {\r\n                        attachEvent(actions.start, eventHolder, eventStart, {\r\n                            handles: [handleBefore, handleAfter],\r\n                            handleNumbers: [index - 1, index]\r\n                        });\r\n                    });\r\n                });\r\n            }\r\n        }\r\n\r\n        // Attach an event to this slider, possibly including a namespace\r\n        function bindEvent(namespacedEvent, callback) {\r\n            scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];\r\n            scope_Events[namespacedEvent].push(callback);\r\n\r\n            // If the event bound is 'update,' fire it immediately for all handles.\r\n            if (namespacedEvent.split(\".\")[0] === \"update\") {\r\n                scope_Handles.forEach(function(a, index) {\r\n                    fireEvent(\"update\", index);\r\n                });\r\n            }\r\n        }\r\n\r\n        // Undo attachment of event\r\n        function removeEvent(namespacedEvent) {\r\n            var event = namespacedEvent && namespacedEvent.split(\".\")[0];\r\n            var namespace = event && namespacedEvent.substring(event.length);\r\n\r\n            Object.keys(scope_Events).forEach(function(bind) {\r\n                var tEvent = bind.split(\".\")[0];\r\n                var tNamespace = bind.substring(tEvent.length);\r\n\r\n                if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {\r\n                    delete scope_Events[bind];\r\n                }\r\n            });\r\n        }\r\n\r\n        // External event handling\r\n        function fireEvent(eventName, handleNumber, tap) {\r\n            Object.keys(scope_Events).forEach(function(targetEvent) {\r\n                var eventType = targetEvent.split(\".\")[0];\r\n\r\n                if (eventName === eventType) {\r\n                    scope_Events[targetEvent].forEach(function(callback) {\r\n                        callback.call(\r\n                            // Use the slider public API as the scope ('this')\r\n                            scope_Self,\r\n                            // Return values as array, so arg_1[arg_2] is always valid.\r\n                            scope_Values.map(options.format.to),\r\n                            // Handle index, 0 or 1\r\n                            handleNumber,\r\n                            // Un-formatted slider values\r\n                            scope_Values.slice(),\r\n                            // Event is fired by tap, true or false\r\n                            tap || false,\r\n                            // Left offset of the handle, in relation to the slider\r\n                            scope_Locations.slice()\r\n                        );\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        function toPct(pct) {\r\n            return pct + \"%\";\r\n        }\r\n\r\n        // Split out the handle positioning logic so the Move event can use it, too\r\n        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {\r\n            // For sliders with multiple handles, limit movement to the other handle.\r\n            // Apply the margin option by adding it to the handle positions.\r\n            if (scope_Handles.length > 1 && !options.events.unconstrained) {\r\n                if (lookBackward && handleNumber > 0) {\r\n                    to = Math.max(to, reference[handleNumber - 1] + options.margin);\r\n                }\r\n\r\n                if (lookForward && handleNumber < scope_Handles.length - 1) {\r\n                    to = Math.min(to, reference[handleNumber + 1] - options.margin);\r\n                }\r\n            }\r\n\r\n            // The limit option has the opposite effect, limiting handles to a\r\n            // maximum distance from another. Limit must be > 0, as otherwise\r\n            // handles would be unmovable.\r\n            if (scope_Handles.length > 1 && options.limit) {\r\n                if (lookBackward && handleNumber > 0) {\r\n                    to = Math.min(to, reference[handleNumber - 1] + options.limit);\r\n                }\r\n\r\n                if (lookForward && handleNumber < scope_Handles.length - 1) {\r\n                    to = Math.max(to, reference[handleNumber + 1] - options.limit);\r\n                }\r\n            }\r\n\r\n            // The padding option keeps the handles a certain distance from the\r\n            // edges of the slider. Padding must be > 0.\r\n            if (options.padding) {\r\n                if (handleNumber === 0) {\r\n                    to = Math.max(to, options.padding[0]);\r\n                }\r\n\r\n                if (handleNumber === scope_Handles.length - 1) {\r\n                    to = Math.min(to, 100 - options.padding[1]);\r\n                }\r\n            }\r\n\r\n            to = scope_Spectrum.getStep(to);\r\n\r\n            // Limit percentage to the 0 - 100 range\r\n            to = limit(to);\r\n\r\n            // Return false if handle can't move\r\n            if (to === reference[handleNumber] && !getValue) {\r\n                return false;\r\n            }\r\n\r\n            return to;\r\n        }\r\n\r\n        // Uses slider orientation to create CSS rules. a = base value;\r\n        function inRuleOrder(v, a) {\r\n            var o = options.ort;\r\n            return (o ? a : v) + \", \" + (o ? v : a);\r\n        }\r\n\r\n        // Moves handle(s) by a percentage\r\n        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])\r\n        function moveHandles(upward, proposal, locations, handleNumbers) {\r\n            var proposals = locations.slice();\r\n\r\n            var b = [!upward, upward];\r\n            var f = [upward, !upward];\r\n\r\n            // Copy handleNumbers so we don't change the dataset\r\n            handleNumbers = handleNumbers.slice();\r\n\r\n            // Check to see which handle is 'leading'.\r\n            // If that one can't move the second can't either.\r\n            if (upward) {\r\n                handleNumbers.reverse();\r\n            }\r\n\r\n            // Step 1: get the maximum percentage that any of the handles can move\r\n            if (handleNumbers.length > 1) {\r\n                handleNumbers.forEach(function(handleNumber, o) {\r\n                    var to = checkHandlePosition(\r\n                        proposals,\r\n                        handleNumber,\r\n                        proposals[handleNumber] + proposal,\r\n                        b[o],\r\n                        f[o],\r\n                        false\r\n                    );\r\n\r\n                    // Stop if one of the handles can't move.\r\n                    if (to === false) {\r\n                        proposal = 0;\r\n                    } else {\r\n                        proposal = to - proposals[handleNumber];\r\n                        proposals[handleNumber] = to;\r\n                    }\r\n                });\r\n            }\r\n\r\n            // If using one handle, check backward AND forward\r\n            else {\r\n                b = f = [true];\r\n            }\r\n\r\n            var state = false;\r\n\r\n            // Step 2: Try to set the handles with the found percentage\r\n            handleNumbers.forEach(function(handleNumber, o) {\r\n                state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;\r\n            });\r\n\r\n            // Step 3: If a handle moved, fire events\r\n            if (state) {\r\n                handleNumbers.forEach(function(handleNumber) {\r\n                    fireEvent(\"update\", handleNumber);\r\n                    fireEvent(\"slide\", handleNumber);\r\n                });\r\n            }\r\n        }\r\n\r\n        // Takes a base value and an offset. This offset is used for the connect bar size.\r\n        // In the initial design for this feature, the origin element was 1% wide.\r\n        // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature\r\n        // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223\r\n        function transformDirection(a, b) {\r\n            return options.dir ? 100 - a - b : a;\r\n        }\r\n\r\n        // Updates scope_Locations and scope_Values, updates visual state\r\n        function updateHandlePosition(handleNumber, to) {\r\n            // Update locations.\r\n            scope_Locations[handleNumber] = to;\r\n\r\n            // Convert the value to the slider stepping/range.\r\n            scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);\r\n\r\n            var rule = \"translate(\" + inRuleOrder(toPct(transformDirection(to, 0) - scope_DirOffset), \"0\") + \")\";\r\n            scope_Handles[handleNumber].style[options.transformRule] = rule;\r\n\r\n            updateConnect(handleNumber);\r\n            updateConnect(handleNumber + 1);\r\n        }\r\n\r\n        // Handles before the slider middle are stacked later = higher,\r\n        // Handles after the middle later is lower\r\n        // [[7] [8] .......... | .......... [5] [4]\r\n        function setZindex() {\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;\r\n                var zIndex = 3 + (scope_Handles.length + dir * handleNumber);\r\n                scope_Handles[handleNumber].style.zIndex = zIndex;\r\n            });\r\n        }\r\n\r\n        // Test suggested values and apply margin, step.\r\n        function setHandle(handleNumber, to, lookBackward, lookForward) {\r\n            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);\r\n\r\n            if (to === false) {\r\n                return false;\r\n            }\r\n\r\n            updateHandlePosition(handleNumber, to);\r\n\r\n            return true;\r\n        }\r\n\r\n        // Updates style attribute for connect nodes\r\n        function updateConnect(index) {\r\n            // Skip connects set to false\r\n            if (!scope_Connects[index]) {\r\n                return;\r\n            }\r\n\r\n            var l = 0;\r\n            var h = 100;\r\n\r\n            if (index !== 0) {\r\n                l = scope_Locations[index - 1];\r\n            }\r\n\r\n            if (index !== scope_Connects.length - 1) {\r\n                h = scope_Locations[index];\r\n            }\r\n\r\n            // We use two rules:\r\n            // 'translate' to change the left/top offset;\r\n            // 'scale' to change the width of the element;\r\n            // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)\r\n            var connectWidth = h - l;\r\n            var translateRule = \"translate(\" + inRuleOrder(toPct(transformDirection(l, connectWidth)), \"0\") + \")\";\r\n            var scaleRule = \"scale(\" + inRuleOrder(connectWidth / 100, \"1\") + \")\";\r\n\r\n            scope_Connects[index].style[options.transformRule] = translateRule + \" \" + scaleRule;\r\n        }\r\n\r\n        // Parses value passed to .set method. Returns current value if not parse-able.\r\n        function resolveToValue(to, handleNumber) {\r\n            // Setting with null indicates an 'ignore'.\r\n            // Inputting 'false' is invalid.\r\n            if (to === null || to === false || to === undefined) {\r\n                return scope_Locations[handleNumber];\r\n            }\r\n\r\n            // If a formatted number was passed, attempt to decode it.\r\n            if (typeof to === \"number\") {\r\n                to = String(to);\r\n            }\r\n\r\n            to = options.format.from(to);\r\n            to = scope_Spectrum.toStepping(to);\r\n\r\n            // If parsing the number failed, use the current value.\r\n            if (to === false || isNaN(to)) {\r\n                return scope_Locations[handleNumber];\r\n            }\r\n\r\n            return to;\r\n        }\r\n\r\n        // Set the slider value.\r\n        function valueSet(input, fireSetEvent) {\r\n            var values = asArray(input);\r\n            var isInit = scope_Locations[0] === undefined;\r\n\r\n            // Event fires by default\r\n            fireSetEvent = fireSetEvent === undefined ? true : !!fireSetEvent;\r\n\r\n            // Animation is optional.\r\n            // Make sure the initial values were set before using animated placement.\r\n            if (options.animate && !isInit) {\r\n                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\r\n            }\r\n\r\n            // First pass, without lookAhead but with lookBackward. Values are set from left to right.\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false);\r\n            });\r\n\r\n            // Second pass. Now that all base values are set, apply constraints\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                setHandle(handleNumber, scope_Locations[handleNumber], true, true);\r\n            });\r\n\r\n            setZindex();\r\n\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                fireEvent(\"update\", handleNumber);\r\n\r\n                // Fire the event only for handles that received a new value, as per #579\r\n                if (values[handleNumber] !== null && fireSetEvent) {\r\n                    fireEvent(\"set\", handleNumber);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Reset slider to initial values\r\n        function valueReset(fireSetEvent) {\r\n            valueSet(options.start, fireSetEvent);\r\n        }\r\n\r\n        // Set value for a single handle\r\n        function valueSetHandle(handleNumber, value, fireSetEvent) {\r\n            var values = [];\r\n\r\n            // Ensure numeric input\r\n            handleNumber = Number(handleNumber);\r\n\r\n            if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {\r\n                throw new Error(\"noUiSlider (\" + VERSION + \"): invalid handle number, got: \" + handleNumber);\r\n            }\r\n\r\n            for (var i = 0; i < scope_HandleNumbers.length; i++) {\r\n                values[i] = null;\r\n            }\r\n\r\n            values[handleNumber] = value;\r\n\r\n            valueSet(values, fireSetEvent);\r\n        }\r\n\r\n        // Get the slider value.\r\n        function valueGet() {\r\n            var values = scope_Values.map(options.format.to);\r\n\r\n            // If only one handle is used, return a single value.\r\n            if (values.length === 1) {\r\n                return values[0];\r\n            }\r\n\r\n            return values;\r\n        }\r\n\r\n        // Removes classes from the root and empties it.\r\n        function destroy() {\r\n            for (var key in options.cssClasses) {\r\n                if (!options.cssClasses.hasOwnProperty(key)) {\r\n                    continue;\r\n                }\r\n                removeClass(scope_Target, options.cssClasses[key]);\r\n            }\r\n\r\n            while (scope_Target.firstChild) {\r\n                scope_Target.removeChild(scope_Target.firstChild);\r\n            }\r\n\r\n            delete scope_Target.noUiSlider;\r\n        }\r\n\r\n        // Get the current step size for the slider.\r\n        function getCurrentStep() {\r\n            // Check all locations, map them to their stepping point.\r\n            // Get the step point, then find it in the input list.\r\n            return scope_Locations.map(function(location, index) {\r\n                var nearbySteps = scope_Spectrum.getNearbySteps(location);\r\n                var value = scope_Values[index];\r\n                var increment = nearbySteps.thisStep.step;\r\n                var decrement = null;\r\n\r\n                // If the next value in this step moves into the next step,\r\n                // the increment is the start of the next step - the current value\r\n                if (increment !== false) {\r\n                    if (value + increment > nearbySteps.stepAfter.startValue) {\r\n                        increment = nearbySteps.stepAfter.startValue - value;\r\n                    }\r\n                }\r\n\r\n                // If the value is beyond the starting point\r\n                if (value > nearbySteps.thisStep.startValue) {\r\n                    decrement = nearbySteps.thisStep.step;\r\n                } else if (nearbySteps.stepBefore.step === false) {\r\n                    decrement = false;\r\n                }\r\n\r\n                // If a handle is at the start of a step, it always steps back into the previous step first\r\n                else {\r\n                    decrement = value - nearbySteps.stepBefore.highestStep;\r\n                }\r\n\r\n                // Now, if at the slider edges, there is not in/decrement\r\n                if (location === 100) {\r\n                    increment = null;\r\n                } else if (location === 0) {\r\n                    decrement = null;\r\n                }\r\n\r\n                // As per #391, the comparison for the decrement step can have some rounding issues.\r\n                var stepDecimals = scope_Spectrum.countStepDecimals();\r\n\r\n                // Round per #391\r\n                if (increment !== null && increment !== false) {\r\n                    increment = Number(increment.toFixed(stepDecimals));\r\n                }\r\n\r\n                if (decrement !== null && decrement !== false) {\r\n                    decrement = Number(decrement.toFixed(stepDecimals));\r\n                }\r\n\r\n                return [decrement, increment];\r\n            });\r\n        }\r\n\r\n        // Updateable: margin, limit, padding, step, range, animate, snap\r\n        function updateOptions(optionsToUpdate, fireSetEvent) {\r\n            // Spectrum is created using the range, snap, direction and step options.\r\n            // 'snap' and 'step' can be updated.\r\n            // If 'snap' and 'step' are not passed, they should remain unchanged.\r\n            var v = valueGet();\r\n\r\n            var updateAble = [\"margin\", \"limit\", \"padding\", \"range\", \"animate\", \"snap\", \"step\", \"format\"];\r\n\r\n            // Only change options that we're actually passed to update.\r\n            updateAble.forEach(function(name) {\r\n                if (optionsToUpdate[name] !== undefined) {\r\n                    originalOptions[name] = optionsToUpdate[name];\r\n                }\r\n            });\r\n\r\n            var newOptions = testOptions(originalOptions);\r\n\r\n            // Load new options into the slider state\r\n            updateAble.forEach(function(name) {\r\n                if (optionsToUpdate[name] !== undefined) {\r\n                    options[name] = newOptions[name];\r\n                }\r\n            });\r\n\r\n            scope_Spectrum = newOptions.spectrum;\r\n\r\n            // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)\r\n            options.margin = newOptions.margin;\r\n            options.limit = newOptions.limit;\r\n            options.padding = newOptions.padding;\r\n\r\n            // Update pips, removes existing.\r\n            if (options.pips) {\r\n                pips(options.pips);\r\n            }\r\n\r\n            // Invalidate the current positioning so valueSet forces an update.\r\n            scope_Locations = [];\r\n            valueSet(optionsToUpdate.start || v, fireSetEvent);\r\n        }\r\n\r\n        // Create the base element, initialize HTML and set classes.\r\n        // Add handles and connect elements.\r\n        scope_Base = addSlider(scope_Target);\r\n        addElements(options.connect, scope_Base);\r\n\r\n        // Attach user events.\r\n        bindSliderEvents(options.events);\r\n\r\n        // Use the public value method to set the start values.\r\n        valueSet(options.start);\r\n\r\n        // noinspection JSUnusedGlobalSymbols\r\n        scope_Self = {\r\n            destroy: destroy,\r\n            steps: getCurrentStep,\r\n            on: bindEvent,\r\n            off: removeEvent,\r\n            get: valueGet,\r\n            set: valueSet,\r\n            setHandle: valueSetHandle,\r\n            reset: valueReset,\r\n            // Exposed for unit testing, don't use this in your application.\r\n            __moveHandles: function(a, b, c) {\r\n                moveHandles(a, b, scope_Locations, c);\r\n            },\r\n            options: originalOptions, // Issue #600, #678\r\n            updateOptions: updateOptions,\r\n            target: scope_Target, // Issue #597\r\n            removePips: removePips,\r\n            pips: pips // Issue #594\r\n        };\r\n\r\n        if (options.pips) {\r\n            pips(options.pips);\r\n        }\r\n\r\n        if (options.tooltips) {\r\n            tooltips();\r\n        }\r\n\r\n        aria();\r\n\r\n        return scope_Self;\r\n    }\r\n\r\n    // Run the standard initializer\r\n    function initialize(target, originalOptions) {\r\n        if (!target || !target.nodeName) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): create requires a single element, got: \" + target);\r\n        }\r\n\r\n        // Throw an error if the slider was already initialized.\r\n        if (target.noUiSlider) {\r\n            throw new Error(\"noUiSlider (\" + VERSION + \"): Slider was already initialized.\");\r\n        }\r\n\r\n        // Test the options and create the slider environment;\r\n        var options = testOptions(originalOptions, target);\r\n        var api = scope(target, options, originalOptions);\r\n\r\n        target.noUiSlider = api;\r\n\r\n        return api;\r\n    }\r\n\r\n    // Use an object instead of a function for future expandability;\r\n    return {\r\n        // Exposed for unit testing, don't use this in your application.\r\n        __spectrum: Spectrum,\r\n        version: VERSION,\r\n        create: initialize\r\n    };\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm91aXNsaWRlci9kaXN0cmlidXRlL25vdWlzbGlkZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm91aXNsaWRlci9kaXN0cmlidXRlL25vdWlzbGlkZXIuanM/ZTlmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm91aXNsaWRlciAtIDEyLjEuMCAtIDEwLzI1LzIwMTggKi9cbihmdW5jdGlvbihmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAvLyBOb2RlL0NvbW1vbkpTXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xyXG4gICAgICAgIHdpbmRvdy5ub1VpU2xpZGVyID0gZmFjdG9yeSgpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbigpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBWRVJTSU9OID0gXCIxMi4xLjBcIjtcclxuXHJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRm9ybWF0dGVyKGVudHJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZW50cnkudG8gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZW50cnkuZnJvbSA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcclxuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJpbmRhYmxlIHZlcnNpb25cclxuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlcyBkdXBsaWNhdGVzIGZyb20gYW4gYXJyYXkuXHJcbiAgICBmdW5jdGlvbiB1bmlxdWUoYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzW2FdID8gKHRoaXNbYV0gPSB0cnVlKSA6IGZhbHNlO1xyXG4gICAgICAgIH0sIHt9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSb3VuZCBhIHZhbHVlIHRvIHRoZSBjbG9zZXN0ICd0bycuXHJcbiAgICBmdW5jdGlvbiBjbG9zZXN0KHZhbHVlLCB0bykge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gdG8pICogdG87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3VycmVudCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudC5cclxuICAgIGZ1bmN0aW9uIG9mZnNldChlbGVtLCBvcmllbnRhdGlvbikge1xyXG4gICAgICAgIHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB2YXIgZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xyXG4gICAgICAgIHZhciBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IGdldFBhZ2VPZmZzZXQoZG9jKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNvbnRhaW5zIGxlZnQgc2Nyb2xsIGluIENocm9tZSBvbiBBbmRyb2lkLlxyXG4gICAgICAgIC8vIEkgaGF2ZW4ndCBmb3VuZCBhIGZlYXR1cmUgZGV0ZWN0aW9uIHRoYXQgcHJvdmVzIHRoaXMuIFdvcnN0IGNhc2VcclxuICAgICAgICAvLyBzY2VuYXJpbyBvbiBtaXMtbWF0Y2g6IHRoZSAndGFwJyBmZWF0dXJlIG9uIGhvcml6b250YWwgc2xpZGVycyBicmVha3MuXHJcbiAgICAgICAgaWYgKC93ZWJraXQuKkNocm9tZS4qTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xyXG4gICAgICAgICAgICBwYWdlT2Zmc2V0LnggPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uXHJcbiAgICAgICAgICAgID8gcmVjdC50b3AgKyBwYWdlT2Zmc2V0LnkgLSBkb2NFbGVtLmNsaWVudFRvcFxyXG4gICAgICAgICAgICA6IHJlY3QubGVmdCArIHBhZ2VPZmZzZXQueCAtIGRvY0VsZW0uY2xpZW50TGVmdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIG51bWVyaWNhbC5cclxuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhhKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSBcIm51bWJlclwiICYmICFpc05hTihhKSAmJiBpc0Zpbml0ZShhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXRzIGEgY2xhc3MgYW5kIHJlbW92ZXMgaXQgYWZ0ZXIgW2R1cmF0aW9uXSBtcy5cclxuICAgIGZ1bmN0aW9uIGFkZENsYXNzRm9yKGVsZW1lbnQsIGNsYXNzTmFtZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9LCBkdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIExpbWl0cyBhIHZhbHVlIHRvIDAgLSAxMDBcclxuICAgIGZ1bmN0aW9uIGxpbWl0KGEpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oYSwgMTAwKSwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV3JhcHMgYSB2YXJpYWJsZSBhcyBhbiBhcnJheSwgaWYgaXQgaXNuJ3Qgb25lIHlldC5cclxuICAgIC8vIE5vdGUgdGhhdCBhbiBpbnB1dCBhcnJheSBpcyByZXR1cm5lZCBieSByZWZlcmVuY2UhXHJcbiAgICBmdW5jdGlvbiBhc0FycmF5KGEpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ291bnRzIGRlY2ltYWxzXHJcbiAgICBmdW5jdGlvbiBjb3VudERlY2ltYWxzKG51bVN0cikge1xyXG4gICAgICAgIG51bVN0ciA9IFN0cmluZyhudW1TdHIpO1xyXG4gICAgICAgIHZhciBwaWVjZXMgPSBudW1TdHIuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgIHJldHVybiBwaWVjZXMubGVuZ3RoID4gMSA/IHBpZWNlc1sxXS5sZW5ndGggOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNhZGRfY2xhc3NcclxuICAgIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbGFzc05hbWUpIHtcclxuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNyZW1vdmVfY2xhc3NcclxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcclxuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShcclxuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoXCIoXnxcXFxcYilcIiArIGNsYXNzTmFtZS5zcGxpdChcIiBcIikuam9pbihcInxcIikgKyBcIihcXFxcYnwkKVwiLCBcImdpXCIpLFxyXG4gICAgICAgICAgICAgICAgXCIgXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaHR0cHM6Ly9wbGFpbmpzLmNvbS9qYXZhc2NyaXB0L2F0dHJpYnV0ZXMvYWRkaW5nLXJlbW92aW5nLWFuZC10ZXN0aW5nLWZvci1jbGFzc2VzLTkvXHJcbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdFxyXG4gICAgICAgICAgICA/IGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXHJcbiAgICAgICAgICAgIDogbmV3IFJlZ0V4cChcIlxcXFxiXCIgKyBjbGFzc05hbWUgKyBcIlxcXFxiXCIpLnRlc3QoZWwuY2xhc3NOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3Njcm9sbFkjTm90ZXNcclxuICAgIGZ1bmN0aW9uIGdldFBhZ2VPZmZzZXQoZG9jKSB7XHJcbiAgICAgICAgdmFyIHN1cHBvcnRQYWdlT2Zmc2V0ID0gd2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGlzQ1NTMUNvbXBhdCA9IChkb2MuY29tcGF0TW9kZSB8fCBcIlwiKSA9PT0gXCJDU1MxQ29tcGF0XCI7XHJcbiAgICAgICAgdmFyIHggPSBzdXBwb3J0UGFnZU9mZnNldFxyXG4gICAgICAgICAgICA/IHdpbmRvdy5wYWdlWE9mZnNldFxyXG4gICAgICAgICAgICA6IGlzQ1NTMUNvbXBhdFxyXG4gICAgICAgICAgICAgICAgPyBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRcclxuICAgICAgICAgICAgICAgIDogZG9jLmJvZHkuc2Nyb2xsTGVmdDtcclxuICAgICAgICB2YXIgeSA9IHN1cHBvcnRQYWdlT2Zmc2V0XHJcbiAgICAgICAgICAgID8gd2luZG93LnBhZ2VZT2Zmc2V0XHJcbiAgICAgICAgICAgIDogaXNDU1MxQ29tcGF0XHJcbiAgICAgICAgICAgICAgICA/IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXHJcbiAgICAgICAgICAgICAgICA6IGRvYy5ib2R5LnNjcm9sbFRvcDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIGNvbXB1dGUgY29uc3RhbnRzIGluc3RlYWRcclxuICAgIC8vIG9mIGFjY2Vzc2luZyB3aW5kb3cuKiBhcyBzb29uIGFzIHRoZSBtb2R1bGUgbmVlZHMgaXRcclxuICAgIC8vIHNvIHRoYXQgd2UgZG8gbm90IGNvbXB1dGUgYW55dGhpbmcgaWYgbm90IG5lZWRlZFxyXG4gICAgZnVuY3Rpb24gZ2V0QWN0aW9ucygpIHtcclxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGV2ZW50cyB0byBiaW5kLiBJRTExIGltcGxlbWVudHMgcG9pbnRlckV2ZW50cyB3aXRob3V0XHJcbiAgICAgICAgLy8gYSBwcmVmaXgsIHdoaWNoIGJyZWFrcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIElFMTAgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWRcclxuICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBcInBvaW50ZXJkb3duXCIsXHJcbiAgICAgICAgICAgICAgICAgIG1vdmU6IFwicG9pbnRlcm1vdmVcIixcclxuICAgICAgICAgICAgICAgICAgZW5kOiBcInBvaW50ZXJ1cFwiXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogXCJNU1BvaW50ZXJEb3duXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBtb3ZlOiBcIk1TUG9pbnRlck1vdmVcIixcclxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogXCJNU1BvaW50ZXJVcFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFwibW91c2Vkb3duIHRvdWNoc3RhcnRcIixcclxuICAgICAgICAgICAgICAgICAgICAgIG1vdmU6IFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBcIm1vdXNldXAgdG91Y2hlbmRcIlxyXG4gICAgICAgICAgICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kXHJcbiAgICAvLyBJc3N1ZSAjNzg1XHJcbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0c1Bhc3NpdmUoKSB7XHJcbiAgICAgICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBvcHRzKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSgpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93LkNTUyAmJiBDU1Muc3VwcG9ydHMgJiYgQ1NTLnN1cHBvcnRzKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBWYWx1ZSBjYWxjdWxhdGlvblxyXG5cclxuICAgIC8vIERldGVybWluZSB0aGUgc2l6ZSBvZiBhIHN1Yi1yYW5nZSBpbiByZWxhdGlvbiB0byBhIGZ1bGwgcmFuZ2UuXHJcbiAgICBmdW5jdGlvbiBzdWJSYW5nZVJhdGlvKHBhLCBwYikge1xyXG4gICAgICAgIHJldHVybiAxMDAgLyAocGIgLSBwYSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gKHBlcmNlbnRhZ2UpIEhvdyBtYW55IHBlcmNlbnQgaXMgdGhpcyB2YWx1ZSBvZiB0aGlzIHJhbmdlP1xyXG4gICAgZnVuY3Rpb24gZnJvbVBlcmNlbnRhZ2UocmFuZ2UsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAqIDEwMCkgLyAocmFuZ2VbMV0gLSByYW5nZVswXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gKHBlcmNlbnRhZ2UpIFdoZXJlIGlzIHRoaXMgdmFsdWUgb24gdGhpcyByYW5nZT9cclxuICAgIGZ1bmN0aW9uIHRvUGVyY2VudGFnZShyYW5nZSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gZnJvbVBlcmNlbnRhZ2UocmFuZ2UsIHJhbmdlWzBdIDwgMCA/IHZhbHVlICsgTWF0aC5hYnMocmFuZ2VbMF0pIDogdmFsdWUgLSByYW5nZVswXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gKHZhbHVlKSBIb3cgbXVjaCBpcyB0aGlzIHBlcmNlbnRhZ2Ugb24gdGhpcyByYW5nZT9cclxuICAgIGZ1bmN0aW9uIGlzUGVyY2VudGFnZShyYW5nZSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlICogKHJhbmdlWzFdIC0gcmFuZ2VbMF0pKSAvIDEwMCArIHJhbmdlWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJhbmdlIGNvbnZlcnNpb25cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRKKHZhbHVlLCBhcnIpIHtcclxuICAgICAgICB2YXIgaiA9IDE7XHJcblxyXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+PSBhcnJbal0pIHtcclxuICAgICAgICAgICAgaiArPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGo7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gKHBlcmNlbnRhZ2UpIElucHV0IGEgdmFsdWUsIGZpbmQgd2hlcmUsIG9uIGEgc2NhbGUgb2YgMC0xMDAsIGl0IGFwcGxpZXMuXHJcbiAgICBmdW5jdGlvbiB0b1N0ZXBwaW5nKHhWYWwsIHhQY3QsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID49IHhWYWwuc2xpY2UoLTEpWzBdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxMDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHhWYWwpO1xyXG4gICAgICAgIHZhciB2YSA9IHhWYWxbaiAtIDFdO1xyXG4gICAgICAgIHZhciB2YiA9IHhWYWxbal07XHJcbiAgICAgICAgdmFyIHBhID0geFBjdFtqIC0gMV07XHJcbiAgICAgICAgdmFyIHBiID0geFBjdFtqXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBhICsgdG9QZXJjZW50YWdlKFt2YSwgdmJdLCB2YWx1ZSkgLyBzdWJSYW5nZVJhdGlvKHBhLCBwYik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gKHZhbHVlKSBJbnB1dCBhIHBlcmNlbnRhZ2UsIGZpbmQgd2hlcmUgaXQgaXMgb24gdGhlIHNwZWNpZmllZCByYW5nZS5cclxuICAgIGZ1bmN0aW9uIGZyb21TdGVwcGluZyh4VmFsLCB4UGN0LCB2YWx1ZSkge1xyXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHJhbmdlIGdyb3VwIHRoYXQgZml0cyAxMDBcclxuICAgICAgICBpZiAodmFsdWUgPj0gMTAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB4VmFsLnNsaWNlKC0xKVswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgeFBjdCk7XHJcbiAgICAgICAgdmFyIHZhID0geFZhbFtqIC0gMV07XHJcbiAgICAgICAgdmFyIHZiID0geFZhbFtqXTtcclxuICAgICAgICB2YXIgcGEgPSB4UGN0W2ogLSAxXTtcclxuICAgICAgICB2YXIgcGIgPSB4UGN0W2pdO1xyXG5cclxuICAgICAgICByZXR1cm4gaXNQZXJjZW50YWdlKFt2YSwgdmJdLCAodmFsdWUgLSBwYSkgKiBzdWJSYW5nZVJhdGlvKHBhLCBwYikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIChwZXJjZW50YWdlKSBHZXQgdGhlIHN0ZXAgdGhhdCBhcHBsaWVzIGF0IGEgY2VydGFpbiB2YWx1ZS5cclxuICAgIGZ1bmN0aW9uIGdldFN0ZXAoeFBjdCwgeFN0ZXBzLCBzbmFwLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMTAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgeFBjdCk7XHJcbiAgICAgICAgdmFyIGEgPSB4UGN0W2ogLSAxXTtcclxuICAgICAgICB2YXIgYiA9IHhQY3Rbal07XHJcblxyXG4gICAgICAgIC8vIElmICdzbmFwJyBpcyBzZXQsIHN0ZXBzIGFyZSB1c2VkIGFzIGZpeGVkIHBvaW50cyBvbiB0aGUgc2xpZGVyLlxyXG4gICAgICAgIGlmIChzbmFwKSB7XHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgcG9zaXRpb24sIGEgb3IgYi5cclxuICAgICAgICAgICAgaWYgKHZhbHVlIC0gYSA+IChiIC0gYSkgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXhTdGVwc1tqIC0gMV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHhQY3RbaiAtIDFdICsgY2xvc2VzdCh2YWx1ZSAtIHhQY3RbaiAtIDFdLCB4U3RlcHNbaiAtIDFdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnRyeSBwYXJzaW5nXHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRW50cnlQb2ludChpbmRleCwgdmFsdWUsIHRoYXQpIHtcclxuICAgICAgICB2YXIgcGVyY2VudGFnZTtcclxuXHJcbiAgICAgICAgLy8gV3JhcCBudW1lcmljYWwgaW5wdXQgaW4gYW4gYXJyYXkuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWplY3QgYW55IGludmFsaWQgaW5wdXQsIGJ5IHRlc3Rpbmcgd2hldGhlciB2YWx1ZSBpcyBhbiBhcnJheS5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyBjb250YWlucyBpbnZhbGlkIHZhbHVlLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvdmVydCBtaW4vbWF4IHN5bnRheCB0byAwIGFuZCAxMDAuXHJcbiAgICAgICAgaWYgKGluZGV4ID09PSBcIm1pblwiKSB7XHJcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSAwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgcGVyY2VudGFnZSA9IDEwMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwZXJjZW50YWdlID0gcGFyc2VGbG9hdChpbmRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3IgY29ycmVjdCBpbnB1dC5cclxuICAgICAgICBpZiAoIWlzTnVtZXJpYyhwZXJjZW50YWdlKSB8fCAhaXNOdW1lcmljKHZhbHVlWzBdKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdyYW5nZScgdmFsdWUgaXNuJ3QgbnVtZXJpYy5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdG9yZSB2YWx1ZXMuXHJcbiAgICAgICAgdGhhdC54UGN0LnB1c2gocGVyY2VudGFnZSk7XHJcbiAgICAgICAgdGhhdC54VmFsLnB1c2godmFsdWVbMF0pO1xyXG5cclxuICAgICAgICAvLyBOYU4gd2lsbCBldmFsdWF0ZSB0byBmYWxzZSB0b28sIGJ1dCB0byBrZWVwXHJcbiAgICAgICAgLy8gbG9nZ2luZyBjbGVhciwgc2V0IHN0ZXAgZXhwbGljaXRseS4gTWFrZSBzdXJlXHJcbiAgICAgICAgLy8gbm90IHRvIG92ZXJyaWRlIHRoZSAnc3RlcCcgc2V0dGluZyB3aXRoIGZhbHNlLlxyXG4gICAgICAgIGlmICghcGVyY2VudGFnZSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC54U3RlcHNbMF0gPSB2YWx1ZVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoYXQueFN0ZXBzLnB1c2goaXNOYU4odmFsdWVbMV0pID8gZmFsc2UgOiB2YWx1ZVsxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGF0LnhIaWdoZXN0Q29tcGxldGVTdGVwLnB1c2goMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RlcFBvaW50KGksIG4sIHRoYXQpIHtcclxuICAgICAgICAvLyBJZ25vcmUgJ2ZhbHNlJyBzdGVwcGluZy5cclxuICAgICAgICBpZiAoIW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGYWN0b3IgdG8gcmFuZ2UgcmF0aW9cclxuICAgICAgICB0aGF0LnhTdGVwc1tpXSA9XHJcbiAgICAgICAgICAgIGZyb21QZXJjZW50YWdlKFt0aGF0LnhWYWxbaV0sIHRoYXQueFZhbFtpICsgMV1dLCBuKSAvIHN1YlJhbmdlUmF0aW8odGhhdC54UGN0W2ldLCB0aGF0LnhQY3RbaSArIDFdKTtcclxuXHJcbiAgICAgICAgdmFyIHRvdGFsU3RlcHMgPSAodGhhdC54VmFsW2kgKyAxXSAtIHRoYXQueFZhbFtpXSkgLyB0aGF0LnhOdW1TdGVwc1tpXTtcclxuICAgICAgICB2YXIgaGlnaGVzdFN0ZXAgPSBNYXRoLmNlaWwoTnVtYmVyKHRvdGFsU3RlcHMudG9GaXhlZCgzKSkgLSAxKTtcclxuICAgICAgICB2YXIgc3RlcCA9IHRoYXQueFZhbFtpXSArIHRoYXQueE51bVN0ZXBzW2ldICogaGlnaGVzdFN0ZXA7XHJcblxyXG4gICAgICAgIHRoYXQueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaV0gPSBzdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEludGVyZmFjZVxyXG5cclxuICAgIGZ1bmN0aW9uIFNwZWN0cnVtKGVudHJ5LCBzbmFwLCBzaW5nbGVTdGVwKSB7XHJcbiAgICAgICAgdGhpcy54UGN0ID0gW107XHJcbiAgICAgICAgdGhpcy54VmFsID0gW107XHJcbiAgICAgICAgdGhpcy54U3RlcHMgPSBbc2luZ2xlU3RlcCB8fCBmYWxzZV07XHJcbiAgICAgICAgdGhpcy54TnVtU3RlcHMgPSBbZmFsc2VdO1xyXG4gICAgICAgIHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXAgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5zbmFwID0gc25hcDtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4O1xyXG4gICAgICAgIHZhciBvcmRlcmVkID0gW107IC8vIFswLCAnbWluJ10sIFsxLCAnNTAlJ10sIFsyLCAnbWF4J11cclxuXHJcbiAgICAgICAgLy8gTWFwIHRoZSBvYmplY3Qga2V5cyB0byBhbiBhcnJheS5cclxuICAgICAgICBmb3IgKGluZGV4IGluIGVudHJ5KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeS5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgIG9yZGVyZWQucHVzaChbZW50cnlbaW5kZXhdLCBpbmRleF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTb3J0IGFsbCBlbnRyaWVzIGJ5IHZhbHVlIChudW1lcmljIHNvcnQpLlxyXG4gICAgICAgIGlmIChvcmRlcmVkLmxlbmd0aCAmJiB0eXBlb2Ygb3JkZXJlZFswXVswXSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBvcmRlcmVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFbMF1bMF0gLSBiWzBdWzBdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvcmRlcmVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgYWxsIGVudHJpZXMgdG8gc3VicmFuZ2VzLlxyXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IG9yZGVyZWQubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZUVudHJ5UG9pbnQob3JkZXJlZFtpbmRleF1bMV0sIG9yZGVyZWRbaW5kZXhdWzBdLCB0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN0b3JlIHRoZSBhY3R1YWwgc3RlcCB2YWx1ZXMuXHJcbiAgICAgICAgLy8geFN0ZXBzIGlzIHNvcnRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB4UGN0IGFuZCB4VmFsLlxyXG4gICAgICAgIHRoaXMueE51bVN0ZXBzID0gdGhpcy54U3RlcHMuc2xpY2UoMCk7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgYWxsIG51bWVyaWMgc3RlcHMgdG8gdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIHN1YnJhbmdlIHRoZXkgcmVwcmVzZW50LlxyXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMueE51bVN0ZXBzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBoYW5kbGVTdGVwUG9pbnQoaW5kZXgsIHRoaXMueE51bVN0ZXBzW2luZGV4XSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXRNYXJnaW4gPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzdGVwID0gdGhpcy54TnVtU3RlcHNbMF07XHJcblxyXG4gICAgICAgIGlmIChzdGVwICYmICh2YWx1ZSAvIHN0ZXApICUgMSAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdsaW1pdCcsICdtYXJnaW4nIGFuZCAncGFkZGluZycgbXVzdCBiZSBkaXZpc2libGUgYnkgc3RlcC5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy54UGN0Lmxlbmd0aCA9PT0gMiA/IGZyb21QZXJjZW50YWdlKHRoaXMueFZhbCwgdmFsdWUpIDogZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS50b1N0ZXBwaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YWx1ZSA9IHRvU3RlcHBpbmcodGhpcy54VmFsLCB0aGlzLnhQY3QsIHZhbHVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZnJvbVN0ZXBwaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gZnJvbVN0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXRTdGVwID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YWx1ZSA9IGdldFN0ZXAodGhpcy54UGN0LCB0aGlzLnhTdGVwcywgdGhpcy5zbmFwLCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmdldE5lYXJieVN0ZXBzID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHRoaXMueFBjdCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0ZXBCZWZvcmU6IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHRoaXMueFZhbFtqIC0gMl0sXHJcbiAgICAgICAgICAgICAgICBzdGVwOiB0aGlzLnhOdW1TdGVwc1tqIC0gMl0sXHJcbiAgICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqIC0gMl1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGhpc1N0ZXA6IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHRoaXMueFZhbFtqIC0gMV0sXHJcbiAgICAgICAgICAgICAgICBzdGVwOiB0aGlzLnhOdW1TdGVwc1tqIC0gMV0sXHJcbiAgICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqIC0gMV1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3RlcEFmdGVyOiB7XHJcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbal0sXHJcbiAgICAgICAgICAgICAgICBzdGVwOiB0aGlzLnhOdW1TdGVwc1tqXSxcclxuICAgICAgICAgICAgICAgIGhpZ2hlc3RTdGVwOiB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwW2pdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuY291bnRTdGVwRGVjaW1hbHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc3RlcERlY2ltYWxzID0gdGhpcy54TnVtU3RlcHMubWFwKGNvdW50RGVjaW1hbHMpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBzdGVwRGVjaW1hbHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdXRzaWRlIHRlc3RpbmdcclxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGVwKHRoaXMudG9TdGVwcGluZyh2YWx1ZSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKlx0RXZlcnkgaW5wdXQgb3B0aW9uIGlzIHRlc3RlZCBhbmQgcGFyc2VkLiBUaGlzJ2xsIHByZXZlbnRcclxuICAgICAgICBlbmRsZXNzIHZhbGlkYXRpb24gaW4gaW50ZXJuYWwgbWV0aG9kcy4gVGhlc2UgdGVzdHMgYXJlXHJcbiAgICAgICAgc3RydWN0dXJlZCB3aXRoIGFuIGl0ZW0gZm9yIGV2ZXJ5IG9wdGlvbiBhdmFpbGFibGUuIEFuXHJcbiAgICAgICAgb3B0aW9uIGNhbiBiZSBtYXJrZWQgYXMgcmVxdWlyZWQgYnkgc2V0dGluZyB0aGUgJ3InIGZsYWcuXHJcbiAgICAgICAgVGhlIHRlc3RpbmcgZnVuY3Rpb24gaXMgcHJvdmlkZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XHJcbiAgICAgICAgICAgIC0gVGhlIHByb3ZpZGVkIHZhbHVlIGZvciB0aGUgb3B0aW9uO1xyXG4gICAgICAgICAgICAtIEEgcmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9iamVjdDtcclxuICAgICAgICAgICAgLSBUaGUgbmFtZSBmb3IgdGhlIG9wdGlvbjtcclxuXHJcbiAgICAgICAgVGhlIHRlc3RpbmcgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSB3aGVuIGFuIGVycm9yIGlzIGRldGVjdGVkLFxyXG4gICAgICAgIG9yIHRydWUgd2hlbiBldmVyeXRoaW5nIGlzIE9LLiBJdCBjYW4gYWxzbyBtb2RpZnkgdGhlIG9wdGlvblxyXG4gICAgICAgIG9iamVjdCwgdG8gbWFrZSBzdXJlIGFsbCB2YWx1ZXMgY2FuIGJlIGNvcnJlY3RseSBsb29wZWQgZWxzZXdoZXJlLiAqL1xyXG5cclxuICAgIHZhciBkZWZhdWx0Rm9ybWF0dGVyID0ge1xyXG4gICAgICAgIHRvOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS50b0ZpeGVkKDIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnJvbTogTnVtYmVyXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGVudHJ5KSB7XHJcbiAgICAgICAgLy8gQW55IG9iamVjdCB3aXRoIGEgdG8gYW5kIGZyb20gbWV0aG9kIGlzIHN1cHBvcnRlZC5cclxuICAgICAgICBpZiAoaXNWYWxpZEZvcm1hdHRlcihlbnRyeSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdmb3JtYXQnIHJlcXVpcmVzICd0bycgYW5kICdmcm9tJyBtZXRob2RzLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0U3RlcChwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3N0ZXAnIGlzIG5vdCBudW1lcmljLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBzdGVwIG9wdGlvbiBjYW4gc3RpbGwgYmUgdXNlZCB0byBzZXQgc3RlcHBpbmdcclxuICAgICAgICAvLyBmb3IgbGluZWFyIHNsaWRlcnMuIE92ZXJ3cml0dGVuIGlmIHNldCBpbiAncmFuZ2UnLlxyXG4gICAgICAgIHBhcnNlZC5zaW5nbGVTdGVwID0gZW50cnk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdFJhbmdlKHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICAvLyBGaWx0ZXIgaW5jb3JyZWN0IGlucHV0LlxyXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncmFuZ2UnIGlzIG5vdCBhbiBvYmplY3QuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2F0Y2ggbWlzc2luZyBzdGFydCBvciBlbmQuXHJcbiAgICAgICAgaWYgKGVudHJ5Lm1pbiA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5Lm1heCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogTWlzc2luZyAnbWluJyBvciAnbWF4JyBpbiAncmFuZ2UnLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhdGNoIGVxdWFsIHN0YXJ0IG9yIGVuZC5cclxuICAgICAgICBpZiAoZW50cnkubWluID09PSBlbnRyeS5tYXgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncmFuZ2UnICdtaW4nIGFuZCAnbWF4JyBjYW5ub3QgYmUgZXF1YWwuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFyc2VkLnNwZWN0cnVtID0gbmV3IFNwZWN0cnVtKGVudHJ5LCBwYXJzZWQuc25hcCwgcGFyc2VkLnNpbmdsZVN0ZXApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RTdGFydChwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgZW50cnkgPSBhc0FycmF5KGVudHJ5KTtcclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgaW5wdXQuIFZhbHVlcyBhcmVuJ3QgdGVzdGVkLCBhcyB0aGUgcHVibGljIC52YWwgbWV0aG9kXHJcbiAgICAgICAgLy8gd2lsbCBhbHdheXMgcHJvdmlkZSBhIHZhbGlkIGxvY2F0aW9uLlxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyeSkgfHwgIWVudHJ5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdzdGFydCcgb3B0aW9uIGlzIGluY29ycmVjdC5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdG9yZSB0aGUgbnVtYmVyIG9mIGhhbmRsZXMuXHJcbiAgICAgICAgcGFyc2VkLmhhbmRsZXMgPSBlbnRyeS5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFdoZW4gdGhlIHNsaWRlciBpcyBpbml0aWFsaXplZCwgdGhlIC52YWwgbWV0aG9kIHdpbGxcclxuICAgICAgICAvLyBiZSBjYWxsZWQgd2l0aCB0aGUgc3RhcnQgb3B0aW9ucy5cclxuICAgICAgICBwYXJzZWQuc3RhcnQgPSBlbnRyeTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0U25hcChwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgLy8gRW5mb3JjZSAxMDAlIHN0ZXBwaW5nIHdpdGhpbiBzdWJyYW5nZXMuXHJcbiAgICAgICAgcGFyc2VkLnNuYXAgPSBlbnRyeTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnc25hcCcgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdEFuaW1hdGUocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIC8vIEVuZm9yY2UgMTAwJSBzdGVwcGluZyB3aXRoaW4gc3VicmFuZ2VzLlxyXG4gICAgICAgIHBhcnNlZC5hbmltYXRlID0gZW50cnk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2FuaW1hdGUnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RBbmltYXRpb25EdXJhdGlvbihwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgcGFyc2VkLmFuaW1hdGlvbkR1cmF0aW9uID0gZW50cnk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnYW5pbWF0aW9uRHVyYXRpb24nIG9wdGlvbiBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdENvbm5lY3QocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIHZhciBjb25uZWN0ID0gW2ZhbHNlXTtcclxuICAgICAgICB2YXIgaTtcclxuXHJcbiAgICAgICAgLy8gTWFwIGxlZ2FjeSBvcHRpb25zXHJcbiAgICAgICAgaWYgKGVudHJ5ID09PSBcImxvd2VyXCIpIHtcclxuICAgICAgICAgICAgZW50cnkgPSBbdHJ1ZSwgZmFsc2VdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZW50cnkgPT09IFwidXBwZXJcIikge1xyXG4gICAgICAgICAgICBlbnRyeSA9IFtmYWxzZSwgdHJ1ZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgYm9vbGVhbiBvcHRpb25zXHJcbiAgICAgICAgaWYgKGVudHJ5ID09PSB0cnVlIHx8IGVudHJ5ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcGFyc2VkLmhhbmRsZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdC5wdXNoKGVudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29ubmVjdC5wdXNoKGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlamVjdCBpbnZhbGlkIGlucHV0XHJcbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZW50cnkpIHx8ICFlbnRyeS5sZW5ndGggfHwgZW50cnkubGVuZ3RoICE9PSBwYXJzZWQuaGFuZGxlcyArIDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnY29ubmVjdCcgb3B0aW9uIGRvZXNuJ3QgbWF0Y2ggaGFuZGxlIGNvdW50LlwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25uZWN0ID0gZW50cnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJzZWQuY29ubmVjdCA9IGNvbm5lY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdE9yaWVudGF0aW9uKHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICAvLyBTZXQgb3JpZW50YXRpb24gdG8gYW4gYSBudW1lcmljYWwgdmFsdWUgZm9yIGVhc3lcclxuICAgICAgICAvLyBhcnJheSBzZWxlY3Rpb24uXHJcbiAgICAgICAgc3dpdGNoIChlbnRyeSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VkLm9ydCA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQub3J0ID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnb3JpZW50YXRpb24nIG9wdGlvbiBpcyBpbnZhbGlkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdE1hcmdpbihwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ21hcmdpbicgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJc3N1ZSAjNTgyXHJcbiAgICAgICAgaWYgKGVudHJ5ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcnNlZC5tYXJnaW4gPSBwYXJzZWQuc3BlY3RydW0uZ2V0TWFyZ2luKGVudHJ5KTtcclxuXHJcbiAgICAgICAgaWYgKCFwYXJzZWQubWFyZ2luKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ21hcmdpbicgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIG9uIGxpbmVhciBzbGlkZXJzLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdExpbWl0KHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnbGltaXQnIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFyc2VkLmxpbWl0ID0gcGFyc2VkLnNwZWN0cnVtLmdldE1hcmdpbihlbnRyeSk7XHJcblxyXG4gICAgICAgIGlmICghcGFyc2VkLmxpbWl0IHx8IHBhcnNlZC5oYW5kbGVzIDwgMikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcIm5vVWlTbGlkZXIgKFwiICtcclxuICAgICAgICAgICAgICAgICAgICBWRVJTSU9OICtcclxuICAgICAgICAgICAgICAgICAgICBcIik6ICdsaW1pdCcgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIG9uIGxpbmVhciBzbGlkZXJzIHdpdGggMiBvciBtb3JlIGhhbmRsZXMuXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdFBhZGRpbmcocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSAmJiAhQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBiZSBudW1lcmljIG9yIGFycmF5IG9mIGV4YWN0bHkgMiBudW1iZXJzLlwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkgJiYgIShlbnRyeS5sZW5ndGggPT09IDIgfHwgaXNOdW1lcmljKGVudHJ5WzBdKSB8fCBpc051bWVyaWMoZW50cnlbMV0pKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMgb3IgYXJyYXkgb2YgZXhhY3RseSAyIG51bWJlcnMuXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50cnkpKSB7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gW2VudHJ5LCBlbnRyeV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAnZ2V0TWFyZ2luJyByZXR1cm5zIGZhbHNlIGZvciBpbnZhbGlkIHZhbHVlcy5cclxuICAgICAgICBwYXJzZWQucGFkZGluZyA9IFtwYXJzZWQuc3BlY3RydW0uZ2V0TWFyZ2luKGVudHJ5WzBdKSwgcGFyc2VkLnNwZWN0cnVtLmdldE1hcmdpbihlbnRyeVsxXSldO1xyXG5cclxuICAgICAgICBpZiAocGFyc2VkLnBhZGRpbmdbMF0gPT09IGZhbHNlIHx8IHBhcnNlZC5wYWRkaW5nWzFdID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgb24gbGluZWFyIHNsaWRlcnMuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZC5wYWRkaW5nWzBdIDwgMCB8fCBwYXJzZWQucGFkZGluZ1sxXSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIocykuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZC5wYWRkaW5nWzBdICsgcGFyc2VkLnBhZGRpbmdbMV0gPj0gMTAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IG5vdCBleGNlZWQgMTAwJSBvZiB0aGUgcmFuZ2UuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0RGlyZWN0aW9uKHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICAvLyBTZXQgZGlyZWN0aW9uIGFzIGEgbnVtZXJpY2FsIHZhbHVlIGZvciBlYXN5IHBhcnNpbmcuXHJcbiAgICAgICAgLy8gSW52ZXJ0IGNvbm5lY3Rpb24gZm9yIFJUTCBzbGlkZXJzLCBzbyB0aGF0IHRoZSBwcm9wZXJcclxuICAgICAgICAvLyBoYW5kbGVzIGdldCB0aGUgY29ubmVjdC9iYWNrZ3JvdW5kIGNsYXNzZXMuXHJcbiAgICAgICAgc3dpdGNoIChlbnRyeSkge1xyXG4gICAgICAgICAgICBjYXNlIFwibHRyXCI6XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQuZGlyID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicnRsXCI6XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQuZGlyID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnZGlyZWN0aW9uJyBvcHRpb24gd2FzIG5vdCByZWNvZ25pemVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdEJlaGF2aW91cihwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBpbnB1dCBpcyBhIHN0cmluZy5cclxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2JlaGF2aW91cicgbXVzdCBiZSBhIHN0cmluZyBjb250YWluaW5nIG9wdGlvbnMuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHN0cmluZyBjb250YWlucyBhbnkga2V5d29yZHMuXHJcbiAgICAgICAgLy8gTm9uZSBhcmUgcmVxdWlyZWQuXHJcbiAgICAgICAgdmFyIHRhcCA9IGVudHJ5LmluZGV4T2YoXCJ0YXBcIikgPj0gMDtcclxuICAgICAgICB2YXIgZHJhZyA9IGVudHJ5LmluZGV4T2YoXCJkcmFnXCIpID49IDA7XHJcbiAgICAgICAgdmFyIGZpeGVkID0gZW50cnkuaW5kZXhPZihcImZpeGVkXCIpID49IDA7XHJcbiAgICAgICAgdmFyIHNuYXAgPSBlbnRyeS5pbmRleE9mKFwic25hcFwiKSA+PSAwO1xyXG4gICAgICAgIHZhciBob3ZlciA9IGVudHJ5LmluZGV4T2YoXCJob3ZlclwiKSA+PSAwO1xyXG4gICAgICAgIHZhciB1bmNvbnN0cmFpbmVkID0gZW50cnkuaW5kZXhPZihcInVuY29uc3RyYWluZWRcIikgPj0gMDtcclxuXHJcbiAgICAgICAgaWYgKGZpeGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZWQuaGFuZGxlcyAhPT0gMikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnZml4ZWQnIGJlaGF2aW91ciBtdXN0IGJlIHVzZWQgd2l0aCAyIGhhbmRsZXNcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVzZSBtYXJnaW4gdG8gZW5mb3JjZSBmaXhlZCBzdGF0ZVxyXG4gICAgICAgICAgICB0ZXN0TWFyZ2luKHBhcnNlZCwgcGFyc2VkLnN0YXJ0WzFdIC0gcGFyc2VkLnN0YXJ0WzBdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh1bmNvbnN0cmFpbmVkICYmIChwYXJzZWQubWFyZ2luIHx8IHBhcnNlZC5saW1pdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICd1bmNvbnN0cmFpbmVkJyBiZWhhdmlvdXIgY2Fubm90IGJlIHVzZWQgd2l0aCBtYXJnaW4gb3IgbGltaXRcIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFyc2VkLmV2ZW50cyA9IHtcclxuICAgICAgICAgICAgdGFwOiB0YXAgfHwgc25hcCxcclxuICAgICAgICAgICAgZHJhZzogZHJhZyxcclxuICAgICAgICAgICAgZml4ZWQ6IGZpeGVkLFxyXG4gICAgICAgICAgICBzbmFwOiBzbmFwLFxyXG4gICAgICAgICAgICBob3ZlcjogaG92ZXIsXHJcbiAgICAgICAgICAgIHVuY29uc3RyYWluZWQ6IHVuY29uc3RyYWluZWRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RUb29sdGlwcyhwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKGVudHJ5ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZW50cnkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcGFyc2VkLnRvb2x0aXBzID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnNlZC5oYW5kbGVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlZC50b29sdGlwcy5wdXNoKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyc2VkLnRvb2x0aXBzID0gYXNBcnJheShlbnRyeSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocGFyc2VkLnRvb2x0aXBzLmxlbmd0aCAhPT0gcGFyc2VkLmhhbmRsZXMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogbXVzdCBwYXNzIGEgZm9ybWF0dGVyIGZvciBhbGwgaGFuZGxlcy5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhcnNlZC50b29sdGlwcy5mb3JFYWNoKGZ1bmN0aW9uKGZvcm1hdHRlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBmb3JtYXR0ZXIgIT09IFwiYm9vbGVhblwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBmb3JtYXR0ZXIgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZvcm1hdHRlci50byAhPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAndG9vbHRpcHMnIG11c3QgYmUgcGFzc2VkIGEgZm9ybWF0dGVyIG9yICdmYWxzZScuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdEFyaWFGb3JtYXQocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIHBhcnNlZC5hcmlhRm9ybWF0ID0gZW50cnk7XHJcbiAgICAgICAgdmFsaWRhdGVGb3JtYXQoZW50cnkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RGb3JtYXQocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIHBhcnNlZC5mb3JtYXQgPSBlbnRyeTtcclxuICAgICAgICB2YWxpZGF0ZUZvcm1hdChlbnRyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkU3VwcG9ydChwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgcGFyc2VkLmtleWJvYXJkU3VwcG9ydCA9IGVudHJ5O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdrZXlib2FyZFN1cHBvcnQnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3REb2N1bWVudEVsZW1lbnQocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYWR2YW5jZWQgb3B0aW9uLiBQYXNzZWQgdmFsdWVzIGFyZSB1c2VkIHdpdGhvdXQgdmFsaWRhdGlvbi5cclxuICAgICAgICBwYXJzZWQuZG9jdW1lbnRFbGVtZW50ID0gZW50cnk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdENzc1ByZWZpeChwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJzdHJpbmdcIiAmJiBlbnRyeSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnY3NzUHJlZml4JyBtdXN0IGJlIGEgc3RyaW5nIG9yIGBmYWxzZWAuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFyc2VkLmNzc1ByZWZpeCA9IGVudHJ5O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RDc3NDbGFzc2VzKHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2Nzc0NsYXNzZXMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgcGFyc2VkLmNzc1ByZWZpeCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3NlcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVudHJ5Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3Nlc1trZXldID0gcGFyc2VkLmNzc1ByZWZpeCArIGVudHJ5W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3NlcyA9IGVudHJ5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUZXN0IGFsbCBkZXZlbG9wZXIgc2V0dGluZ3MgYW5kIHBhcnNlIHRvIGFzc3VtcHRpb24tc2FmZSB2YWx1ZXMuXHJcbiAgICBmdW5jdGlvbiB0ZXN0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gVG8gcHJvdmUgYSBmaXggZm9yICM1MzcsIGZyZWV6ZSBvcHRpb25zIGhlcmUuXHJcbiAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBpcyBtb2RpZmllZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcbiAgICAgICAgLy8gT2JqZWN0LmZyZWV6ZShvcHRpb25zKTtcclxuXHJcbiAgICAgICAgdmFyIHBhcnNlZCA9IHtcclxuICAgICAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgICAgICBsaW1pdDogMCxcclxuICAgICAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICAgICAgYW5pbWF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IDMwMCxcclxuICAgICAgICAgICAgYXJpYUZvcm1hdDogZGVmYXVsdEZvcm1hdHRlcixcclxuICAgICAgICAgICAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0dGVyXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gVGVzdHMgYXJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBwcmVzZW50ZWQgaGVyZS5cclxuICAgICAgICB2YXIgdGVzdHMgPSB7XHJcbiAgICAgICAgICAgIHN0ZXA6IHsgcjogZmFsc2UsIHQ6IHRlc3RTdGVwIH0sXHJcbiAgICAgICAgICAgIHN0YXJ0OiB7IHI6IHRydWUsIHQ6IHRlc3RTdGFydCB9LFxyXG4gICAgICAgICAgICBjb25uZWN0OiB7IHI6IHRydWUsIHQ6IHRlc3RDb25uZWN0IH0sXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogeyByOiB0cnVlLCB0OiB0ZXN0RGlyZWN0aW9uIH0sXHJcbiAgICAgICAgICAgIHNuYXA6IHsgcjogZmFsc2UsIHQ6IHRlc3RTbmFwIH0sXHJcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgcjogZmFsc2UsIHQ6IHRlc3RBbmltYXRlIH0sXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiB7IHI6IGZhbHNlLCB0OiB0ZXN0QW5pbWF0aW9uRHVyYXRpb24gfSxcclxuICAgICAgICAgICAgcmFuZ2U6IHsgcjogdHJ1ZSwgdDogdGVzdFJhbmdlIH0sXHJcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiB7IHI6IGZhbHNlLCB0OiB0ZXN0T3JpZW50YXRpb24gfSxcclxuICAgICAgICAgICAgbWFyZ2luOiB7IHI6IGZhbHNlLCB0OiB0ZXN0TWFyZ2luIH0sXHJcbiAgICAgICAgICAgIGxpbWl0OiB7IHI6IGZhbHNlLCB0OiB0ZXN0TGltaXQgfSxcclxuICAgICAgICAgICAgcGFkZGluZzogeyByOiBmYWxzZSwgdDogdGVzdFBhZGRpbmcgfSxcclxuICAgICAgICAgICAgYmVoYXZpb3VyOiB7IHI6IHRydWUsIHQ6IHRlc3RCZWhhdmlvdXIgfSxcclxuICAgICAgICAgICAgYXJpYUZvcm1hdDogeyByOiBmYWxzZSwgdDogdGVzdEFyaWFGb3JtYXQgfSxcclxuICAgICAgICAgICAgZm9ybWF0OiB7IHI6IGZhbHNlLCB0OiB0ZXN0Rm9ybWF0IH0sXHJcbiAgICAgICAgICAgIHRvb2x0aXBzOiB7IHI6IGZhbHNlLCB0OiB0ZXN0VG9vbHRpcHMgfSxcclxuICAgICAgICAgICAga2V5Ym9hcmRTdXBwb3J0OiB7IHI6IHRydWUsIHQ6IHRlc3RLZXlib2FyZFN1cHBvcnQgfSxcclxuICAgICAgICAgICAgZG9jdW1lbnRFbGVtZW50OiB7IHI6IGZhbHNlLCB0OiB0ZXN0RG9jdW1lbnRFbGVtZW50IH0sXHJcbiAgICAgICAgICAgIGNzc1ByZWZpeDogeyByOiB0cnVlLCB0OiB0ZXN0Q3NzUHJlZml4IH0sXHJcbiAgICAgICAgICAgIGNzc0NsYXNzZXM6IHsgcjogdHJ1ZSwgdDogdGVzdENzc0NsYXNzZXMgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcclxuICAgICAgICAgICAgY29ubmVjdDogZmFsc2UsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcclxuICAgICAgICAgICAgYmVoYXZpb3VyOiBcInRhcFwiLFxyXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgIGtleWJvYXJkU3VwcG9ydDogdHJ1ZSxcclxuICAgICAgICAgICAgY3NzUHJlZml4OiBcIm5vVWktXCIsXHJcbiAgICAgICAgICAgIGNzc0NsYXNzZXM6IHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogXCJ0YXJnZXRcIixcclxuICAgICAgICAgICAgICAgIGJhc2U6IFwiYmFzZVwiLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcIm9yaWdpblwiLFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlOiBcImhhbmRsZVwiLFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlTG93ZXI6IFwiaGFuZGxlLWxvd2VyXCIsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVVcHBlcjogXCJoYW5kbGUtdXBwZXJcIixcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWw6IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IFwidmVydGljYWxcIixcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiYmFja2dyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgY29ubmVjdDogXCJjb25uZWN0XCIsXHJcbiAgICAgICAgICAgICAgICBjb25uZWN0czogXCJjb25uZWN0c1wiLFxyXG4gICAgICAgICAgICAgICAgbHRyOiBcImx0clwiLFxyXG4gICAgICAgICAgICAgICAgcnRsOiBcInJ0bFwiLFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBcImRyYWdnYWJsZVwiLFxyXG4gICAgICAgICAgICAgICAgZHJhZzogXCJzdGF0ZS1kcmFnXCIsXHJcbiAgICAgICAgICAgICAgICB0YXA6IFwic3RhdGUtdGFwXCIsXHJcbiAgICAgICAgICAgICAgICBhY3RpdmU6IFwiYWN0aXZlXCIsXHJcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBcInRvb2x0aXBcIixcclxuICAgICAgICAgICAgICAgIHBpcHM6IFwicGlwc1wiLFxyXG4gICAgICAgICAgICAgICAgcGlwc0hvcml6b250YWw6IFwicGlwcy1ob3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgICAgICBwaXBzVmVydGljYWw6IFwicGlwcy12ZXJ0aWNhbFwiLFxyXG4gICAgICAgICAgICAgICAgbWFya2VyOiBcIm1hcmtlclwiLFxyXG4gICAgICAgICAgICAgICAgbWFya2VySG9yaXpvbnRhbDogXCJtYXJrZXItaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICAgICAgbWFya2VyVmVydGljYWw6IFwibWFya2VyLXZlcnRpY2FsXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJOb3JtYWw6IFwibWFya2VyLW5vcm1hbFwiLFxyXG4gICAgICAgICAgICAgICAgbWFya2VyTGFyZ2U6IFwibWFya2VyLWxhcmdlXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJTdWI6IFwibWFya2VyLXN1YlwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwidmFsdWVcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlSG9yaXpvbnRhbDogXCJ2YWx1ZS1ob3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZVZlcnRpY2FsOiBcInZhbHVlLXZlcnRpY2FsXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZU5vcm1hbDogXCJ2YWx1ZS1ub3JtYWxcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlTGFyZ2U6IFwidmFsdWUtbGFyZ2VcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlU3ViOiBcInZhbHVlLXN1YlwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBBcmlhRm9ybWF0IGRlZmF1bHRzIHRvIHJlZ3VsYXIgZm9ybWF0LCBpZiBhbnkuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ICYmICFvcHRpb25zLmFyaWFGb3JtYXQpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5hcmlhRm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSdW4gYWxsIG9wdGlvbnMgdGhyb3VnaCBhIHRlc3RpbmcgbWVjaGFuaXNtIHRvIGVuc3VyZSBjb3JyZWN0XHJcbiAgICAgICAgLy8gaW5wdXQuIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IG9wdGlvbnMgbWlnaHQgZ2V0IG1vZGlmaWVkIHRvXHJcbiAgICAgICAgLy8gYmUgaGFuZGxlZCBwcm9wZXJseS4gRS5nLiB3cmFwcGluZyBpbnRlZ2VycyBpbiBhcnJheXMuXHJcbiAgICAgICAgT2JqZWN0LmtleXModGVzdHMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW9uIGlzbid0IHNldCwgYnV0IGl0IGlzIHJlcXVpcmVkLCB0aHJvdyBhbiBlcnJvci5cclxuICAgICAgICAgICAgaWYgKCFpc1NldChvcHRpb25zW25hbWVdKSAmJiBkZWZhdWx0c1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdHNbbmFtZV0ucikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ1wiICsgbmFtZSArIFwiJyBpcyByZXF1aXJlZC5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRlc3RzW25hbWVdLnQocGFyc2VkLCAhaXNTZXQob3B0aW9uc1tuYW1lXSkgPyBkZWZhdWx0c1tuYW1lXSA6IG9wdGlvbnNbbmFtZV0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBGb3J3YXJkIHBpcHMgb3B0aW9uc1xyXG4gICAgICAgIHBhcnNlZC5waXBzID0gb3B0aW9ucy5waXBzO1xyXG5cclxuICAgICAgICAvLyBBbGwgcmVjZW50IGJyb3dzZXJzIGFjY2VwdCB1bnByZWZpeGVkIHRyYW5zZm9ybS5cclxuICAgICAgICAvLyBXZSBuZWVkIC1tcy0gZm9yIElFOSBhbmQgLXdlYmtpdC0gZm9yIG9sZGVyIEFuZHJvaWQ7XHJcbiAgICAgICAgLy8gQXNzdW1lIHVzZSBvZiAtd2Via2l0LSBpZiB1bnByZWZpeGVkIGFuZCAtbXMtIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI2ZlYXQ9dHJhbnNmb3JtczJkXHJcbiAgICAgICAgdmFyIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHZhciBtc1ByZWZpeCA9IGQuc3R5bGUubXNUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgbm9QcmVmaXggPSBkLnN0eWxlLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBwYXJzZWQudHJhbnNmb3JtUnVsZSA9IG5vUHJlZml4ID8gXCJ0cmFuc2Zvcm1cIiA6IG1zUHJlZml4ID8gXCJtc1RyYW5zZm9ybVwiIDogXCJ3ZWJraXRUcmFuc2Zvcm1cIjtcclxuXHJcbiAgICAgICAgLy8gUGlwcyBkb24ndCBtb3ZlLCBzbyB3ZSBjYW4gcGxhY2UgdGhlbSB1c2luZyBsZWZ0L3RvcC5cclxuICAgICAgICB2YXIgc3R5bGVzID0gW1tcImxlZnRcIiwgXCJ0b3BcIl0sIFtcInJpZ2h0XCIsIFwiYm90dG9tXCJdXTtcclxuXHJcbiAgICAgICAgcGFyc2VkLnN0eWxlID0gc3R5bGVzW3BhcnNlZC5kaXJdW3BhcnNlZC5vcnRdO1xyXG5cclxuICAgICAgICByZXR1cm4gcGFyc2VkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNjb3BlKHRhcmdldCwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBnZXRBY3Rpb25zKCk7XHJcbiAgICAgICAgdmFyIHN1cHBvcnRzVG91Y2hBY3Rpb25Ob25lID0gZ2V0U3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUoKTtcclxuICAgICAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gc3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUgJiYgZ2V0U3VwcG9ydHNQYXNzaXZlKCk7XHJcblxyXG4gICAgICAgIC8vIEFsbCB2YXJpYWJsZXMgbG9jYWwgdG8gJ3Njb3BlJyBhcmUgcHJlZml4ZWQgd2l0aCAnc2NvcGVfJ1xyXG4gICAgICAgIHZhciBzY29wZV9UYXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdmFyIHNjb3BlX0xvY2F0aW9ucyA9IFtdO1xyXG4gICAgICAgIHZhciBzY29wZV9CYXNlO1xyXG4gICAgICAgIHZhciBzY29wZV9IYW5kbGVzO1xyXG4gICAgICAgIHZhciBzY29wZV9IYW5kbGVOdW1iZXJzID0gW107XHJcbiAgICAgICAgdmFyIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIHNjb3BlX0Nvbm5lY3RzO1xyXG4gICAgICAgIHZhciBzY29wZV9TcGVjdHJ1bSA9IG9wdGlvbnMuc3BlY3RydW07XHJcbiAgICAgICAgdmFyIHNjb3BlX1ZhbHVlcyA9IFtdO1xyXG4gICAgICAgIHZhciBzY29wZV9FdmVudHMgPSB7fTtcclxuICAgICAgICB2YXIgc2NvcGVfU2VsZjtcclxuICAgICAgICB2YXIgc2NvcGVfUGlwcztcclxuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnQgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcclxuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnRFbGVtZW50ID0gb3B0aW9ucy5kb2N1bWVudEVsZW1lbnQgfHwgc2NvcGVfRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgIHZhciBzY29wZV9Cb2R5ID0gc2NvcGVfRG9jdW1lbnQuYm9keTtcclxuXHJcbiAgICAgICAgLy8gUGlwcyBjb25zdGFudHNcclxuICAgICAgICB2YXIgUElQU19OT05FID0gLTE7XHJcbiAgICAgICAgdmFyIFBJUFNfTk9fVkFMVUUgPSAwO1xyXG4gICAgICAgIHZhciBQSVBTX0xBUkdFX1ZBTFVFID0gMTtcclxuICAgICAgICB2YXIgUElQU19TTUFMTF9WQUxVRSA9IDI7XHJcblxyXG4gICAgICAgIC8vIEZvciBob3Jpem9udGFsIHNsaWRlcnMgaW4gc3RhbmRhcmQgbHRyIGRvY3VtZW50cyxcclxuICAgICAgICAvLyBtYWtlIC5ub1VpLW9yaWdpbiBvdmVyZmxvdyB0byB0aGUgbGVmdCBzbyB0aGUgZG9jdW1lbnQgZG9lc24ndCBzY3JvbGwuXHJcbiAgICAgICAgdmFyIHNjb3BlX0Rpck9mZnNldCA9IHNjb3BlX0RvY3VtZW50LmRpciA9PT0gXCJydGxcIiB8fCBvcHRpb25zLm9ydCA9PT0gMSA/IDAgOiAxMDA7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZXMgYSBub2RlLCBhZGRzIGl0IHRvIHRhcmdldCwgcmV0dXJucyB0aGUgbmV3IG5vZGUuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkTm9kZVRvKGFkZFRhcmdldCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXYgPSBzY29wZV9Eb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoZGl2LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhZGRUYXJnZXQuYXBwZW5kQ2hpbGQoZGl2KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkaXY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgYSBvcmlnaW4gdG8gdGhlIGJhc2VcclxuICAgICAgICBmdW5jdGlvbiBhZGRPcmlnaW4oYmFzZSwgaGFuZGxlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSBhZGROb2RlVG8oYmFzZSwgb3B0aW9ucy5jc3NDbGFzc2VzLm9yaWdpbik7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGROb2RlVG8ob3JpZ2luLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlKTtcclxuXHJcbiAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWhhbmRsZVwiLCBoYW5kbGVOdW1iZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMua2V5Ym9hcmRTdXBwb3J0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4XHJcbiAgICAgICAgICAgICAgICAvLyAwID0gZm9jdXNhYmxlIGFuZCByZWFjaGFibGVcclxuICAgICAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic2xpZGVyXCIpO1xyXG4gICAgICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwiYXJpYS1vcmllbnRhdGlvblwiLCBvcHRpb25zLm9ydCA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVOdW1iZXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmhhbmRsZUxvd2VyKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVOdW1iZXIgPT09IG9wdGlvbnMuaGFuZGxlcyAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmhhbmRsZVVwcGVyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluc2VydCBub2RlcyBmb3IgY29ubmVjdCBlbGVtZW50c1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkZENvbm5lY3QoYmFzZSwgYWRkKSB7XHJcbiAgICAgICAgICAgIGlmICghYWRkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhZGROb2RlVG8oYmFzZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmNvbm5lY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGhhbmRsZXMgdG8gdGhlIHNsaWRlciBiYXNlLlxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZEVsZW1lbnRzKGNvbm5lY3RPcHRpb25zLCBiYXNlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0QmFzZSA9IGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMuY29ubmVjdHMpO1xyXG5cclxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlcyA9IFtdO1xyXG4gICAgICAgICAgICBzY29wZV9Db25uZWN0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHMucHVzaChhZGRDb25uZWN0KGNvbm5lY3RCYXNlLCBjb25uZWN0T3B0aW9uc1swXSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gWzo6OjpPPT09PU89PT09Tz09PT1dXHJcbiAgICAgICAgICAgIC8vIGNvbm5lY3RPcHRpb25zID0gWzAsIDEsIDEsIDFdXHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMuaGFuZGxlczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBLZWVwIGEgbGlzdCBvZiBhbGwgYWRkZWQgaGFuZGxlcy5cclxuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMucHVzaChhZGRPcmlnaW4oYmFzZSwgaSkpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVyc1tpXSA9IGk7XHJcbiAgICAgICAgICAgICAgICBzY29wZV9Db25uZWN0cy5wdXNoKGFkZENvbm5lY3QoY29ubmVjdEJhc2UsIGNvbm5lY3RPcHRpb25zW2kgKyAxXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIGEgc2luZ2xlIHNsaWRlci5cclxuICAgICAgICBmdW5jdGlvbiBhZGRTbGlkZXIoYWRkVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGNsYXNzZXMgYW5kIGRhdGEgdG8gdGhlIHRhcmdldC5cclxuICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMubHRyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnJ0bCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9ydCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy52ZXJ0aWNhbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhZGROb2RlVG8oYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuYmFzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZGRUb29sdGlwKGhhbmRsZSwgaGFuZGxlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhZGROb2RlVG8oaGFuZGxlLmZpcnN0Q2hpbGQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50b29sdGlwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSB0b29sdGlwcyBvcHRpb24gaXMgYSBzaG9ydGhhbmQgZm9yIHVzaW5nIHRoZSAndXBkYXRlJyBldmVudC5cclxuICAgICAgICBmdW5jdGlvbiB0b29sdGlwcygpIHtcclxuICAgICAgICAgICAgLy8gVG9vbHRpcHMgYXJlIGFkZGVkIHdpdGggb3B0aW9ucy50b29sdGlwcyBpbiBvcmlnaW5hbCBvcmRlci5cclxuICAgICAgICAgICAgdmFyIHRpcHMgPSBzY29wZV9IYW5kbGVzLm1hcChhZGRUb29sdGlwKTtcclxuXHJcbiAgICAgICAgICAgIGJpbmRFdmVudChcInVwZGF0ZVwiLCBmdW5jdGlvbih2YWx1ZXMsIGhhbmRsZU51bWJlciwgdW5lbmNvZGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRpcHNbaGFuZGxlTnVtYmVyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSB2YWx1ZXNbaGFuZGxlTnVtYmVyXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSBvcHRpb25zLnRvb2x0aXBzW2hhbmRsZU51bWJlcl0udG8odW5lbmNvZGVkW2hhbmRsZU51bWJlcl0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRpcHNbaGFuZGxlTnVtYmVyXS5pbm5lckhUTUwgPSBmb3JtYXR0ZWRWYWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBhcmlhKCkge1xyXG4gICAgICAgICAgICBiaW5kRXZlbnQoXCJ1cGRhdGVcIiwgZnVuY3Rpb24odmFsdWVzLCBoYW5kbGVOdW1iZXIsIHVuZW5jb2RlZCwgdGFwLCBwb3NpdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBBcmlhIFZhbHVlcyBmb3IgYWxsIGhhbmRsZXMsIGFzIGEgY2hhbmdlIGluIG9uZSBjaGFuZ2VzIG1pbiBhbmQgbWF4IHZhbHVlcyBmb3IgdGhlIG5leHQuXHJcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2NvcGVfSGFuZGxlc1tpbmRleF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW4gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHNjb3BlX0xvY2F0aW9ucywgaW5kZXgsIDAsIHRydWUsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSBjaGVja0hhbmRsZVBvc2l0aW9uKHNjb3BlX0xvY2F0aW9ucywgaW5kZXgsIDEwMCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBwb3NpdGlvbnNbaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXR0ZWQgdmFsdWUgZm9yIGRpc3BsYXlcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IG9wdGlvbnMuYXJpYUZvcm1hdC50byh1bmVuY29kZWRbaW5kZXhdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFwIHRvIHNsaWRlciByYW5nZSB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobWluKS50b0ZpeGVkKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhtYXgpLnRvRml4ZWQoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93ID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKG5vdykudG9GaXhlZCgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVtaW5cIiwgbWluKTtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1heFwiLCBtYXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZS5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbm93XCIsIG5vdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWV0ZXh0XCIsIHRleHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXAobW9kZSwgdmFsdWVzLCBzdGVwcGVkKSB7XHJcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcmFuZ2UuXHJcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcInJhbmdlXCIgfHwgbW9kZSA9PT0gXCJzdGVwc1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0ueFZhbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwiY291bnRcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcyA8IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICd2YWx1ZXMnICg+PSAyKSByZXF1aXJlZCBmb3IgbW9kZSAnY291bnQnLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEaXZpZGUgMCAtIDEwMCBpbiAnY291bnQnIHBhcnRzLlxyXG4gICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gdmFsdWVzIC0gMTtcclxuICAgICAgICAgICAgICAgIHZhciBzcHJlYWQgPSAxMDAgLyBpbnRlcnZhbDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMaXN0IHRoZXNlIHBhcnRzIGFuZCBoYXZlIHRoZW0gaGFuZGxlZCBhcyAncG9zaXRpb25zJy5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChpbnRlcnZhbC0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2ludGVydmFsXSA9IGludGVydmFsICogc3ByZWFkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKDEwMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgbW9kZSA9IFwicG9zaXRpb25zXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcInBvc2l0aW9uc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXAgYWxsIHBlcmNlbnRhZ2VzIHRvIG9uLXJhbmdlIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhzdGVwcGVkID8gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCh2YWx1ZSkgOiB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwidmFsdWVzXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBtdXN0IGJlIHN0ZXBwZWQsIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHBlcmNlbnRhZ2UgZmlyc3QuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RlcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcGVyY2VudGFnZSwgYXBwbHkgc3RlcCwgcmV0dXJuIHRvIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAoc2NvcGVfU3BlY3RydW0udG9TdGVwcGluZyh2YWx1ZSkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGNhbiBzaW1wbHkgdXNlIHRoZSB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZVNwcmVhZChkZW5zaXR5LCBtb2RlLCBncm91cCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBzYWZlSW5jcmVtZW50KHZhbHVlLCBpbmNyZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGZsb2F0aW5nIHBvaW50IHZhcmlhbmNlIGJ5IGRyb3BwaW5nIHRoZSBzbWFsbGVzdCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgKyBpbmNyZW1lbnQpLnRvRml4ZWQoNykgLyAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kZXhlcyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RJblJhbmdlID0gc2NvcGVfU3BlY3RydW0ueFZhbFswXTtcclxuICAgICAgICAgICAgdmFyIGxhc3RJblJhbmdlID0gc2NvcGVfU3BlY3RydW0ueFZhbFtzY29wZV9TcGVjdHJ1bS54VmFsLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICB2YXIgaWdub3JlRmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGlnbm9yZUxhc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIHByZXZQY3QgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZ3JvdXAsIHNvcnQgaXQgYW5kIGZpbHRlciBhd2F5IGFsbCBkdXBsaWNhdGVzLlxyXG4gICAgICAgICAgICBncm91cCA9IHVuaXF1ZShcclxuICAgICAgICAgICAgICAgIGdyb3VwLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcmFuZ2Ugc3RhcnRzIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChncm91cFswXSAhPT0gZmlyc3RJblJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cC51bnNoaWZ0KGZpcnN0SW5SYW5nZSk7XHJcbiAgICAgICAgICAgICAgICBpZ25vcmVGaXJzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExpa2V3aXNlIGZvciB0aGUgbGFzdCBvbmUuXHJcbiAgICAgICAgICAgIGlmIChncm91cFtncm91cC5sZW5ndGggLSAxXSAhPT0gbGFzdEluUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwLnB1c2gobGFzdEluUmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWdub3JlTGFzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24oY3VycmVudCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzdGVwIGFuZCB0aGUgbG93ZXIgKyB1cHBlciBwb3NpdGlvbnMuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RlcDtcclxuICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHE7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gY3VycmVudDtcclxuICAgICAgICAgICAgICAgIHZhciBoaWdoID0gZ3JvdXBbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdQY3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGN0RGlmZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgIHZhciBwY3RQb3M7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGVwcztcclxuICAgICAgICAgICAgICAgIHZhciByZWFsU3RlcHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RlcFNpemU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNTdGVwcyA9IG1vZGUgPT09IFwic3RlcHNcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHVzaW5nICdzdGVwcycgbW9kZSwgdXNlIHRoZSBwcm92aWRlZCBzdGVwcy5cclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UnbGwgc3RlcCBvbiB0byB0aGUgbmV4dCBzdWJyYW5nZS5cclxuICAgICAgICAgICAgICAgIGlmIChpc1N0ZXBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IHNjb3BlX1NwZWN0cnVtLnhOdW1TdGVwc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBhICdmdWxsJyBzdGVwLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IGhpZ2ggLSBsb3c7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTG93IGNhbiBiZSAwLCBzbyB0ZXN0IGZvciBmYWxzZS4gSWYgaGlnaCBpcyB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgYXQgdGhlIGxhc3Qgc3VicmFuZ2UuIEluZGV4IDAgaXMgYWxyZWFkeSBoYW5kbGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGxvdyA9PT0gZmFsc2UgfHwgaGlnaCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdGVwIGlzbid0IDAsIHdoaWNoIHdvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3AgKCM2NTQpXHJcbiAgICAgICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoc3RlcCwgMC4wMDAwMDAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCBzdGVwcyBpbiB0aGUgc3VicmFuZ2UuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsb3c7IGkgPD0gaGlnaDsgaSA9IHNhZmVJbmNyZW1lbnQoaSwgc3RlcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBlcmNlbnRhZ2UgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHN0ZXAsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzaXplIGZvciB0aGUgc3VicmFuZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UGN0ID0gc2NvcGVfU3BlY3RydW0udG9TdGVwcGluZyhpKTtcclxuICAgICAgICAgICAgICAgICAgICBwY3REaWZmZXJlbmNlID0gbmV3UGN0IC0gcHJldlBjdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcHMgPSBwY3REaWZmZXJlbmNlIC8gZGVuc2l0eTtcclxuICAgICAgICAgICAgICAgICAgICByZWFsU3RlcHMgPSBNYXRoLnJvdW5kKHN0ZXBzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyByYXRpbyByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgcGVyY2VudGFnZS1zcGFjZSBhIHBvaW50IGluZGljYXRlcy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYSBkZW5zaXR5IDEgdGhlIHBvaW50cy9wZXJjZW50YWdlID0gMS4gRm9yIGRlbnNpdHkgMiwgdGhhdCBwZXJjZW50YWdlIG5lZWRzIHRvIGJlIHJlLWRpdmlkZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdGhlIHBlcmNlbnRhZ2Ugb2Zmc2V0IHRvIGFuIGV2ZW4gbnVtYmVyLCB0aGVuIGRpdmlkZSBieSB0d29cclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBzcHJlYWQgdGhlIG9mZnNldCBvbiBib3RoIHNpZGVzIG9mIHRoZSByYW5nZS5cclxuICAgICAgICAgICAgICAgICAgICBzdGVwU2l6ZSA9IHBjdERpZmZlcmVuY2UgLyByZWFsU3RlcHM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERpdmlkZSBhbGwgcG9pbnRzIGV2ZW5seSwgYWRkaW5nIHRoZSBjb3JyZWN0IG51bWJlciB0byB0aGlzIHN1YnJhbmdlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB1cCB0byA8PSBzbyB0aGF0IDEwMCUgZ2V0cyBhIHBvaW50LCBldmVudCBpZiBpZ25vcmVMYXN0IGlzIHNldC5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHEgPSAxOyBxIDw9IHJlYWxTdGVwczsgcSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByYXRpbyBiZXR3ZWVuIHRoZSByb3VuZGVkIHZhbHVlIGFuZCB0aGUgYWN0dWFsIHNpemUgbWlnaHQgYmUgfjElIG9mZi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29ycmVjdCB0aGUgcGVyY2VudGFnZSBvZmZzZXQgYnkgdGhlIG51bWJlciBvZiBwb2ludHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGVyIHN1YnJhbmdlLiBkZW5zaXR5ID0gMSB3aWxsIHJlc3VsdCBpbiAxMDAgcG9pbnRzIG9uIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmdWxsIHJhbmdlLCAyIGZvciA1MCwgNCBmb3IgMjUsIGV0Yy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGN0UG9zID0gcHJldlBjdCArIHEgKiBzdGVwU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1twY3RQb3MudG9GaXhlZCg1KV0gPSBbc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHBjdFBvcyksIDBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwb2ludCB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBncm91cC5pbmRleE9mKGkpID4gLTEgPyBQSVBTX0xBUkdFX1ZBTFVFIDogaXNTdGVwcyA/IFBJUFNfU01BTExfVkFMVUUgOiBQSVBTX05PX1ZBTFVFO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbmZvcmNlIHRoZSAnaWdub3JlRmlyc3QnIG9wdGlvbiBieSBvdmVyd3JpdGluZyB0aGUgdHlwZSBmb3IgMC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWluZGV4ICYmIGlnbm9yZUZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA9PT0gaGlnaCAmJiBpZ25vcmVMYXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIHRoZSAndHlwZScgb2YgdGhpcyBwb2ludC4gMCA9IHBsYWluLCAxID0gcmVhbCB2YWx1ZSwgMiA9IHN0ZXAgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXNbbmV3UGN0LnRvRml4ZWQoNSldID0gW2ksIHR5cGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwZXJjZW50YWdlIGNvdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZQY3QgPSBuZXdQY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4ZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZGRNYXJraW5nKHNwcmVhZCwgZmlsdGVyRnVuYywgZm9ybWF0dGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2NvcGVfRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZVNpemVDbGFzc2VzID0gW107XHJcbiAgICAgICAgICAgIHZhbHVlU2l6ZUNsYXNzZXNbUElQU19OT19WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVOb3JtYWw7XHJcbiAgICAgICAgICAgIHZhbHVlU2l6ZUNsYXNzZXNbUElQU19MQVJHRV9WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVMYXJnZTtcclxuICAgICAgICAgICAgdmFsdWVTaXplQ2xhc3Nlc1tQSVBTX1NNQUxMX1ZBTFVFXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZVN1YjtcclxuXHJcbiAgICAgICAgICAgIHZhciBtYXJrZXJTaXplQ2xhc3NlcyA9IFtdO1xyXG4gICAgICAgICAgICBtYXJrZXJTaXplQ2xhc3Nlc1tQSVBTX05PX1ZBTFVFXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJOb3JtYWw7XHJcbiAgICAgICAgICAgIG1hcmtlclNpemVDbGFzc2VzW1BJUFNfTEFSR0VfVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlckxhcmdlO1xyXG4gICAgICAgICAgICBtYXJrZXJTaXplQ2xhc3Nlc1tQSVBTX1NNQUxMX1ZBTFVFXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJTdWI7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgPSBbb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlSG9yaXpvbnRhbCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlVmVydGljYWxdO1xyXG4gICAgICAgICAgICB2YXIgbWFya2VyT3JpZW50YXRpb25DbGFzc2VzID0gW29wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJIb3Jpem9udGFsLCBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyVmVydGljYWxdO1xyXG5cclxuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHMpO1xyXG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBvcHRpb25zLm9ydCA9PT0gMCA/IG9wdGlvbnMuY3NzQ2xhc3Nlcy5waXBzSG9yaXpvbnRhbCA6IG9wdGlvbnMuY3NzQ2xhc3Nlcy5waXBzVmVydGljYWwpO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q2xhc3Nlcyh0eXBlLCBzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gc291cmNlID09PSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZW50YXRpb25DbGFzc2VzID0gYSA/IHZhbHVlT3JpZW50YXRpb25DbGFzc2VzIDogbWFya2VyT3JpZW50YXRpb25DbGFzc2VzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemVDbGFzc2VzID0gYSA/IHZhbHVlU2l6ZUNsYXNzZXMgOiBtYXJrZXJTaXplQ2xhc3NlcztcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlICsgXCIgXCIgKyBvcmllbnRhdGlvbkNsYXNzZXNbb3B0aW9ucy5vcnRdICsgXCIgXCIgKyBzaXplQ2xhc3Nlc1t0eXBlXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkU3ByZWFkKG9mZnNldCwgdmFsdWUsIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgZnVuY3Rpb24sIGlmIGl0IGlzIHNldC5cclxuICAgICAgICAgICAgICAgIHR5cGUgPSBmaWx0ZXJGdW5jID8gZmlsdGVyRnVuYyh2YWx1ZSwgdHlwZSkgOiB0eXBlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBQSVBTX05PTkUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgbWFya2VyIGZvciBldmVyeSBwb2ludFxyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBhZGROb2RlVG8oZWxlbWVudCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBnZXRDbGFzc2VzKHR5cGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXIpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZVtvcHRpb25zLnN0eWxlXSA9IG9mZnNldCArIFwiJVwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFZhbHVlcyBhcmUgb25seSBhcHBlbmRlZCBmb3IgcG9pbnRzIG1hcmtlZCAnMScgb3IgJzInLlxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPiBQSVBTX05PX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGFkZE5vZGVUbyhlbGVtZW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBnZXRDbGFzc2VzKHR5cGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlW29wdGlvbnMuc3R5bGVdID0gb2Zmc2V0ICsgXCIlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBmb3JtYXR0ZXIudG8odmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgYWxsIHBvaW50cy5cclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3ByZWFkKS5mb3JFYWNoKGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgYWRkU3ByZWFkKG9mZnNldCwgc3ByZWFkW29mZnNldF1bMF0sIHNwcmVhZFtvZmZzZXRdWzFdKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVBpcHMoKSB7XHJcbiAgICAgICAgICAgIGlmIChzY29wZV9QaXBzKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVFbGVtZW50KHNjb3BlX1BpcHMpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGVfUGlwcyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHBpcHMoZ3JpZCkge1xyXG4gICAgICAgICAgICAvLyBGaXggIzY2OVxyXG4gICAgICAgICAgICByZW1vdmVQaXBzKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbW9kZSA9IGdyaWQubW9kZTtcclxuICAgICAgICAgICAgdmFyIGRlbnNpdHkgPSBncmlkLmRlbnNpdHkgfHwgMTtcclxuICAgICAgICAgICAgdmFyIGZpbHRlciA9IGdyaWQuZmlsdGVyIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gZ3JpZC52YWx1ZXMgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBzdGVwcGVkID0gZ3JpZC5zdGVwcGVkIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBnZXRHcm91cChtb2RlLCB2YWx1ZXMsIHN0ZXBwZWQpO1xyXG4gICAgICAgICAgICB2YXIgc3ByZWFkID0gZ2VuZXJhdGVTcHJlYWQoZGVuc2l0eSwgbW9kZSwgZ3JvdXApO1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gZ3JpZC5mb3JtYXQgfHwge1xyXG4gICAgICAgICAgICAgICAgdG86IE1hdGgucm91bmRcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlX1BpcHMgPSBzY29wZV9UYXJnZXQuYXBwZW5kQ2hpbGQoYWRkTWFya2luZyhzcHJlYWQsIGZpbHRlciwgZm9ybWF0KSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2NvcGVfUGlwcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNob3J0aGFuZCBmb3IgYmFzZSBkaW1lbnNpb25zLlxyXG4gICAgICAgIGZ1bmN0aW9uIGJhc2VTaXplKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IHNjb3BlX0Jhc2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIHZhciBhbHQgPSBcIm9mZnNldFwiICsgW1wiV2lkdGhcIiwgXCJIZWlnaHRcIl1bb3B0aW9ucy5vcnRdO1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5vcnQgPT09IDAgPyByZWN0LndpZHRoIHx8IHNjb3BlX0Jhc2VbYWx0XSA6IHJlY3QuaGVpZ2h0IHx8IHNjb3BlX0Jhc2VbYWx0XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZXIgZm9yIGF0dGFjaGluZyBldmVudHMgdHJvdWdoIGEgcHJveHkuXHJcbiAgICAgICAgZnVuY3Rpb24gYXR0YWNoRXZlbnQoZXZlbnRzLCBlbGVtZW50LCBjYWxsYmFjaywgZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvICdmaWx0ZXInIGV2ZW50cyB0byB0aGUgc2xpZGVyLlxyXG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIGEgbm9kZSwgbm90IGEgbm9kZUxpc3RcclxuXHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gZml4RXZlbnQoZSwgZGF0YS5wYWdlT2Zmc2V0LCBkYXRhLnRhcmdldCB8fCBlbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBmaXhFdmVudCByZXR1cm5zIGZhbHNlIGlmIHRoaXMgZXZlbnQgaGFzIGEgZGlmZmVyZW50IHRhcmdldFxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBoYW5kbGluZyAobXVsdGktKSB0b3VjaCBldmVudHM7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZG9Ob3RSZWplY3QgaXMgcGFzc2VkIGJ5IGFsbCBlbmQgZXZlbnRzIHRvIG1ha2Ugc3VyZSByZWxlYXNlZCB0b3VjaGVzXHJcbiAgICAgICAgICAgICAgICAvLyBhcmUgbm90IHJlamVjdGVkLCBsZWF2aW5nIHRoZSBzbGlkZXIgXCJzdHVja1wiIHRvIHRoZSBjdXJzb3I7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVfVGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpICYmICFkYXRhLmRvTm90UmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0b3AgaWYgYW4gYWN0aXZlICd0YXAnIHRyYW5zaXRpb24gaXMgdGFraW5nIHBsYWNlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcCkgJiYgIWRhdGEuZG9Ob3RSZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHJpZ2h0IG9yIG1pZGRsZSBjbGlja3Mgb24gc3RhcnQgIzQ1NFxyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cyA9PT0gYWN0aW9ucy5zdGFydCAmJiBlLmJ1dHRvbnMgIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbnMgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSByaWdodCBvciBtaWRkbGUgY2xpY2tzIG9uIHN0YXJ0ICM0NTRcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhvdmVyICYmIGUuYnV0dG9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyAnc3VwcG9ydHNQYXNzaXZlJyBpcyBvbmx5IHRydWUgaWYgYSBicm93c2VyIGFsc28gc3VwcG9ydHMgdG91Y2gtYWN0aW9uOiBub25lIGluIENTUy5cclxuICAgICAgICAgICAgICAgIC8vIGlPUyBzYWZhcmkgZG9lcyBub3QsIHNvIGl0IGRvZXNuJ3QgZ2V0IHRvIGJlbmVmaXQgZnJvbSBwYXNzaXZlIHNjcm9sbGluZy4gaU9TIGRvZXMgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgLy8gdG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb24sIGJ1dCB0aGF0IGFsbG93cyBwYW5uaW5nLCB3aGljaCBicmVha3NcclxuICAgICAgICAgICAgICAgIC8vIHNsaWRlcnMgYWZ0ZXIgem9vbWluZy9vbiBub24tcmVzcG9uc2l2ZSBwYWdlcy5cclxuICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzMzExMlxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c1Bhc3NpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZS5jYWxjUG9pbnQgPSBlLnBvaW50c1tvcHRpb25zLm9ydF07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgZXZlbnQgaGFuZGxlciB3aXRoIHRoZSBldmVudCBbIGFuZCBhZGRpdGlvbmFsIGRhdGEgXS5cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGRhdGEpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJpbmQgYSBjbG9zdXJlIG9uIHRoZSB0YXJnZXQgZm9yIGV2ZXJ5IGV2ZW50IHR5cGUuXHJcbiAgICAgICAgICAgIGV2ZW50cy5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIG1ldGhvZCwgc3VwcG9ydHNQYXNzaXZlID8geyBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBtZXRob2RzLnB1c2goW2V2ZW50TmFtZSwgbWV0aG9kXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcm92aWRlIGEgY2xlYW4gZXZlbnQgd2l0aCBzdGFuZGFyZGl6ZWQgb2Zmc2V0IHZhbHVlcy5cclxuICAgICAgICBmdW5jdGlvbiBmaXhFdmVudChlLCBwYWdlT2Zmc2V0LCBldmVudFRhcmdldCkge1xyXG4gICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIHRoZSB0eXBlLCB3aGljaCBjYW4gYmVcclxuICAgICAgICAgICAgLy8gdG91Y2gsIG1vdXNlIG9yIHBvaW50ZXIuIE9mZnNldCBjaGFuZ2VzIG5lZWQgdG8gYmVcclxuICAgICAgICAgICAgLy8gbWFkZSBvbiBhbiBldmVudCBzcGVjaWZpYyBiYXNpcy5cclxuICAgICAgICAgICAgdmFyIHRvdWNoID0gZS50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA9PT0gMDtcclxuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS50eXBlLmluZGV4T2YoXCJtb3VzZVwiKSA9PT0gMDtcclxuICAgICAgICAgICAgdmFyIHBvaW50ZXIgPSBlLnR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgPT09IDA7XHJcblxyXG4gICAgICAgICAgICB2YXIgeDtcclxuICAgICAgICAgICAgdmFyIHk7XHJcblxyXG4gICAgICAgICAgICAvLyBJRTEwIGltcGxlbWVudGVkIHBvaW50ZXIgZXZlbnRzIHdpdGggYSBwcmVmaXg7XHJcbiAgICAgICAgICAgIGlmIChlLnR5cGUuaW5kZXhPZihcIk1TUG9pbnRlclwiKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBvbmx5IHRoaW5nIG9uZSBoYW5kbGUgc2hvdWxkIGJlIGNvbmNlcm5lZCBhYm91dCBpcyB0aGUgdG91Y2hlcyB0aGF0IG9yaWdpbmF0ZWQgb24gdG9wIG9mIGl0LlxyXG4gICAgICAgICAgICBpZiAodG91Y2gpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBhIHRvdWNoIG9yaWdpbmF0ZWQgb24gdGhlIHRhcmdldC5cclxuICAgICAgICAgICAgICAgIHZhciBpc1RvdWNoT25UYXJnZXQgPSBmdW5jdGlvbihjaGVja1RvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrVG91Y2gudGFyZ2V0ID09PSBldmVudFRhcmdldCB8fCBldmVudFRhcmdldC5jb250YWlucyhjaGVja1RvdWNoLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIHRvdWNoc3RhcnQgZXZlbnRzLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGVyZSBpcyBzdGlsbCBubyBtb3JlIHRoYW4gb25lXHJcbiAgICAgICAgICAgICAgICAvLyB0b3VjaCBvbiB0aGUgdGFyZ2V0IHNvIHdlIGxvb2sgYW1vbmdzdCBhbGwgdG91Y2hlcy5cclxuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwidG91Y2hzdGFydFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFRvdWNoZXMgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZS50b3VjaGVzLCBpc1RvdWNoT25UYXJnZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gb25lIHRvdWNoIHBlciBoYW5kbGUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB4ID0gdGFyZ2V0VG91Y2hlc1swXS5wYWdlWDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gdGFyZ2V0VG91Y2hlc1swXS5wYWdlWTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIG90aGVyIGNhc2VzLCBmaW5kIG9uIGNoYW5nZWRUb3VjaGVzIGlzIGVub3VnaC5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VG91Y2ggPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGUuY2hhbmdlZFRvdWNoZXMsIGlzVG91Y2hPblRhcmdldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbmNlbCBpZiB0aGUgdGFyZ2V0IHRvdWNoIGhhcyBub3QgbW92ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRUb3VjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB4ID0gdGFyZ2V0VG91Y2gucGFnZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRhcmdldFRvdWNoLnBhZ2VZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYWdlT2Zmc2V0ID0gcGFnZU9mZnNldCB8fCBnZXRQYWdlT2Zmc2V0KHNjb3BlX0RvY3VtZW50KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtb3VzZSB8fCBwb2ludGVyKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gZS5jbGllbnRYICsgcGFnZU9mZnNldC54O1xyXG4gICAgICAgICAgICAgICAgeSA9IGUuY2xpZW50WSArIHBhZ2VPZmZzZXQueTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZS5wYWdlT2Zmc2V0ID0gcGFnZU9mZnNldDtcclxuICAgICAgICAgICAgZS5wb2ludHMgPSBbeCwgeV07XHJcbiAgICAgICAgICAgIGUuY3Vyc29yID0gbW91c2UgfHwgcG9pbnRlcjsgLy8gRml4ICM0MzVcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVHJhbnNsYXRlIGEgY29vcmRpbmF0ZSBpbiB0aGUgZG9jdW1lbnQgdG8gYSBwZXJjZW50YWdlIG9uIHRoZSBzbGlkZXJcclxuICAgICAgICBmdW5jdGlvbiBjYWxjUG9pbnRUb1BlcmNlbnRhZ2UoY2FsY1BvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNhbGNQb2ludCAtIG9mZnNldChzY29wZV9CYXNlLCBvcHRpb25zLm9ydCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IChsb2NhdGlvbiAqIDEwMCkgLyBiYXNlU2l6ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xhbXAgcHJvcG9zYWwgYmV0d2VlbiAwJSBhbmQgMTAwJVxyXG4gICAgICAgICAgICAvLyBPdXQtb2YtYm91bmQgY29vcmRpbmF0ZXMgbWF5IG9jY3VyIHdoZW4gLm5vVWktYmFzZSBwc2V1ZG8tZWxlbWVudHNcclxuICAgICAgICAgICAgLy8gYXJlIHVzZWQgKGUuZy4gY29udGFpbmVkIGhhbmRsZXMgZmVhdHVyZSlcclxuICAgICAgICAgICAgcHJvcG9zYWwgPSBsaW1pdChwcm9wb3NhbCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBwcm9wb3NhbCA6IHByb3Bvc2FsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmluZCBoYW5kbGUgY2xvc2VzdCB0byBhIGNlcnRhaW4gcGVyY2VudGFnZSBvbiB0aGUgc2xpZGVyXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZShwcm9wb3NhbCkge1xyXG4gICAgICAgICAgICB2YXIgY2xvc2VzdCA9IDEwMDtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZU51bWJlciA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIC8vIERpc2FibGVkIGhhbmRsZXMgYXJlIGlnbm9yZWRcclxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGUuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IE1hdGguYWJzKHNjb3BlX0xvY2F0aW9uc1tpbmRleF0gLSBwcm9wb3NhbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBvcyA8IGNsb3Nlc3QgfHwgKHBvcyA9PT0gMTAwICYmIGNsb3Nlc3QgPT09IDEwMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXIgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0ID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVOdW1iZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaXJlICdlbmQnIHdoZW4gYSBtb3VzZSBvciBwZW4gbGVhdmVzIHRoZSBkb2N1bWVudC5cclxuICAgICAgICBmdW5jdGlvbiBkb2N1bWVudExlYXZlKGV2ZW50LCBkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBcIm1vdXNlb3V0XCIgJiYgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkhUTUxcIiAmJiBldmVudC5yZWxhdGVkVGFyZ2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudEVuZChldmVudCwgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBtb3ZlbWVudCBvbiBkb2N1bWVudCBmb3IgaGFuZGxlIGFuZCByYW5nZSBkcmFnLlxyXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50TW92ZShldmVudCwgZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBGaXggIzQ5OFxyXG4gICAgICAgICAgICAvLyBDaGVjayB2YWx1ZSBvZiAuYnV0dG9ucyBpbiAnc3RhcnQnIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFMTAgbW9iaWxlIChkYXRhLmJ1dHRvbnNQcm9wZXJ0eSkuXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvOTI3MDA1L21vYmlsZS1pZTEwLXdpbmRvd3MtcGhvbmUtYnV0dG9ucy1wcm9wZXJ0eS1vZi1wb2ludGVybW92ZS1ldmVudC1hbHdheXMtemVyb1xyXG4gICAgICAgICAgICAvLyBJRTkgaGFzIC5idXR0b25zIGFuZCAud2hpY2ggemVybyBvbiBtb3VzZW1vdmUuXHJcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggYnJlYWtzIHRoZSBzcGVjIE1ETiBkZWZpbmVzLlxyXG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZihcIk1TSUUgOVwiKSA9PT0gLTEgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMCAmJiBkYXRhLmJ1dHRvbnNQcm9wZXJ0eSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50RW5kKGV2ZW50LCBkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgYXJlIG1vdmluZyB1cCBvciBkb3duXHJcbiAgICAgICAgICAgIHZhciBtb3ZlbWVudCA9IChvcHRpb25zLmRpciA/IC0xIDogMSkgKiAoZXZlbnQuY2FsY1BvaW50IC0gZGF0YS5zdGFydENhbGNQb2ludCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBtb3ZlbWVudCBpbnRvIGEgcGVyY2VudGFnZSBvZiB0aGUgc2xpZGVyIHdpZHRoL2hlaWdodFxyXG4gICAgICAgICAgICB2YXIgcHJvcG9zYWwgPSAobW92ZW1lbnQgKiAxMDApIC8gZGF0YS5iYXNlU2l6ZTtcclxuXHJcbiAgICAgICAgICAgIG1vdmVIYW5kbGVzKG1vdmVtZW50ID4gMCwgcHJvcG9zYWwsIGRhdGEubG9jYXRpb25zLCBkYXRhLmhhbmRsZU51bWJlcnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVW5iaW5kIG1vdmUgZXZlbnRzIG9uIGRvY3VtZW50LCBjYWxsIGNhbGxiYWNrcy5cclxuICAgICAgICBmdW5jdGlvbiBldmVudEVuZChldmVudCwgZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBUaGUgaGFuZGxlIGlzIG5vIGxvbmdlciBhY3RpdmUsIHNvIHJlbW92ZSB0aGUgY2xhc3MuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLmhhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZGF0YS5oYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5hY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50IC09IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVuYmluZCB0aGUgbW92ZSBhbmQgZW5kIGV2ZW50cywgd2hpY2ggYXJlIGFkZGVkIG9uICdzdGFydCcuXHJcbiAgICAgICAgICAgIGRhdGEubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24oYykge1xyXG4gICAgICAgICAgICAgICAgc2NvcGVfRG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoY1swXSwgY1sxXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGRyYWdnaW5nIGNsYXNzLlxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuZHJhZyk7XHJcbiAgICAgICAgICAgICAgICBzZXRaaW5kZXgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY3Vyc29yIHN0eWxlcyBhbmQgdGV4dC1zZWxlY3Rpb24gZXZlbnRzIGJvdW5kIHRvIHRoZSBib2R5LlxyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnNvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkuc3R5bGUuY3Vyc29yID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3RzdGFydFwiLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRhdGEuaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwiY2hhbmdlXCIsIGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcImVuZFwiLCBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJpbmQgbW92ZSBldmVudHMgb24gZG9jdW1lbnQuXHJcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRTdGFydChldmVudCwgZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlO1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5oYW5kbGVOdW1iZXJzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbZGF0YS5oYW5kbGVOdW1iZXJzWzBdXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgJ2Rpc2FibGVkJyBoYW5kbGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlT3JpZ2luLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IGhhbmRsZU9yaWdpbi5jaGlsZHJlblswXTtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCArPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlIGhhbmRsZSBhcyAnYWN0aXZlJyBzbyBpdCBjYW4gYmUgc3R5bGVkLlxyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuYWN0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQSBkcmFnIHNob3VsZCBuZXZlciBwcm9wYWdhdGUgdXAgdG8gdGhlICd0YXAnIGV2ZW50LlxyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XHJcblxyXG4gICAgICAgICAgICAvLyBBdHRhY2ggdGhlIG1vdmUgYW5kIGVuZCBldmVudHMuXHJcbiAgICAgICAgICAgIHZhciBtb3ZlRXZlbnQgPSBhdHRhY2hFdmVudChhY3Rpb25zLm1vdmUsIHNjb3BlX0RvY3VtZW50RWxlbWVudCwgZXZlbnRNb3ZlLCB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXZlbnQgdGFyZ2V0IGhhcyBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcHJvcGFnYXRlIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCB3ZSBrZWVwXHJcbiAgICAgICAgICAgICAgICAvLyByZWx5aW5nIG9uIGl0IHRvIGV4dHJhY3QgdGFyZ2V0IHRvdWNoZXMuXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcclxuICAgICAgICAgICAgICAgIGhhbmRsZTogaGFuZGxlLFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXHJcbiAgICAgICAgICAgICAgICBzdGFydENhbGNQb2ludDogZXZlbnQuY2FsY1BvaW50LFxyXG4gICAgICAgICAgICAgICAgYmFzZVNpemU6IGJhc2VTaXplKCksXHJcbiAgICAgICAgICAgICAgICBwYWdlT2Zmc2V0OiBldmVudC5wYWdlT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyczogZGF0YS5oYW5kbGVOdW1iZXJzLFxyXG4gICAgICAgICAgICAgICAgYnV0dG9uc1Byb3BlcnR5OiBldmVudC5idXR0b25zLFxyXG4gICAgICAgICAgICAgICAgbG9jYXRpb25zOiBzY29wZV9Mb2NhdGlvbnMuc2xpY2UoKVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBlbmRFdmVudCA9IGF0dGFjaEV2ZW50KGFjdGlvbnMuZW5kLCBzY29wZV9Eb2N1bWVudEVsZW1lbnQsIGV2ZW50RW5kLCB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcclxuICAgICAgICAgICAgICAgIGhhbmRsZTogaGFuZGxlLFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXHJcbiAgICAgICAgICAgICAgICBkb05vdFJlamVjdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVyc1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBvdXRFdmVudCA9IGF0dGFjaEV2ZW50KFwibW91c2VvdXRcIiwgc2NvcGVfRG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudExlYXZlLCB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcclxuICAgICAgICAgICAgICAgIGhhbmRsZTogaGFuZGxlLFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXHJcbiAgICAgICAgICAgICAgICBkb05vdFJlamVjdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVyc1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIHB1c2hlZCB0aGUgbGlzdGVuZXJzIGluIHRoZSBsaXN0ZW5lciBsaXN0IHJhdGhlciB0aGFuIGNyZWF0aW5nXHJcbiAgICAgICAgICAgIC8vIGEgbmV3IG9uZSBhcyBpdCBoYXMgYWxyZWFkeSBiZWVuIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoLmFwcGx5KGxpc3RlbmVycywgbW92ZUV2ZW50LmNvbmNhdChlbmRFdmVudCwgb3V0RXZlbnQpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRleHQgc2VsZWN0aW9uIGlzbid0IGFuIGlzc3VlIG9uIHRvdWNoIGRldmljZXMsXHJcbiAgICAgICAgICAgIC8vIHNvIGFkZGluZyBjdXJzb3Igc3R5bGVzIGNhbiBiZSBza2lwcGVkLlxyXG4gICAgICAgICAgICBpZiAoZXZlbnQuY3Vyc29yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRoZSAnSScgY3Vyc29yIGFuZCBleHRlbmQgdGhlIHJhbmdlLWRyYWcgY3Vyc29yLlxyXG4gICAgICAgICAgICAgICAgc2NvcGVfQm9keS5zdHlsZS5jdXJzb3IgPSBnZXRDb21wdXRlZFN0eWxlKGV2ZW50LnRhcmdldCkuY3Vyc29yO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlIHRhcmdldCB3aXRoIGEgZHJhZ2dpbmcgc3RhdGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuZHJhZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0ZXh0IHNlbGVjdGlvbiB3aGVuIGRyYWdnaW5nIHRoZSBoYW5kbGVzLlxyXG4gICAgICAgICAgICAgICAgLy8gSW4gbm9VaVNsaWRlciA8PSA5LjIuMCwgdGhpcyB3YXMgaGFuZGxlZCBieSBjYWxsaW5nIHByZXZlbnREZWZhdWx0IG9uIG1vdXNlL3RvdWNoIHN0YXJ0L21vdmUsXHJcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBpcyBzY3JvbGwgYmxvY2tpbmcuIFRoZSBzZWxlY3RzdGFydCBldmVudCBpcyBzdXBwb3J0ZWQgYnkgRmlyZUZveCBzdGFydGluZyBmcm9tIHZlcnNpb24gNTIsXHJcbiAgICAgICAgICAgICAgICAvLyBtZWFuaW5nIHRoZSBvbmx5IGhvbGRvdXQgaXMgaU9TIFNhZmFyaS4gVGhpcyBkb2Vzbid0IG1hdHRlcjogdGV4dCBzZWxlY3Rpb24gaXNuJ3QgdHJpZ2dlcmVkIHRoZXJlLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlICdjdXJzb3InIGZsYWcgaXMgZmFsc2UuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXNlbGVjdHN0YXJ0XHJcbiAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3RzdGFydFwiLCBwcmV2ZW50RGVmYXVsdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInN0YXJ0XCIsIGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTW92ZSBjbG9zZXN0IGhhbmRsZSB0byB0YXBwZWQgbG9jYXRpb24uXHJcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRUYXAoZXZlbnQpIHtcclxuICAgICAgICAgICAgLy8gVGhlIHRhcCBldmVudCBzaG91bGRuJ3QgcHJvcGFnYXRlIHVwXHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gY2FsY1BvaW50VG9QZXJjZW50YWdlKGV2ZW50LmNhbGNQb2ludCk7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVOdW1iZXIgPSBnZXRDbG9zZXN0SGFuZGxlKHByb3Bvc2FsKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRhY2tsZSB0aGUgY2FzZSB0aGF0IGFsbCBoYW5kbGVzIGFyZSAnZGlzYWJsZWQnLlxyXG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGbGFnIHRoZSBzbGlkZXIgYXMgaXQgaXMgbm93IGluIGEgdHJhbnNpdGlvbmFsIHN0YXRlLlxyXG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIHRha2VzIGEgY29uZmlndXJhYmxlIGFtb3VudCBvZiBtcyAoZGVmYXVsdCAzMDApLiBSZS1lbmFibGUgdGhlIHNsaWRlciBhZnRlciB0aGF0LlxyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZXZlbnRzLnNuYXApIHtcclxuICAgICAgICAgICAgICAgIGFkZENsYXNzRm9yKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcCwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHByb3Bvc2FsLCB0cnVlLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIHNldFppbmRleCgpO1xyXG5cclxuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2xpZGVcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGZpcmVFdmVudChcImNoYW5nZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xyXG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmV2ZW50cy5zbmFwKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudFN0YXJ0KGV2ZW50LCB7IGhhbmRsZU51bWJlcnM6IFtoYW5kbGVOdW1iZXJdIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaXJlcyBhICdob3ZlcicgZXZlbnQgZm9yIGEgaG92ZXJlZCBtb3VzZS9wZW4gcG9zaXRpb24uXHJcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRIb3ZlcihldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcG9zYWwgPSBjYWxjUG9pbnRUb1BlcmNlbnRhZ2UoZXZlbnQuY2FsY1BvaW50KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAocHJvcG9zYWwpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcodG8pO1xyXG5cclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKHRhcmdldEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJob3ZlclwiID09PSB0YXJnZXRFdmVudC5zcGxpdChcIi5cIilbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZV9FdmVudHNbdGFyZ2V0RXZlbnRdLmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChzY29wZV9TZWxmLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXR0YWNoIGV2ZW50cyB0byBzZXZlcmFsIHNsaWRlciBwYXJ0cy5cclxuICAgICAgICBmdW5jdGlvbiBiaW5kU2xpZGVyRXZlbnRzKGJlaGF2aW91cikge1xyXG4gICAgICAgICAgICAvLyBBdHRhY2ggdGhlIHN0YW5kYXJkIGRyYWcgZXZlbnQgdG8gdGhlIGhhbmRsZXMuXHJcbiAgICAgICAgICAgIGlmICghYmVoYXZpb3VyLmZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGV2ZW50cyBhcmUgb25seSBib3VuZCB0byB0aGUgdmlzdWFsIGhhbmRsZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQsIG5vdCB0aGUgJ3JlYWwnIG9yaWdpbiBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50KGFjdGlvbnMuc3RhcnQsIGhhbmRsZS5jaGlsZHJlblswXSwgZXZlbnRTdGFydCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBbaW5kZXhdXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSB0YXAgZXZlbnQgdG8gdGhlIHNsaWRlciBiYXNlLlxyXG4gICAgICAgICAgICBpZiAoYmVoYXZpb3VyLnRhcCkge1xyXG4gICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5zdGFydCwgc2NvcGVfQmFzZSwgZXZlbnRUYXAsIHt9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmlyZSBob3ZlciBldmVudHNcclxuICAgICAgICAgICAgaWYgKGJlaGF2aW91ci5ob3Zlcikge1xyXG4gICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5tb3ZlLCBzY29wZV9CYXNlLCBldmVudEhvdmVyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG92ZXI6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHRoZSByYW5nZSBkcmFnZ2FibGUuXHJcbiAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuZHJhZykge1xyXG4gICAgICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHMuZm9yRWFjaChmdW5jdGlvbihjb25uZWN0LCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0ID09PSBmYWxzZSB8fCBpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gc2NvcGVfQ29ubmVjdHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlQmVmb3JlID0gc2NvcGVfSGFuZGxlc1tpbmRleCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVBZnRlciA9IHNjb3BlX0hhbmRsZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudEhvbGRlcnMgPSBbY29ubmVjdF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGNvbm5lY3QsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnZ2FibGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSByYW5nZSBpcyBmaXhlZCwgdGhlIGVudGlyZSByYW5nZSBjYW5cclxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBkcmFnZ2VkIGJ5IHRoZSBoYW5kbGVzLiBUaGUgaGFuZGxlIGluIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbiB3aWxsIHByb3BhZ2F0ZSB0aGUgc3RhcnQgZXZlbnQgdXB3YXJkLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCBuZWVkcyB0byBiZSBib3VuZCBtYW51YWxseSBvbiB0aGUgb3RoZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlaGF2aW91ci5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEhvbGRlcnMucHVzaChoYW5kbGVCZWZvcmUuY2hpbGRyZW5bMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEhvbGRlcnMucHVzaChoYW5kbGVBZnRlci5jaGlsZHJlblswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBldmVudEhvbGRlcnMuZm9yRWFjaChmdW5jdGlvbihldmVudEhvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBldmVudEhvbGRlciwgZXZlbnRTdGFydCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlczogW2hhbmRsZUJlZm9yZSwgaGFuZGxlQWZ0ZXJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyczogW2luZGV4IC0gMSwgaW5kZXhdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF0dGFjaCBhbiBldmVudCB0byB0aGlzIHNsaWRlciwgcG9zc2libHkgaW5jbHVkaW5nIGEgbmFtZXNwYWNlXHJcbiAgICAgICAgZnVuY3Rpb24gYmluZEV2ZW50KG5hbWVzcGFjZWRFdmVudCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgc2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0gPSBzY29wZV9FdmVudHNbbmFtZXNwYWNlZEV2ZW50XSB8fCBbXTtcclxuICAgICAgICAgICAgc2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0ucHVzaChjYWxsYmFjayk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgYm91bmQgaXMgJ3VwZGF0ZSwnIGZpcmUgaXQgaW1tZWRpYXRlbHkgZm9yIGFsbCBoYW5kbGVzLlxyXG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlZEV2ZW50LnNwbGl0KFwiLlwiKVswXSA9PT0gXCJ1cGRhdGVcIikge1xyXG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVbmRvIGF0dGFjaG1lbnQgb2YgZXZlbnRcclxuICAgICAgICBmdW5jdGlvbiByZW1vdmVFdmVudChuYW1lc3BhY2VkRXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmFtZXNwYWNlZEV2ZW50ICYmIG5hbWVzcGFjZWRFdmVudC5zcGxpdChcIi5cIilbMF07XHJcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBldmVudCAmJiBuYW1lc3BhY2VkRXZlbnQuc3Vic3RyaW5nKGV2ZW50Lmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24oYmluZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRFdmVudCA9IGJpbmQuc3BsaXQoXCIuXCIpWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHROYW1lc3BhY2UgPSBiaW5kLnN1YnN0cmluZyh0RXZlbnQubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKCFldmVudCB8fCBldmVudCA9PT0gdEV2ZW50KSAmJiAoIW5hbWVzcGFjZSB8fCBuYW1lc3BhY2UgPT09IHROYW1lc3BhY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjb3BlX0V2ZW50c1tiaW5kXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeHRlcm5hbCBldmVudCBoYW5kbGluZ1xyXG4gICAgICAgIGZ1bmN0aW9uIGZpcmVFdmVudChldmVudE5hbWUsIGhhbmRsZU51bWJlciwgdGFwKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbih0YXJnZXRFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IHRhcmdldEV2ZW50LnNwbGl0KFwiLlwiKVswXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBldmVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZV9FdmVudHNbdGFyZ2V0RXZlbnRdLmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2xpZGVyIHB1YmxpYyBBUEkgYXMgdGhlIHNjb3BlICgndGhpcycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9TZWxmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHZhbHVlcyBhcyBhcnJheSwgc28gYXJnXzFbYXJnXzJdIGlzIGFsd2F5cyB2YWxpZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX1ZhbHVlcy5tYXAob3B0aW9ucy5mb3JtYXQudG8pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGluZGV4LCAwIG9yIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuLWZvcm1hdHRlZCBzbGlkZXIgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9WYWx1ZXMuc2xpY2UoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2ZW50IGlzIGZpcmVkIGJ5IHRhcCwgdHJ1ZSBvciBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFwIHx8IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVmdCBvZmZzZXQgb2YgdGhlIGhhbmRsZSwgaW4gcmVsYXRpb24gdG8gdGhlIHNsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfTG9jYXRpb25zLnNsaWNlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB0b1BjdChwY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBjdCArIFwiJVwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3BsaXQgb3V0IHRoZSBoYW5kbGUgcG9zaXRpb25pbmcgbG9naWMgc28gdGhlIE1vdmUgZXZlbnQgY2FuIHVzZSBpdCwgdG9vXHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tIYW5kbGVQb3NpdGlvbihyZWZlcmVuY2UsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQsIGdldFZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBzbGlkZXJzIHdpdGggbXVsdGlwbGUgaGFuZGxlcywgbGltaXQgbW92ZW1lbnQgdG8gdGhlIG90aGVyIGhhbmRsZS5cclxuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIG1hcmdpbiBvcHRpb24gYnkgYWRkaW5nIGl0IHRvIHRoZSBoYW5kbGUgcG9zaXRpb25zLlxyXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmICFvcHRpb25zLmV2ZW50cy51bmNvbnN0cmFpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9va0JhY2t3YXJkICYmIGhhbmRsZU51bWJlciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCByZWZlcmVuY2VbaGFuZGxlTnVtYmVyIC0gMV0gKyBvcHRpb25zLm1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxvb2tGb3J3YXJkICYmIGhhbmRsZU51bWJlciA8IHNjb3BlX0hhbmRsZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSAtIG9wdGlvbnMubWFyZ2luKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGxpbWl0IG9wdGlvbiBoYXMgdGhlIG9wcG9zaXRlIGVmZmVjdCwgbGltaXRpbmcgaGFuZGxlcyB0byBhXHJcbiAgICAgICAgICAgIC8vIG1heGltdW0gZGlzdGFuY2UgZnJvbSBhbm90aGVyLiBMaW1pdCBtdXN0IGJlID4gMCwgYXMgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgIC8vIGhhbmRsZXMgd291bGQgYmUgdW5tb3ZhYmxlLlxyXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMubGltaXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsb29rQmFja3dhcmQgJiYgaGFuZGxlTnVtYmVyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgLSAxXSArIG9wdGlvbnMubGltaXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsb29rRm9yd2FyZCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCByZWZlcmVuY2VbaGFuZGxlTnVtYmVyICsgMV0gLSBvcHRpb25zLmxpbWl0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHBhZGRpbmcgb3B0aW9uIGtlZXBzIHRoZSBoYW5kbGVzIGEgY2VydGFpbiBkaXN0YW5jZSBmcm9tIHRoZVxyXG4gICAgICAgICAgICAvLyBlZGdlcyBvZiB0aGUgc2xpZGVyLiBQYWRkaW5nIG11c3QgYmUgPiAwLlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWRkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgb3B0aW9ucy5wYWRkaW5nWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCAxMDAgLSBvcHRpb25zLnBhZGRpbmdbMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAodG8pO1xyXG5cclxuICAgICAgICAgICAgLy8gTGltaXQgcGVyY2VudGFnZSB0byB0aGUgMCAtIDEwMCByYW5nZVxyXG4gICAgICAgICAgICB0byA9IGxpbWl0KHRvKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiBmYWxzZSBpZiBoYW5kbGUgY2FuJ3QgbW92ZVxyXG4gICAgICAgICAgICBpZiAodG8gPT09IHJlZmVyZW5jZVtoYW5kbGVOdW1iZXJdICYmICFnZXRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2VzIHNsaWRlciBvcmllbnRhdGlvbiB0byBjcmVhdGUgQ1NTIHJ1bGVzLiBhID0gYmFzZSB2YWx1ZTtcclxuICAgICAgICBmdW5jdGlvbiBpblJ1bGVPcmRlcih2LCBhKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gb3B0aW9ucy5vcnQ7XHJcbiAgICAgICAgICAgIHJldHVybiAobyA/IGEgOiB2KSArIFwiLCBcIiArIChvID8gdiA6IGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTW92ZXMgaGFuZGxlKHMpIGJ5IGEgcGVyY2VudGFnZVxyXG4gICAgICAgIC8vIChib29sLCAlIHRvIG1vdmUsIFslIHdoZXJlIGhhbmRsZSBzdGFydGVkLCAuLi5dLCBbaW5kZXggaW4gc2NvcGVfSGFuZGxlcywgLi4uXSlcclxuICAgICAgICBmdW5jdGlvbiBtb3ZlSGFuZGxlcyh1cHdhcmQsIHByb3Bvc2FsLCBsb2NhdGlvbnMsIGhhbmRsZU51bWJlcnMpIHtcclxuICAgICAgICAgICAgdmFyIHByb3Bvc2FscyA9IGxvY2F0aW9ucy5zbGljZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGIgPSBbIXVwd2FyZCwgdXB3YXJkXTtcclxuICAgICAgICAgICAgdmFyIGYgPSBbdXB3YXJkLCAhdXB3YXJkXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvcHkgaGFuZGxlTnVtYmVycyBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIGRhdGFzZXRcclxuICAgICAgICAgICAgaGFuZGxlTnVtYmVycyA9IGhhbmRsZU51bWJlcnMuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSB3aGljaCBoYW5kbGUgaXMgJ2xlYWRpbmcnLlxyXG4gICAgICAgICAgICAvLyBJZiB0aGF0IG9uZSBjYW4ndCBtb3ZlIHRoZSBzZWNvbmQgY2FuJ3QgZWl0aGVyLlxyXG4gICAgICAgICAgICBpZiAodXB3YXJkKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3RlcCAxOiBnZXQgdGhlIG1heGltdW0gcGVyY2VudGFnZSB0aGF0IGFueSBvZiB0aGUgaGFuZGxlcyBjYW4gbW92ZVxyXG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyLCBvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWxzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdICsgcHJvcG9zYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJbb10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZbb10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBpZiBvbmUgb2YgdGhlIGhhbmRsZXMgY2FuJ3QgbW92ZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodG8gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbCA9IHRvIC0gcHJvcG9zYWxzW2hhbmRsZU51bWJlcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdID0gdG87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHVzaW5nIG9uZSBoYW5kbGUsIGNoZWNrIGJhY2t3YXJkIEFORCBmb3J3YXJkXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYiA9IGYgPSBbdHJ1ZV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RlcCAyOiBUcnkgdG8gc2V0IHRoZSBoYW5kbGVzIHdpdGggdGhlIGZvdW5kIHBlcmNlbnRhZ2VcclxuICAgICAgICAgICAgaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlciwgbykge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBsb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSArIHByb3Bvc2FsLCBiW29dLCBmW29dKSB8fCBzdGF0ZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdGVwIDM6IElmIGEgaGFuZGxlIG1vdmVkLCBmaXJlIGV2ZW50c1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzbGlkZVwiLCBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRha2VzIGEgYmFzZSB2YWx1ZSBhbmQgYW4gb2Zmc2V0LiBUaGlzIG9mZnNldCBpcyB1c2VkIGZvciB0aGUgY29ubmVjdCBiYXIgc2l6ZS5cclxuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBkZXNpZ24gZm9yIHRoaXMgZmVhdHVyZSwgdGhlIG9yaWdpbiBlbGVtZW50IHdhcyAxJSB3aWRlLlxyXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIGEgcm91bmRpbmcgYnVnIGluIENocm9tZSBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGZlYXR1cmVcclxuICAgICAgICAvLyBpbiB0aGlzIG1hbm5lcjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Nzk4MjIzXHJcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGlyID8gMTAwIC0gYSAtIGIgOiBhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlcyBzY29wZV9Mb2NhdGlvbnMgYW5kIHNjb3BlX1ZhbHVlcywgdXBkYXRlcyB2aXN1YWwgc3RhdGVcclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVIYW5kbGVQb3NpdGlvbihoYW5kbGVOdW1iZXIsIHRvKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsb2NhdGlvbnMuXHJcbiAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID0gdG87XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byB0aGUgc2xpZGVyIHN0ZXBwaW5nL3JhbmdlLlxyXG4gICAgICAgICAgICBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcnVsZSA9IFwidHJhbnNsYXRlKFwiICsgaW5SdWxlT3JkZXIodG9QY3QodHJhbnNmb3JtRGlyZWN0aW9uKHRvLCAwKSAtIHNjb3BlX0Rpck9mZnNldCksIFwiMFwiKSArIFwiKVwiO1xyXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzW2hhbmRsZU51bWJlcl0uc3R5bGVbb3B0aW9ucy50cmFuc2Zvcm1SdWxlXSA9IHJ1bGU7XHJcblxyXG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0KGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3QoaGFuZGxlTnVtYmVyICsgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBIYW5kbGVzIGJlZm9yZSB0aGUgc2xpZGVyIG1pZGRsZSBhcmUgc3RhY2tlZCBsYXRlciA9IGhpZ2hlcixcclxuICAgICAgICAvLyBIYW5kbGVzIGFmdGVyIHRoZSBtaWRkbGUgbGF0ZXIgaXMgbG93ZXJcclxuICAgICAgICAvLyBbWzddIFs4XSAuLi4uLi4uLi4uIHwgLi4uLi4uLi4uLiBbNV0gWzRdXHJcbiAgICAgICAgZnVuY3Rpb24gc2V0WmluZGV4KCkge1xyXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0gPiA1MCA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgIHZhciB6SW5kZXggPSAzICsgKHNjb3BlX0hhbmRsZXMubGVuZ3RoICsgZGlyICogaGFuZGxlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXS5zdHlsZS56SW5kZXggPSB6SW5kZXg7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGVzdCBzdWdnZXN0ZWQgdmFsdWVzIGFuZCBhcHBseSBtYXJnaW4sIHN0ZXAuXHJcbiAgICAgICAgZnVuY3Rpb24gc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQpIHtcclxuICAgICAgICAgICAgdG8gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHNjb3BlX0xvY2F0aW9ucywgaGFuZGxlTnVtYmVyLCB0bywgbG9va0JhY2t3YXJkLCBsb29rRm9yd2FyZCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRvID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB1cGRhdGVIYW5kbGVQb3NpdGlvbihoYW5kbGVOdW1iZXIsIHRvKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlcyBzdHlsZSBhdHRyaWJ1dGUgZm9yIGNvbm5lY3Qgbm9kZXNcclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDb25uZWN0KGluZGV4KSB7XHJcbiAgICAgICAgICAgIC8vIFNraXAgY29ubmVjdHMgc2V0IHRvIGZhbHNlXHJcbiAgICAgICAgICAgIGlmICghc2NvcGVfQ29ubmVjdHNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBsID0gMDtcclxuICAgICAgICAgICAgdmFyIGggPSAxMDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGwgPSBzY29wZV9Mb2NhdGlvbnNbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBzY29wZV9Db25uZWN0cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBoID0gc2NvcGVfTG9jYXRpb25zW2luZGV4XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gV2UgdXNlIHR3byBydWxlczpcclxuICAgICAgICAgICAgLy8gJ3RyYW5zbGF0ZScgdG8gY2hhbmdlIHRoZSBsZWZ0L3RvcCBvZmZzZXQ7XHJcbiAgICAgICAgICAgIC8vICdzY2FsZScgdG8gY2hhbmdlIHRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudDtcclxuICAgICAgICAgICAgLy8gQXMgdGhlIGVsZW1lbnQgaGFzIGEgd2lkdGggb2YgMTAwJSwgYSB0cmFuc2xhdGlvbiBvZiAxMDAlIGlzIGVxdWFsIHRvIDEwMCUgb2YgdGhlIHBhcmVudCAoLm5vVWktYmFzZSlcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RXaWR0aCA9IGggLSBsO1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRlUnVsZSA9IFwidHJhbnNsYXRlKFwiICsgaW5SdWxlT3JkZXIodG9QY3QodHJhbnNmb3JtRGlyZWN0aW9uKGwsIGNvbm5lY3RXaWR0aCkpLCBcIjBcIikgKyBcIilcIjtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUnVsZSA9IFwic2NhbGUoXCIgKyBpblJ1bGVPcmRlcihjb25uZWN0V2lkdGggLyAxMDAsIFwiMVwiKSArIFwiKVwiO1xyXG5cclxuICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHNbaW5kZXhdLnN0eWxlW29wdGlvbnMudHJhbnNmb3JtUnVsZV0gPSB0cmFuc2xhdGVSdWxlICsgXCIgXCIgKyBzY2FsZVJ1bGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQYXJzZXMgdmFsdWUgcGFzc2VkIHRvIC5zZXQgbWV0aG9kLiBSZXR1cm5zIGN1cnJlbnQgdmFsdWUgaWYgbm90IHBhcnNlLWFibGUuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZVRvVmFsdWUodG8sIGhhbmRsZU51bWJlcikge1xyXG4gICAgICAgICAgICAvLyBTZXR0aW5nIHdpdGggbnVsbCBpbmRpY2F0ZXMgYW4gJ2lnbm9yZScuXHJcbiAgICAgICAgICAgIC8vIElucHV0dGluZyAnZmFsc2UnIGlzIGludmFsaWQuXHJcbiAgICAgICAgICAgIGlmICh0byA9PT0gbnVsbCB8fCB0byA9PT0gZmFsc2UgfHwgdG8gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBhIGZvcm1hdHRlZCBudW1iZXIgd2FzIHBhc3NlZCwgYXR0ZW1wdCB0byBkZWNvZGUgaXQuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgIHRvID0gU3RyaW5nKHRvKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdG8gPSBvcHRpb25zLmZvcm1hdC5mcm9tKHRvKTtcclxuICAgICAgICAgICAgdG8gPSBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHRvKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHBhcnNpbmcgdGhlIG51bWJlciBmYWlsZWQsIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cclxuICAgICAgICAgICAgaWYgKHRvID09PSBmYWxzZSB8fCBpc05hTih0bykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBzbGlkZXIgdmFsdWUuXHJcbiAgICAgICAgZnVuY3Rpb24gdmFsdWVTZXQoaW5wdXQsIGZpcmVTZXRFdmVudCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gYXNBcnJheShpbnB1dCk7XHJcbiAgICAgICAgICAgIHZhciBpc0luaXQgPSBzY29wZV9Mb2NhdGlvbnNbMF0gPT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIC8vIEV2ZW50IGZpcmVzIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgZmlyZVNldEV2ZW50ID0gZmlyZVNldEV2ZW50ID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFmaXJlU2V0RXZlbnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBBbmltYXRpb24gaXMgb3B0aW9uYWwuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5pdGlhbCB2YWx1ZXMgd2VyZSBzZXQgYmVmb3JlIHVzaW5nIGFuaW1hdGVkIHBsYWNlbWVudC5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiAhaXNJbml0KSB7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzc0ZvcihzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXAsIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaXJzdCBwYXNzLCB3aXRob3V0IGxvb2tBaGVhZCBidXQgd2l0aCBsb29rQmFja3dhcmQuIFZhbHVlcyBhcmUgc2V0IGZyb20gbGVmdCB0byByaWdodC5cclxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgcmVzb2x2ZVRvVmFsdWUodmFsdWVzW2hhbmRsZU51bWJlcl0sIGhhbmRsZU51bWJlciksIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZWNvbmQgcGFzcy4gTm93IHRoYXQgYWxsIGJhc2UgdmFsdWVzIGFyZSBzZXQsIGFwcGx5IGNvbnN0cmFpbnRzXHJcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBzZXRaaW5kZXgoKTtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpcmUgdGhlIGV2ZW50IG9ubHkgZm9yIGhhbmRsZXMgdGhhdCByZWNlaXZlZCBhIG5ldyB2YWx1ZSwgYXMgcGVyICM1NzlcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbaGFuZGxlTnVtYmVyXSAhPT0gbnVsbCAmJiBmaXJlU2V0RXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXNldCBzbGlkZXIgdG8gaW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICBmdW5jdGlvbiB2YWx1ZVJlc2V0KGZpcmVTZXRFdmVudCkge1xyXG4gICAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0LCBmaXJlU2V0RXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2V0IHZhbHVlIGZvciBhIHNpbmdsZSBoYW5kbGVcclxuICAgICAgICBmdW5jdGlvbiB2YWx1ZVNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHZhbHVlLCBmaXJlU2V0RXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5zdXJlIG51bWVyaWMgaW5wdXRcclxuICAgICAgICAgICAgaGFuZGxlTnVtYmVyID0gTnVtYmVyKGhhbmRsZU51bWJlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoIShoYW5kbGVOdW1iZXIgPj0gMCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVOdW1iZXJzLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogaW52YWxpZCBoYW5kbGUgbnVtYmVyLCBnb3Q6IFwiICsgaGFuZGxlTnVtYmVyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY29wZV9IYW5kbGVOdW1iZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YWx1ZXNbaGFuZGxlTnVtYmVyXSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgdmFsdWVTZXQodmFsdWVzLCBmaXJlU2V0RXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBzbGlkZXIgdmFsdWUuXHJcbiAgICAgICAgZnVuY3Rpb24gdmFsdWVHZXQoKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBzY29wZV9WYWx1ZXMubWFwKG9wdGlvbnMuZm9ybWF0LnRvKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG9ubHkgb25lIGhhbmRsZSBpcyB1c2VkLCByZXR1cm4gYSBzaW5nbGUgdmFsdWUuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzWzBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlcyBjbGFzc2VzIGZyb20gdGhlIHJvb3QgYW5kIGVtcHRpZXMgaXQuXHJcbiAgICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY3NzQ2xhc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNzc0NsYXNzZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXNba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChzY29wZV9UYXJnZXQuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgc2NvcGVfVGFyZ2V0LnJlbW92ZUNoaWxkKHNjb3BlX1RhcmdldC5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGVsZXRlIHNjb3BlX1RhcmdldC5ub1VpU2xpZGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0ZXAgc2l6ZSBmb3IgdGhlIHNsaWRlci5cclxuICAgICAgICBmdW5jdGlvbiBnZXRDdXJyZW50U3RlcCgpIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgYWxsIGxvY2F0aW9ucywgbWFwIHRoZW0gdG8gdGhlaXIgc3RlcHBpbmcgcG9pbnQuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgc3RlcCBwb2ludCwgdGhlbiBmaW5kIGl0IGluIHRoZSBpbnB1dCBsaXN0LlxyXG4gICAgICAgICAgICByZXR1cm4gc2NvcGVfTG9jYXRpb25zLm1hcChmdW5jdGlvbihsb2NhdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZWFyYnlTdGVwcyA9IHNjb3BlX1NwZWN0cnVtLmdldE5lYXJieVN0ZXBzKGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNjb3BlX1ZhbHVlc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5jcmVtZW50ID0gbmVhcmJ5U3RlcHMudGhpc1N0ZXAuc3RlcDtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNyZW1lbnQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IHZhbHVlIGluIHRoaXMgc3RlcCBtb3ZlcyBpbnRvIHRoZSBuZXh0IHN0ZXAsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5jcmVtZW50IGlzIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBzdGVwIC0gdGhlIGN1cnJlbnQgdmFsdWVcclxuICAgICAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICsgaW5jcmVtZW50ID4gbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUgLSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGJleW9uZCB0aGUgc3RhcnRpbmcgcG9pbnRcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0YXJ0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSBuZWFyYnlTdGVwcy50aGlzU3RlcC5zdGVwO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLnN0ZXAgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBoYW5kbGUgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgc3RlcCwgaXQgYWx3YXlzIHN0ZXBzIGJhY2sgaW50byB0aGUgcHJldmlvdXMgc3RlcCBmaXJzdFxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gdmFsdWUgLSBuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLmhpZ2hlc3RTdGVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vdywgaWYgYXQgdGhlIHNsaWRlciBlZGdlcywgdGhlcmUgaXMgbm90IGluL2RlY3JlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uID09PSAxMDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhdGlvbiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXMgcGVyICMzOTEsIHRoZSBjb21wYXJpc29uIGZvciB0aGUgZGVjcmVtZW50IHN0ZXAgY2FuIGhhdmUgc29tZSByb3VuZGluZyBpc3N1ZXMuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RlcERlY2ltYWxzID0gc2NvcGVfU3BlY3RydW0uY291bnRTdGVwRGVjaW1hbHMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSb3VuZCBwZXIgIzM5MVxyXG4gICAgICAgICAgICAgICAgaWYgKGluY3JlbWVudCAhPT0gbnVsbCAmJiBpbmNyZW1lbnQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gTnVtYmVyKGluY3JlbWVudC50b0ZpeGVkKHN0ZXBEZWNpbWFscykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkZWNyZW1lbnQgIT09IG51bGwgJiYgZGVjcmVtZW50ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudCA9IE51bWJlcihkZWNyZW1lbnQudG9GaXhlZChzdGVwRGVjaW1hbHMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2RlY3JlbWVudCwgaW5jcmVtZW50XTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGVhYmxlOiBtYXJnaW4sIGxpbWl0LCBwYWRkaW5nLCBzdGVwLCByYW5nZSwgYW5pbWF0ZSwgc25hcFxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMob3B0aW9uc1RvVXBkYXRlLCBmaXJlU2V0RXZlbnQpIHtcclxuICAgICAgICAgICAgLy8gU3BlY3RydW0gaXMgY3JlYXRlZCB1c2luZyB0aGUgcmFuZ2UsIHNuYXAsIGRpcmVjdGlvbiBhbmQgc3RlcCBvcHRpb25zLlxyXG4gICAgICAgICAgICAvLyAnc25hcCcgYW5kICdzdGVwJyBjYW4gYmUgdXBkYXRlZC5cclxuICAgICAgICAgICAgLy8gSWYgJ3NuYXAnIGFuZCAnc3RlcCcgYXJlIG5vdCBwYXNzZWQsIHRoZXkgc2hvdWxkIHJlbWFpbiB1bmNoYW5nZWQuXHJcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVHZXQoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1cGRhdGVBYmxlID0gW1wibWFyZ2luXCIsIFwibGltaXRcIiwgXCJwYWRkaW5nXCIsIFwicmFuZ2VcIiwgXCJhbmltYXRlXCIsIFwic25hcFwiLCBcInN0ZXBcIiwgXCJmb3JtYXRcIl07XHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IGNoYW5nZSBvcHRpb25zIHRoYXQgd2UncmUgYWN0dWFsbHkgcGFzc2VkIHRvIHVwZGF0ZS5cclxuICAgICAgICAgICAgdXBkYXRlQWJsZS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zVG9VcGRhdGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsT3B0aW9uc1tuYW1lXSA9IG9wdGlvbnNUb1VwZGF0ZVtuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IHRlc3RPcHRpb25zKG9yaWdpbmFsT3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAvLyBMb2FkIG5ldyBvcHRpb25zIGludG8gdGhlIHNsaWRlciBzdGF0ZVxyXG4gICAgICAgICAgICB1cGRhdGVBYmxlLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNUb1VwZGF0ZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IG5ld09wdGlvbnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgc2NvcGVfU3BlY3RydW0gPSBuZXdPcHRpb25zLnNwZWN0cnVtO1xyXG5cclxuICAgICAgICAgICAgLy8gTGltaXQsIG1hcmdpbiBhbmQgcGFkZGluZyBkZXBlbmQgb24gdGhlIHNwZWN0cnVtIGJ1dCBhcmUgc3RvcmVkIG91dHNpZGUgb2YgaXQuICgjNjc3KVxyXG4gICAgICAgICAgICBvcHRpb25zLm1hcmdpbiA9IG5ld09wdGlvbnMubWFyZ2luO1xyXG4gICAgICAgICAgICBvcHRpb25zLmxpbWl0ID0gbmV3T3B0aW9ucy5saW1pdDtcclxuICAgICAgICAgICAgb3B0aW9ucy5wYWRkaW5nID0gbmV3T3B0aW9ucy5wYWRkaW5nO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHBpcHMsIHJlbW92ZXMgZXhpc3RpbmcuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBpcHMpIHtcclxuICAgICAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUgY3VycmVudCBwb3NpdGlvbmluZyBzbyB2YWx1ZVNldCBmb3JjZXMgYW4gdXBkYXRlLlxyXG4gICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgdmFsdWVTZXQob3B0aW9uc1RvVXBkYXRlLnN0YXJ0IHx8IHYsIGZpcmVTZXRFdmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGJhc2UgZWxlbWVudCwgaW5pdGlhbGl6ZSBIVE1MIGFuZCBzZXQgY2xhc3Nlcy5cclxuICAgICAgICAvLyBBZGQgaGFuZGxlcyBhbmQgY29ubmVjdCBlbGVtZW50cy5cclxuICAgICAgICBzY29wZV9CYXNlID0gYWRkU2xpZGVyKHNjb3BlX1RhcmdldCk7XHJcbiAgICAgICAgYWRkRWxlbWVudHMob3B0aW9ucy5jb25uZWN0LCBzY29wZV9CYXNlKTtcclxuXHJcbiAgICAgICAgLy8gQXR0YWNoIHVzZXIgZXZlbnRzLlxyXG4gICAgICAgIGJpbmRTbGlkZXJFdmVudHMob3B0aW9ucy5ldmVudHMpO1xyXG5cclxuICAgICAgICAvLyBVc2UgdGhlIHB1YmxpYyB2YWx1ZSBtZXRob2QgdG8gc2V0IHRoZSBzdGFydCB2YWx1ZXMuXHJcbiAgICAgICAgdmFsdWVTZXQob3B0aW9ucy5zdGFydCk7XHJcblxyXG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcclxuICAgICAgICBzY29wZV9TZWxmID0ge1xyXG4gICAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxyXG4gICAgICAgICAgICBzdGVwczogZ2V0Q3VycmVudFN0ZXAsXHJcbiAgICAgICAgICAgIG9uOiBiaW5kRXZlbnQsXHJcbiAgICAgICAgICAgIG9mZjogcmVtb3ZlRXZlbnQsXHJcbiAgICAgICAgICAgIGdldDogdmFsdWVHZXQsXHJcbiAgICAgICAgICAgIHNldDogdmFsdWVTZXQsXHJcbiAgICAgICAgICAgIHNldEhhbmRsZTogdmFsdWVTZXRIYW5kbGUsXHJcbiAgICAgICAgICAgIHJlc2V0OiB2YWx1ZVJlc2V0LFxyXG4gICAgICAgICAgICAvLyBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcsIGRvbid0IHVzZSB0aGlzIGluIHlvdXIgYXBwbGljYXRpb24uXHJcbiAgICAgICAgICAgIF9fbW92ZUhhbmRsZXM6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgICAgIG1vdmVIYW5kbGVzKGEsIGIsIHNjb3BlX0xvY2F0aW9ucywgYyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG9yaWdpbmFsT3B0aW9ucywgLy8gSXNzdWUgIzYwMCwgIzY3OFxyXG4gICAgICAgICAgICB1cGRhdGVPcHRpb25zOiB1cGRhdGVPcHRpb25zLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHNjb3BlX1RhcmdldCwgLy8gSXNzdWUgIzU5N1xyXG4gICAgICAgICAgICByZW1vdmVQaXBzOiByZW1vdmVQaXBzLFxyXG4gICAgICAgICAgICBwaXBzOiBwaXBzIC8vIElzc3VlICM1OTRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5waXBzKSB7XHJcbiAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXBzKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXBzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhcmlhKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBzY29wZV9TZWxmO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJ1biB0aGUgc3RhbmRhcmQgaW5pdGlhbGl6ZXJcclxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemUodGFyZ2V0LCBvcmlnaW5hbE9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0Lm5vZGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogY3JlYXRlIHJlcXVpcmVzIGEgc2luZ2xlIGVsZW1lbnQsIGdvdDogXCIgKyB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cclxuICAgICAgICBpZiAodGFyZ2V0Lm5vVWlTbGlkZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBTbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGVzdCB0aGUgb3B0aW9ucyBhbmQgY3JlYXRlIHRoZSBzbGlkZXIgZW52aXJvbm1lbnQ7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0ZXN0T3B0aW9ucyhvcmlnaW5hbE9wdGlvbnMsIHRhcmdldCk7XHJcbiAgICAgICAgdmFyIGFwaSA9IHNjb3BlKHRhcmdldCwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zKTtcclxuXHJcbiAgICAgICAgdGFyZ2V0Lm5vVWlTbGlkZXIgPSBhcGk7XHJcblxyXG4gICAgICAgIHJldHVybiBhcGk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgZnVuY3Rpb24gZm9yIGZ1dHVyZSBleHBhbmRhYmlsaXR5O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvLyBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcsIGRvbid0IHVzZSB0aGlzIGluIHlvdXIgYXBwbGljYXRpb24uXHJcbiAgICAgICAgX19zcGVjdHJ1bTogU3BlY3RydW0sXHJcbiAgICAgICAgdmVyc2lvbjogVkVSU0lPTixcclxuICAgICAgICBjcmVhdGU6IGluaXRpYWxpemVcclxuICAgIH07XHJcbn0pO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxhQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nouislider/distribute/nouislider.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/js/entry.js":
/*!*************************!*\
  !*** ./src/js/entry.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.debounce */ \"./node_modules/lodash.debounce/index.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_is_mobile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/is-mobile */ \"./src/js/utils/is-mobile.js\");\n/* harmony import */ var _graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graphic */ \"./src/js/graphic.js\");\n/* global d3 */\n\n\n\nvar $body = d3.select('body');\nvar previousWidth = 0;\n\nfunction resize() {\n  // only do resize on width changes, not height\n  // (remove the conditional if you want to trigger on height change)\n  var width = $body.node().offsetWidth;\n\n  if (previousWidth !== width) {\n    previousWidth = width;\n    _graphic__WEBPACK_IMPORTED_MODULE_2__[\"default\"].resize();\n  }\n}\n\nfunction setupStickyHeader() {\n  var $header = $body.select('header');\n\n  if ($header.classed('is-sticky')) {\n    var $menu = $body.select('.header__menu');\n    var $toggle = $body.select('.header__toggle');\n    $toggle.on('click', function () {\n      var visible = $menu.classed('is-visible');\n      $menu.classed('is-visible', !visible);\n      $toggle.classed('is-visible', !visible);\n    });\n  }\n}\n\nfunction init() {\n  // add mobile class to body tag\n  $body.classed('is-mobile', _utils_is_mobile__WEBPACK_IMPORTED_MODULE_1__[\"default\"].any()); // setup resize event\n\n  window.addEventListener('resize', lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(resize, 150)); // setup sticky header menu\n\n  setupStickyHeader(); // kick off graphic code\n\n  _graphic__WEBPACK_IMPORTED_MODULE_2__[\"default\"].init();\n}\n\ninit();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvZW50cnkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvZW50cnkuanM/NzBlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgZDMgKi9cbmltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2guZGVib3VuY2UnO1xuaW1wb3J0IGlzTW9iaWxlIGZyb20gJy4vdXRpbHMvaXMtbW9iaWxlJztcbmltcG9ydCBncmFwaGljIGZyb20gJy4vZ3JhcGhpYyc7XG5cbmNvbnN0ICRib2R5ID0gZDMuc2VsZWN0KCdib2R5Jyk7XG5sZXQgcHJldmlvdXNXaWR0aCA9IDA7XG5cbmZ1bmN0aW9uIHJlc2l6ZSgpIHtcblx0Ly8gb25seSBkbyByZXNpemUgb24gd2lkdGggY2hhbmdlcywgbm90IGhlaWdodFxuXHQvLyAocmVtb3ZlIHRoZSBjb25kaXRpb25hbCBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIG9uIGhlaWdodCBjaGFuZ2UpXG5cdGNvbnN0IHdpZHRoID0gJGJvZHkubm9kZSgpLm9mZnNldFdpZHRoO1xuXHRpZiAocHJldmlvdXNXaWR0aCAhPT0gd2lkdGgpIHtcblx0XHRwcmV2aW91c1dpZHRoID0gd2lkdGg7XG5cdFx0Z3JhcGhpYy5yZXNpemUoKTtcblx0fVxufVxuXG5mdW5jdGlvbiBzZXR1cFN0aWNreUhlYWRlcigpIHtcblx0Y29uc3QgJGhlYWRlciA9ICRib2R5LnNlbGVjdCgnaGVhZGVyJyk7XG5cdGlmICgkaGVhZGVyLmNsYXNzZWQoJ2lzLXN0aWNreScpKSB7XG5cdFx0Y29uc3QgJG1lbnUgPSAkYm9keS5zZWxlY3QoJy5oZWFkZXJfX21lbnUnKTtcblx0XHRjb25zdCAkdG9nZ2xlID0gJGJvZHkuc2VsZWN0KCcuaGVhZGVyX190b2dnbGUnKTtcblx0XHQkdG9nZ2xlLm9uKCdjbGljaycsICgpID0+IHtcblx0XHRcdGNvbnN0IHZpc2libGUgPSAkbWVudS5jbGFzc2VkKCdpcy12aXNpYmxlJyk7XG5cdFx0XHQkbWVudS5jbGFzc2VkKCdpcy12aXNpYmxlJywgIXZpc2libGUpO1xuXHRcdFx0JHRvZ2dsZS5jbGFzc2VkKCdpcy12aXNpYmxlJywgIXZpc2libGUpO1xuXHRcdH0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG5cdC8vIGFkZCBtb2JpbGUgY2xhc3MgdG8gYm9keSB0YWdcblx0JGJvZHkuY2xhc3NlZCgnaXMtbW9iaWxlJywgaXNNb2JpbGUuYW55KCkpO1xuXHQvLyBzZXR1cCByZXNpemUgZXZlbnRcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlYm91bmNlKHJlc2l6ZSwgMTUwKSk7XG5cdC8vIHNldHVwIHN0aWNreSBoZWFkZXIgbWVudVxuXHRzZXR1cFN0aWNreUhlYWRlcigpO1xuXHQvLyBraWNrIG9mZiBncmFwaGljIGNvZGVcblx0Z3JhcGhpYy5pbml0KCk7XG59XG5cbmluaXQoKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/entry.js\n");

/***/ }),

/***/ "./src/js/graphic.js":
/*!***************************!*\
  !*** ./src/js/graphic.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var nouislider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nouislider */ \"./node_modules/nouislider/distribute/nouislider.js\");\n/* harmony import */ var nouislider__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nouislider__WEBPACK_IMPORTED_MODULE_0__);\n/* global d3 */\n //import 'nouislider/distribute/nouislider.css';\n\nvar countStreak = 1;\nvar dragging = false;\nvar svg = null;\nvar fixedFace = null;\nvar faces = null;\nvar face = null;\nvar lines = null;\nvar faceAdjust = 0;\nvar globalGain = null;\nvar source2 = null;\nvar viewportWidth;\nvar viewportHeight;\nviewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\nviewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\nvar margin = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0\n},\n    width = Math.min(1100, viewportWidth) - margin.left - margin.right,\n    height = 712 - 112 - margin.top - margin.bottom;\nvar faceSize = Math.min((width - 40) / 5, 110);\nd3.select(\".ranking\").style(\"margin-left\", function () {\n  if (viewportWidth > 420) {\n    return faceSize / 2 + \"px\";\n  }\n\n  return null;\n});\n\nif (viewportWidth < 700) {\n  width = Math.floor(viewportWidth, 550);\n}\n\nif (viewportWidth < 421) {\n  width = viewportWidth - 0;\n  height = 550; //faceSize = Math.min(faceSize,(width)/5);\n} // if(viewportHeight - 112 < 600){\n// \theight = viewportHeight - 112;\n// }\n\n\nd3.select(\".chart\").style(\"width\", width + \"px\").style(\"height\", height + \"px\");\n\nfunction resize() {}\n\nfunction init() {\n  newCode();\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  resize: resize\n});\n\nfunction newCode() {\n  var cumulativeStats = d3.select(\".cumulative-container\");\n  var n = 9,\n      duration = 1500,\n      now = new Date(Date.now() - duration);\n  var searchData;\n  var count = [];\n  var started = false;\n  var axis;\n  var chartData;\n  var nestedDatesTwo;\n  var imageData;\n  var shiftDuration = 3000;\n  var tickDelay;\n  var playLength = 0;\n  var startTime = 0;\n  var colorOne = \"#FF2F28\";\n  var colorTwo = \"#FF2F28\";\n  var context;\n  var bufferLoader;\n  var scratch;\n  var hit;\n  var source;\n  var lastSource;\n  var currentYear = 2019;\n  var windowFocus = 0;\n  var hidden;\n  var textAdjust = 6;\n  var textColor = \"#797979\";\n  var pathColor = \"#FFFFFF\";\n  var playing = false;\n  var muted = false;\n  var hidden;\n  var mobile = false;\n  var parseDate = d3.time.format(\"%Y-%m-%d\").parse;\n  var unParse = d3.time.format(\"%Y-%m-%d\");\n  var niceParse = d3.time.format(\"%b, '%y\");\n  var niceParseTwo = d3.time.format(\"%B %d, '%y\");\n  var niceParseThree = d3.time.format(\"%b %e, '%y\");\n\n  if (viewportWidth < 700) {\n    niceParseThree = d3.time.format(\"%b<br>%Y\");\n  }\n\n  var numParse = d3.time.format(\"%Y%m%d\");\n  var numParseDate = d3.time.format(\"%Y%m%d\").parse;\n  var sideBarParse = d3.time.format(\"%b '%y\");\n  var yearParse = d3.time.format(\"%Y\");\n  var uniqueRowsCsv = \"assets/data/my_unique_rows.csv\";\n  var startString = \"2019-01-01\";\n\n  if (/Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n    mobile = true;\n  }\n\n  var start = new Date(parseDate(startString)); //interate through 17 weeks by adding 7 to the start day\n\n  var dates = [start];\n  var i;\n\n  for (i = 0; i < 52; i++) {\n    var length = dates.length;\n    var date = d3.time.day.offset(dates[length - 1], 7);\n    dates.push(date);\n  }\n\n  var dateAhead = unParse(d3.time.day.offset(dates[0], 7));\n  var twoDatesAhead = unParse(d3.time.day.offset(dates[0], 14));\n  var currentDate = unParse(dates[0]);\n  $(document).ready(function () {\n    d3.csv(\"assets/data/my_all_rows.csv\", function (error, data) {\n      d3.csv(uniqueRowsCsv, function (error, songsUnique) {\n        if (/Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {}\n\n        var songsUniqueMap = d3.map(songsUnique, function (d) {\n          return d.key;\n        });\n        var x = d3.time.scale().domain([dates[0], dates[dates.length - 1]]).range([height, 0]);\n        var y = d3.scale.linear().domain([6, 1]).range([width, 0]);\n        var line = d3.svg.line().interpolate(\"linear\").x(function (d, i) {\n          return y(+d.rank);\n        }).y(function (d, i) {\n          return x(d.chart_date);\n        });\n        data.forEach(function (d) {\n          d.chart_date_num = d.chart_date;\n          d.chart_date = parseDate(d.chart_date); // d.id = d.title + \" by \" + d.artist;\n\n          d.id = d.track_id;\n\n          if (songsUniqueMap.has(d.id)) {} else {// console.log(d.id);\n          }\n\n          d.track_info = songsUniqueMap.get(d.id);\n        });\n        var artistData = d3.nest().key(function (d) {\n          return d.id;\n        }).entries(data);\n        var testDates = d3.nest().key(function (d) {\n          return d.chart_date_num.slice(0, 7);\n        }).entries(data.filter(function (d) {\n          return +d.rank < 6;\n        })); //chartdata is nested by artist\n\n        chartData = d3.nest().key(function (d) {\n          return d.id;\n        }).entries(data); //nestedDates is nested by week\n\n        var nestedDates = d3.nest().key(function (d) {\n          return d.chart_date_num;\n        }).entries(data);\n        var weeksForDateLines = nestedDates.map(function (d) {\n          return +d.key.replace(\"-\", \"\").replace(\"-\", \"\");\n        }).filter(function (d, i) {\n          return i % 4 == 0;\n        });\n\n        for (var i = 0; i < chartData.length; i++) {\n          //add peak to the top-level node\n          //rank by week\n          var dateRank = {};\n\n          for (var j = 0; j < chartData[i].values.length; j++) {\n            var date = chartData[i].values[j].chart_date_num;\n            var rank = chartData[i].values[j].rank;\n\n            if (rank < 6) {\n              dateRank[date] = rank;\n            }\n          }\n\n          chartData[i].nestedDateArray = dateRank;\n        }\n\n        var chartMap = d3.map(chartData, function (d) {\n          return d.key;\n        });\n\n        for (var date in testDates) {\n          for (var track in testDates[date].values) {\n            var item = chartMap.get(testDates[date].values[track].id);\n            testDates[date].values[track].nestedDateArray = item.nestedDateArray;\n            testDates[date].values[track].key = item.key;\n            testDates[date].values[track].values = item.values.filter(function (d) {\n              return +d.rank < 6;\n            });\n          }\n        }\n\n        testDates = d3.map(testDates, function (d) {\n          return d.key;\n        });\n        console.log(unParse(dates[0]).slice(0, 7));\n        var filteredData = testDates.get(unParse(dates[0]).slice(0, 7)).values;\n        var nextMonth = unParse(d3.time.month.offset(dates[0], 1)).slice(0, 7);\n        var filteredDataNext = testDates.get(unParse(d3.time.month.offset(dates[0], 1)).slice(0, 7)).values;\n        filteredData = _.unionBy(filteredData, filteredDataNext); //nestedDatesTwo is for the audio so that it knows what it will play each week\n\n        var nestedDatesTwo = {}; //sorts everything for getting the top ranked track that goes into nestedDatesTwo\n\n        for (var i in nestedDates) {\n          nestedDates[i].values.sort(function (a, b) {\n            return a.rank - b.rank;\n          });\n        } //nestedDates is the data nested by week\n\n\n        for (var i in nestedDates) {\n          var date = nestedDates[i].key;\n          nestedDatesTwo[date] = {\n            track: nestedDates[i][\"values\"][0][\"id\"],\n            preview: nestedDates[i][\"values\"][0][\"track_info\"][\"song_url\"],\n            artist: nestedDates[i][\"values\"][0][\"track_info\"][\"artist\"],\n            title: nestedDates[i][\"values\"][0][\"track_info\"][\"title\"]\n          };\n        } //week map for getting top ranked songs\n\n\n        var rankingMap = d3.map(nestedDates, function (d) {\n          return d.key;\n        });\n\n        function changeYear(changedYear) {\n          var duration1 = 800;\n          var duration2 = 400;\n          var filteredDataFirst = testDates.get(unParse(dates[0]).slice(0, 7)).values;\n\n          if (dates[0] <= new Date(parseDate(\"2019-01-01\"))) {\n            var filteredDataNext = testDates.get(unParse(d3.time.month.offset(dates[0], 1)).slice(0, 7)).values;\n            var filteredDataThird = testDates.get(unParse(d3.time.month.offset(dates[0], 2)).slice(0, 7)).values;\n            var filteredDataFourth = testDates.get(unParse(d3.time.month.offset(dates[0], 2)).slice(0, 7)).values;\n            filteredData = _.unionBy(filteredDataFirst, filteredDataNext, filteredDataThird, filteredDataFourth, 'key');\n          } else {\n            filteredData = filteredDataFirst;\n          }\n\n          d3.selectAll(\"#glow\").remove();\n          path = path.data(filteredData, function (d) {\n            return d.key;\n          });\n          lines = lines.data(dates, function (d) {\n            return d;\n          });\n          face = face.data(filteredData, function (d) {\n            return d.key;\n          });\n          path.enter().append(\"path\").attr(\"class\", \"line\").attr(\"d\", function (d) {\n            return line(d.values); //return lineFunction(d.values);\n\n            return line(getPathWeeks(d));\n          }).attr(\"transform\", \"translate(\" + x(dates[dates.length - 1]) + \")\").style(\"stroke\", function (d) {\n            var data = d;\n            return pathStroke(data);\n          }) // .style(\"display\",function(d){\n          // \treturn faceDisplay(d)\n          // })\n          .style(\"opacity\", function (d) {\n            return pathOpacity(d);\n          });\n          lines.enter().append(\"div\").attr(\"class\", \"date-line\").style(\"top\", function (d) {\n            return x(d) + \"px\";\n          }).style(\"display\", function (d) {\n            var date = +unParse(d).replace(\"-\", \"\").replace(\"-\", \"\");\n\n            if (weeksForDateLines.indexOf(date) > -1) {\n              return \"block\";\n            }\n\n            ;\n            return null;\n          }).append(\"p\").html(function (d) {\n            return niceParseThree(d);\n          });\n          face.enter().append(\"div\").attr(\"class\", \"face tk-futura-pt\") // .style(\"display\",function(d){\n          // \treturn faceDisplay(d)\n          // })\n          .style(\"background-image\", function (d) {\n            if (changedYear == \"scroll\") {\n              return null;\n            }\n\n            if (d[\"track_info\"][\"artist_url\"] == \"NULL\") {\n              return null;\n            }\n\n            if (d[\"track_info\"][\"artist_url\"] == \"manual\") {\n              var hostUrl = document.location.origin;\n              var pathUrl = document.location.pathname.replace(\"index.html\", \"\");\n              var idSong = nestedDatesTwo[unParse(d3.time.day.offset(dates[dates.length - 1], 7))][\"track\"];\n              nextSong = hostUrl + pathUrl + \"url/\" + idSong + \".m4a\";\n              return \"url(\" + nextSong + \")\";\n            }\n\n            return \"url(https://i.scdn.co/image/\" + d[\"track_info\"][\"artist_url\"] + \")\";\n          }).style(\"top\", function (d) {\n            return faceTop(d);\n          }).style(\"left\", function (d) {\n            var data = d;\n            return faceLeft(data);\n          }).append(\"p\").append(\"span\").text(function (d) {\n            var title = d.track_info.title;\n\n            if (title.length > 20) {\n              return title.slice(0, 17) + \"...\";\n            }\n\n            return title;\n          });\n          path.exit().remove();\n          face.exit().remove();\n          lines.exit().remove();\n        }\n\n        var currentDate = unParse(dates[0]);\n        var dateAhead = unParse(d3.time.day.offset(dates[0], 7));\n        var twoDatesAhead = unParse(d3.time.day.offset(dates[0], 14));\n        var opacityScale = d3.scale.linear().domain([5, 3, 1]).range([.01, .25, 1]);\n        var timelineScale = d3.scale.linear().domain([0, 354]).range([23, 375]);\n\n        function topArtist(d) {\n          return nestedDatesTwo[currentDate].title + \"â€”\" + nestedDatesTwo[currentDate].artist;\n        }\n\n        function faceBackground(d) {\n          var rank = d.nestedDateArray[dateAhead];\n\n          if (rank == 1) {\n            return colorTwo;\n          } else {\n            if (currentDate in d.nestedDateArray) {\n              var rank = d.nestedDateArray[currentDate];\n              return d3.interpolate(\"#fff\", \"#000\")(opacityScale(rank));\n            } else {\n              return d3.interpolate(\"#fff\", \"#000\")(opacityScale(.01));\n            }\n          }\n        }\n\n        ;\n        svg = d3.select(\".chart\").append(\"svg\").attr(\"width\", width + margin.left + margin.right).attr(\"height\", height + margin.top + margin.bottom).style(\"width\", width + margin.left + margin.right + \"px\").style(\"height\", height + margin.top + margin.bottom + \"px\").attr(\"class\", \"lines-container\"); // var colorScheme = d3.schemeYlGnBu[5];\n        //colorScheme = d3.schemeGnBu[5];\n\n        var colorScheme = [\"#49217a\", \"#852c82\", \"#b52f59\", \"#f5af71\", \"#fcfbbc\"].reverse(); //colorScheme = [\"yellow\",\"orange\",\"red\",\"green\",\"steelblue\"]//.reverse()\n\n        svg.append(\"linearGradient\").attr(\"id\", \"temperature-gradient\").attr(\"gradientUnits\", \"userSpaceOnUse\").attr(\"x1\", y(5)).attr(\"y1\", 0).attr(\"x2\", y(1)).attr(\"y2\", 0).selectAll(\"stop\").data(colorScheme.reverse().map(function (d, i) {\n          return {\n            offset: i * 25 + \"%\",\n            color: d\n          };\n        }) // \t[\n        //   {offset: \"0%\", color: \"steelblue\"},\n        // \t{offset: \"20%\", color: \"green\"},\n        // \t{offset: \"40%\", color: \"yellow\"},\n        //   {offset: \"60%\", color: \"orange\"},\n        //   {offset: \"100%\", color: \"#FF2F28\"}\n        // ]\n        ).enter().append(\"stop\").attr(\"offset\", function (d) {\n          return d.offset;\n        }).attr(\"stop-color\", function (d) {\n          return d.color;\n        });\n        svg.append(\"defs\").html('<filter id=\"outline\"> <feMorphology in=\"SourceAlpha\" result=\"DILATED\" operator=\"dilate\" radius=\"3\"></feMorphology> <feFlood flood-color=\"#111\" flood-opacity=\"1\" result=\"PINK\"></feFlood> <feComposite in=\"PINK\" in2=\"DILATED\" operator=\"in\" result=\"OUTLINE\"></feComposite> <feMerge> <feMergeNode in=\"OUTLINE\"></feMergeNode> <feMergeNode in=\"SourceGraphic\"></feMergeNode> </feMerge> </filter>');\n        svg.append(\"defs\").append(\"clipPath\").attr(\"id\", \"clip\").append(\"rect\").attr(\"x\", 0).attr(\"y\", -500).attr(\"width\", width).attr(\"height\", function (d) {\n          if (viewportWidth < 326) {\n            return 500 + height - faceSize * .9;\n          }\n\n          if (viewportWidth < 376) {\n            return 500 + height - faceSize * .8;\n          }\n\n          if (viewportWidth < 411) {\n            return 500 + height - faceSize * .75;\n          }\n\n          if (viewportWidth < 421) {\n            return 500 + height - faceSize * .7;\n          }\n\n          return 500 + height - faceSize * .6;\n        });\n        svg.append(\"defs\").append(\"clipPath\").attr(\"id\", \"xaxisclip\").append(\"rect\").attr(\"width\", width + 20).attr(\"height\", height + margin.bottom * 2 + margin.top);\n        svg.append(\"defs\").append(\"filter\").attr(\"id\", 'blurred') //.attr({\"width\":\"200%\", \"height\":\"200%\"})\n        .append(\"feGaussianBlur\").attr(\"stdDeviation\", 8);\n        svg.append(\"defs\").append(\"filter\").attr(\"id\", 'blurredTwo') //.attr({\"width\":\"200%\", \"height\":\"200%\"})\n        .append(\"feGaussianBlur\").attr(\"stdDeviation\", 2); // build paths\n\n        var pathSvg = svg.append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\").attr(\"clip-path\", \"url(#clip)\").attr(\"class\", \"path-container\");\n\n        function getPathWeeks(d) {\n          var weeks = d.values.map(function (d) {\n            return d;\n          });\n          var weekArray = [];\n          var startOfWeek = d.values[0];\n          var end = d3.time.day.offset(startOfWeek.chart_date, 3);\n          var range = d3.time.day.range(startOfWeek.chart_date, end);\n\n          for (var item in range) {\n            weeks.push({\n              rank: startOfWeek.rank,\n              chart_date: range[item]\n            });\n          }\n\n          var endOfWeek = d.values[d.values.length - 1];\n          var endTwo = d3.time.day.offset(endOfWeek.chart_date, 3);\n          var rangeTwo = d3.time.day.range(endOfWeek.chart_date, endTwo);\n\n          for (var item in rangeTwo) {\n            weeks.push({\n              rank: endOfWeek.rank,\n              chart_date: rangeTwo[item]\n            });\n          }\n\n          weeks = weeks.sort(function (a, b) {\n            return a.chart_date - b.chart_date;\n          });\n          return weeks;\n        }\n\n        var lineFunction = d3.svg.line().interpolate(function (points) {\n          for (var point in points) {\n            points[point] = project(matrix, points[point]);\n          }\n\n          return points.join(\"L\");\n        }).x(function (d, i) {\n          return y(+d.rank);\n        }).y(function (d, i) {\n          return x(d.chart_date); //this x is now translating between 0 and height with date on y-axis\n        });\n        var path = pathSvg.selectAll('path').data(filteredData, function (d) {\n          return d.key;\n        }).enter().append(\"path\").attr(\"class\", \"line\").attr(\"d\", function (d) {\n          return line(d.values); //return lineFunction(d.values);\n\n          return line(getPathWeeks(d));\n        }).style(\"stroke\", function (d) {\n          //var data = d;\n          //return \"red\"\n          return pathStroke(d);\n        }).style(\"opacity\", function (d) {\n          var data = d;\n          return pathOpacity(data);\n        });\n\n        function clone(selector) {\n          var node = selector.node();\n          return d3.select(node.parentNode.insertBefore(node.cloneNode(true), node));\n        }\n\n        path.each(function (d, i) {\n          if (dateAhead in d.nestedDateArray) {\n            var rank = d.nestedDateArray[dateAhead];\n\n            if (rank == 1) {\n              clone(d3.select(this)).attr('filter', 'url(#blurred)').style(\"stroke-width\", '9px').style(\"stroke\", colorScheme[0]).style(\"opacity\", .8).attr(\"id\", \"glow\");\n            }\n          }\n        });\n        var bottomFrame = d3.select(\".bottom-frame\").style(\"width\", width + \"px\") //.style(\"width\",(620)+\"px\")\n        .style(\"height\", height + \"px\");\n        bottomFrame.select(\".ranking\").selectAll(\".rank-num\").style(\"color\", function (d, i) {\n          if (i == 4) {\n            return \"#71598e\";\n          }\n\n          return colorScheme[colorScheme.length - i - 1];\n        }); //guitar hero outline\n\n        var guitarHeroOutline = d3.select(\".guitar-frame\").style(\"width\", width + \"px\") //.style(\"width\",(620)+\"px\")\n        .style(\"height\", height + \"px\").append(\"svg\"); // guitarHeroOutline.append(\"rect\")\n        // \t.attr(\"x\",\"0\")\n        // \t.attr(\"y\",height-30-1)\n        // \t.attr(\"height\",30)\n        // \t.attr(\"width\",\"100%\")\n        // \t;\n\n        svg.append(\"linearGradient\").attr(\"id\", \"white-fade\").attr(\"gradientUnits\", \"userSpaceOnUse\").attr(\"x1\", 0).attr(\"y1\", -400).attr(\"x2\", \"20%\").attr(\"y2\", height - 30).selectAll(\"stop\").data([{\n          offset: 0 + \"%\",\n          color: \"rgba(255,255,255,0.0)\"\n        }, {\n          offset: 100 + \"%\",\n          color: \"rgba(255,255,255,1)\"\n        }]).enter().append(\"stop\").attr(\"offset\", function (d) {\n          return d.offset;\n        }).attr(\"stop-color\", function (d) {\n          return d.color;\n        });\n        svg.append(\"linearGradient\").attr(\"id\", \"yellow-fade\").attr(\"gradientUnits\", \"userSpaceOnUse\").attr(\"x1\", 0).attr(\"y1\", -400).attr(\"x2\", \"20%\").attr(\"y2\", height - 30).selectAll(\"stop\").data([{\n          offset: 0 + \"%\",\n          color: \"rgb(255,193,7)\",\n          opacity: 0\n        }, {\n          offset: 100 + \"%\",\n          color: \"rgb(255,193,7)\",\n          opacity: .2\n        }]).enter().append(\"stop\").attr(\"offset\", function (d) {\n          return d.offset;\n        }).attr(\"stop-color\", function (d) {\n          return d.color;\n        }).attr(\"stop-opacity\", function (d) {\n          return d.opacity;\n        });\n        guitarHeroOutline.append(\"rect\").attr(\"x\", 0).attr(\"width\", \"20%\").attr(\"y\", -400).attr(\"height\", function (d) {\n          return 400 + height - 30;\n        }).style(\"fill\", \"url(#yellow-fade)\");\n        guitarHeroOutline.selectAll(\"line\").data(d3.range(6)).enter().append(\"line\").attr(\"x1\", function (d, i) {\n          if (i == 0) {\n            return 1;\n          }\n\n          if (i == 5) {\n            return \"100%\";\n          }\n\n          return i * 20 + \"%\";\n        }).attr(\"x2\", function (d, i) {\n          if (i == 0) {\n            return 1;\n          }\n\n          if (i == 5) {\n            return \"100%\";\n          }\n\n          return i * 20 + \"%\";\n        }).attr(\"y1\", function (d) {\n          return -400;\n        }).attr(\"y2\", function (d) {\n          return height - 30 - 1;\n        }).style(\"stroke\", \"url(#white-fade)\");\n        ; // build faces\n\n        faces = d3.select(\".chart\").append(\"div\").attr(\"id\", \"faces\");\n        face = faces.append(\"div\").attr(\"class\", \"face-container\").selectAll(\".face\").data(filteredData, function (d) {\n          return d.key;\n        }).enter().append(\"div\").attr(\"class\", \"face tk-futura-pt\").style(\"background-image\", function (d) {\n          var data = d;\n          return faceBackgroundImage(data);\n        }).style(\"border-color\", function (d) {\n          return faceBorder(d);\n        }).style(\"opacity\", function (d) {\n          var data = d;\n          return faceOpacity(data);\n        }).style(\"top\", function (d) {\n          return faceTop(d);\n        }).style(\"left\", function (d) {\n          var data = d;\n          return faceLeft(data);\n        }).style(\"width\", faceSize + \"px\").style(\"height\", faceSize + \"px\").on(\"mouseover\", function (d) {\n          var data = d;\n          var element = d3.select(this);\n          faceMouseOver(data, element);\n        });\n        face.append(\"p\").append(\"span\").text(function (d) {\n          var title = d.track_info.title;\n\n          if (title.length > 20) {\n            return title.slice(0, 17) + \"...\";\n          }\n\n          return title;\n        });\n        lines = faces.append(\"div\").attr(\"class\", \"date-lines-container\").selectAll(\"div\").data(dates).enter().append(\"div\").attr(\"class\", \"date-line\").style(\"top\", function (d) {\n          return x(d) + \"px\";\n        }).style(\"display\", function (d) {\n          var date = +unParse(d).replace(\"-\", \"\").replace(\"-\", \"\");\n\n          if (weeksForDateLines.indexOf(date) > -1) {\n            return \"block\";\n          }\n\n          ;\n          return null;\n        });\n        lines.append(\"p\").html(function (d) {\n          return niceParseThree(d);\n        }); // var chartContainer = d3.select(\".chart\")\n        //   .on(\"mouseover\", function(){\n        // \t\tconsole.log('mouseover')\n        //     if(!playing){\n        //       pausePlay.style(\"opacity\",1);\n        //     }\n        //   })\n        //   .on(\"mouseout\",function(){\n        //     if(!playing){\n        //       pausePlay.style(\"opacity\",0);\n        //     }\n        //   })\n        //   ;\n\n        var textLeftOffset = 240;\n        var svgTwo = d3.select(\".chart\").append(\"svg\").attr(\"class\", \"text-container\").append(\"g\").attr(\"clip-path\", \"url(#clip)\").attr(\"transform\", function () {\n          var marginTop = margin.top;\n          return \"translate(\" + textLeftOffset + \",\" + marginTop + \")\";\n        });\n        var clickPlayTip = d3.select(\".click-to-play\");\n        var trackLegend = d3.select(\".track-legend\").selectAll(\"div\");\n        var interpolateOne = d3.interpolate(\"#0C0C0C\", \"#FFFFFF\");\n\n        function faceTop(d) {\n          if (dateAhead in d.nestedDateArray) {\n            return x(dates[1]) + \"px\";\n          } else {\n            if (currentDate in d.nestedDateArray || unParse(d3.time.day.offset(dates[0], -7)) in d.nestedDateArray || unParse(d3.time.day.offset(dates[0], -14)) in d.nestedDateArray) {\n              return x(dates[0]) + \"px\";\n            }\n\n            var chart_date = d.values[d.values.length - 1].chart_date;\n            return x(chart_date) + \"px\"; //this x is now translating between 0 and height with date on y-axis\n          }\n        }\n\n        function faceLeft(d) {\n          if (dateAhead in d.nestedDateArray) {\n            var rank = d.nestedDateArray[dateAhead];\n            return y(rank) + faceAdjust + margin.top + \"px\";\n          } else {\n            if (unParse(d3.time.day.offset(dates[0], -7)) in d.nestedDateArray) {\n              var rank = d.nestedDateArray[currentDate];\n              return y(rank) + faceAdjust + margin.top + \"px\";\n            }\n\n            var rank = d.values[d.values.length - 1].rank;\n            return y(rank) + faceAdjust + margin.top + \"px\";\n          }\n        }\n\n        function faceTopPosition(d) {\n          if (dateAhead in d.nestedDateArray) {\n            var rank = d.nestedDateArray[dateAhead];\n            return y(rank) + faceAdjust + margin.top + \"px\";\n          } else {\n            return width + 100 + \"px\";\n          }\n        }\n\n        ;\n\n        function faceBackgroundImage(d) {\n          if (d[\"track_info\"][\"artist_url\"] == \"NULL\") {\n            return null;\n          }\n\n          return \"url(https://i.scdn.co/image/\" + d[\"track_info\"][\"artist_url\"] + \")\";\n        }\n\n        function faceOpacity(d) {\n          if (dateAhead in d.nestedDateArray) {\n            return null;\n          } else {\n            if (unParse(d3.time.day.offset(dates[0], -7)) in d.nestedDateArray || unParse(d3.time.day.offset(dates[0], -14)) in d.nestedDateArray) {\n              return 0;\n            }\n\n            if (unParse(dates[2]) in d.nestedDateArray || unParse(dates[3]) in d.nestedDateArray || unParse(dates[4]) in d.nestedDateArray) {\n              return .8;\n            }\n\n            if (dates[0] > d3.max(d.values, function (d) {\n              return d.chart_date;\n            })) {\n              return 0;\n            } else {\n              return .1;\n            }\n          }\n        }\n\n        function faceDisplay(d) {\n          if (dateAhead in d.nestedDateArray) {\n            return null;\n          } else {\n            if (unParse(d3.time.day.offset(dates[0], -7)) in d.nestedDateArray || unParse(d3.time.day.offset(dates[0], -14)) in d.nestedDateArray) {\n              return null;\n            }\n\n            if (unParse(dates[2]) in d.nestedDateArray || unParse(dates[3]) in d.nestedDateArray || unParse(dates[4]) in d.nestedDateArray) {\n              return null;\n            }\n\n            if (dates[0] > d3.max(d.values, function (d) {\n              return d.chart_date;\n            })) {\n              return \"none\";\n            } else {\n              return \"none\";\n            }\n          }\n        }\n\n        var bioName = d3.select(\".bio-name\");\n        var bioText = d3.select(\".bio-info\");\n        var pausePlay = d3.selectAll(\".paused-play-button\").on(\"click\", function () {\n          d3.select(this).style(\"pointer-events\", \"none\");\n          d3.select(\".pause-section\").style(\"display\", \"initial\");\n          returnPath();\n        });\n        var searchArray = [];\n        var searchResults = d3.select(\".search-results-new\");\n        var searchResultMouseOver = false;\n\n        function artistClean(artist) {\n          return artist.split(\" Featuring\")[0];\n        }\n\n        var sampleRotate; // window.addEventListener(\"wheel\", event => {\n        //   const delta = Math.sign(event.deltaY);\n        // \tif(Math.round(event.timeStamp) % 2 == 0){\n        // \t\ttestScroll(delta);\n        // \t}\n        // });\n\n        var timeoutScroll = null;\n\n        function testScroll(direction) {\n          if (playing) {\n            moveChart(\"stop\");\n          }\n\n          window.clearTimeout(timeoutScroll);\n          timeoutScroll = window.setTimeout(function (d) {\n            face.style(\"background-image\", function (d) {\n              if (d[\"track_info\"][\"artist_url\"] == \"NULL\") {\n                return null;\n              }\n\n              if (d[\"track_info\"][\"artist_url\"] == \"manual\") {\n                var hostUrl = document.location.origin;\n                var pathUrl = document.location.pathname.replace(\"index.html\", \"\");\n                var idSong = nestedDatesTwo[unParse(d3.time.day.offset(dates[dates.length - 1], 7))][\"track\"];\n                nextSong = hostUrl + pathUrl + \"url/\" + idSong + \".m4a\";\n                return \"url(\" + nextSong + \")\";\n              }\n\n              return \"url(https://i.scdn.co/image/\" + d[\"track_info\"][\"artist_url\"] + \")\";\n            });\n            moveChart(dates[0].getTime());\n          }, 1000);\n\n          for (var i in dates) {\n            dates[i] = d3.time.day.offset(dates[i], 7 * direction);\n          }\n\n          ;\n          currentDate = unParse(dates[0]);\n          dateAhead = unParse(d3.time.day.offset(dates[0], 7));\n          twoDatesAhead = unParse(d3.time.day.offset(dates[0], 14));\n          changeYear(\"scroll\");\n          x.domain([dates[0], dates[dates.length - 1]]);\n          face.style(\"opacity\", function (d) {\n            return faceOpacity(d);\n          }).style(\"width\", faceSize + \"px\").style(\"height\", faceSize + \"px\").style(\"border-color\", function (d) {\n            return faceBorder(d);\n          }).style(\"top\", function (d) {\n            return faceTop(d);\n          }).style(\"left\", function (d) {\n            var data = d;\n            return faceLeft(data);\n          });\n          lines.style(\"top\", function (d) {\n            return x(d) + \"px\";\n          }).style(\"opacity\", function (d, i) {\n            if (i == 0) {\n              return 0;\n            }\n          });\n          d3.select(\".date-lines-container\").style(\"transform\", \"translate(0px,\" + x(d3.time.day.offset(dates[dates.length - 1], 7)) + \"px)\");\n          path.attr(\"d\", function (d) {\n            //return lineFunction(d.values);\n            return line(d.values);\n            return line(getPathWeeks(d));\n          }).style(\"stroke\", function (d) {\n            var data = d;\n            return pathStroke(data);\n          }).style(\"opacity\", function (d) {\n            var data = d;\n            return pathOpacity(data);\n          }).style(\"stroke-width\", function (d) {\n            var data = d;\n            return pathStrokeWidth(data);\n          }).each(function (d, i) {\n            if (dateAhead in d.nestedDateArray) {\n              var rank = d.nestedDateArray[dateAhead];\n\n              if (rank == 1) {\n                clone(d3.select(this)).attr('filter', 'url(#blurred)').style(\"stroke\", colorScheme[0]).attr(\"id\", \"glow\").style(\"stroke-width\", '10px').style(\"opacity\", 1);\n              } else {\n                clone(d3.select(this)) //.attr('filter', 'url(#blurredTwo)')\n                .style(\"stroke\", \"#2a292f\").attr(\"id\", \"glow\").style(\"stroke-width\", '6px');\n              }\n            }\n          });\n          d3.select(\".path-container\").selectAll(\"path\").attr(\"transform\", \"translate(0,0)\"); //.attr(\"transform\", \"translate(0,\"+ x(d3.time.day.offset(dates[dates.length-1], 7)) + \")\")\n          // d3.select(\".path-container\").selectAll(\"path\")\n          // \t.transition()\n          // \t.attr(\"transform\", \"translate(0,0)\")\n          // \t;\n        }\n\n        ; // d3.select(\"body\").on(\"click\",function(d){\n        // \tconsole.log(\"here\");\n        // \ttestScroll(\"hi\");\n        // })\n\n        function moveChart(d) {\n          if (playing == true) {\n            transition = transition.transition(0).duration(0);\n            globalGain.gain.cancelScheduledValues(context.currentTime);\n            globalGain.gain.setValueAtTime(0, context.currentTime); // if ( source ) {\n            // \tif(!source.stop){\n            // \t\tsource.stop = source.noteOff;\n            // \t}\n            // }\n            //\n            // if ( lastSource ) {\n            // \tif(!lastSource.stop){\n            // \t\tlastSource.stop = lastSource.noteOff;\n            // \t}\n            // \tlastSource.stop(0);\n            // }\n          }\n\n          if (d == \"stop\") {\n            playing = false;\n            d3.select(\".play-button\").style(\"display\", \"block\");\n            d3.select(\".pause-button\").style(\"display\", \"none\"); // lines.transition().duration(0);\n            // face.transition().duration(0);\n            // path.transition().duration(0);\n          }\n\n          if (d != \"stop\") {\n            playing = true;\n            d3.select(\".play-button\").style(\"display\", null);\n            d3.select(\".pause-button\").style(\"display\", null);\n            var dateSelected = new Date(+d);\n            var goal = numParse(dateSelected);\n            var closest = weeksForDateLines.reduce(function (prev, curr) {\n              return Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev;\n            }); //interate through 17 weeks by adding 7 to the start day\n\n            dates = [numParseDate(JSON.stringify(closest))];\n            var i;\n\n            for (i = 0; i < n; i++) {\n              var length = dates.length;\n              var date = d3.time.day.offset(dates[length - 1], 7);\n              dates.push(date);\n            }\n\n            var dateAhead = unParse(d3.time.day.offset(dates[0], 7));\n\n            var _twoDatesAhead = unParse(d3.time.day.offset(dates[0], 14));\n\n            var currentDate = unParse(dates[0]);\n            x.domain([dates[0], dates[dates.length - 1]]);\n            window.clearTimeout(tickDelay);\n            tickDelay = setTimeout(function () {\n              if (1 < 2) {\n                for (i = 1; i < 20; i++) {\n                  var timeOne = dates[1];\n                  var timeTwo = d3.time.day.offset(dates[1], 7 * i);\n\n                  if (nestedDatesTwo[unParse(timeOne)][\"track\"] != nestedDatesTwo[unParse(timeTwo)][\"track\"]) {\n                    playLength = Math.max((i - 1) * shiftDuration, shiftDuration);\n                    break;\n                  }\n                }\n\n                var currTime = context.currentTime;\n                var currSong;\n                var previewItemId = nestedDatesTwo[unParse(d3.time.day.offset(dates[1], 0))][\"preview\"];\n                console.log(previewItemId);\n                currSong = \"https://p.scdn.co/mp3-preview/\" + previewItemId;\n                startTime = currTime + 1;\n                loadSounds(currSong, playLength, startTime, \"now\");\n              }\n\n              transition = d3.select({}).transition().duration(shiftDuration).ease(\"linear\");\n              tick();\n            }, 100);\n          }\n        }\n\n        ;\n\n        function textFill(d) {\n          var rank = d.nestedDateArray[currentDate];\n\n          if (rank == 1) {\n            return colorTwo;\n          } else {\n            return textColor;\n          }\n        }\n\n        function pathStroke(d) {\n          if (dateAhead in d.nestedDateArray) {\n            var rank = d.nestedDateArray[dateAhead];\n            return \"url(#temperature-gradient)\";\n\n            if (rank == 1) {\n              return \"red\";\n            } else {\n              return \"url(#temperature-gradient)\";\n            } // if(rank==2){\n            // \treturn \"blue\";\n            // }\n            // if(rank==3){\n            // \treturn \"green\";\n            // }\n            // if(rank==4){\n            // \treturn \"purple\";\n            // }\n            // return \"yellow\";\n\n          }\n\n          return \"none\"; // var rank = d.nestedDateArray[currentDate];\n          // if (rank == 1){\n          //   return \"url(#temperature-gradient)\";\n          //   // return colorTwo;\n          // }\n          // else{\n          //   return \"url(#temperature-gradient)\";\n          // }\n        }\n\n        function faceBorder(d) {\n          if (dateAhead in d.nestedDateArray) {\n            var rank = d.nestedDateArray[dateAhead];\n            return colorScheme[5 - rank];\n          }\n\n          return null;\n        }\n\n        function faceShadow(d) {\n          if (dateAhead in d.nestedDateArray) {\n            var rank = d.nestedDateArray[dateAhead];\n\n            if (rank == 1) {\n              return \"1px 3px 6px #800080, 1px 3px 9px #800080\";\n            }\n          }\n\n          return null;\n        }\n\n        function pathOpacity(d) {\n          if (dateAhead in d.nestedDateArray) {\n            var rank = d.nestedDateArray[dateAhead];\n\n            if (rank == 1) {\n              return 1;\n            }\n\n            if (rank == 2) {\n              return .8;\n            }\n\n            return .6;\n          }\n\n          return 0;\n        }\n\n        function pathStrokeWidth(d) {\n          if (dateAhead in d.nestedDateArray) {\n            var rank = d.nestedDateArray[dateAhead];\n\n            if (rank == 1) {\n              return \"4px\";\n            }\n\n            return \"4px\";\n          }\n\n          return \"1px\";\n        }\n\n        var transition = d3.select({}).transition().duration(shiftDuration).ease(\"linear\");\n        var tickCount = 0;\n        var extentDates = d3.extent(nestedDates, function (d) {\n          return parseDate(d.key);\n        });\n        extentDates[0] = parseDate(\"2019-01-01\");\n        var yearArray = [];\n        var yearsForPips = [\"2019-01\", \"2019-03\", \"2019-06\", \"2019-09\", \"2019-12\"];\n\n        for (var date in yearsForPips) {\n          var items = testDates.get(yearsForPips[date]);\n          var last = items.values[items.values.length - 1].chart_date.getTime();\n          yearArray.push(last);\n        }\n\n        console.log('yearArray', yearArray);\n\n        function toFormatYear(v) {\n          return sideBarParse(new Date(+v));\n        }\n\n        function toFormat(v) {\n          return niceParse(new Date(+v));\n        } // Add a formatter to the slider\n\n\n        var orientation = \"vertical\";\n\n        if (viewportWidth < 700) {\n          orientation = \"horizontal\";\n        }\n\n        console.log(extentDates);\n        var sliderDates = nouislider__WEBPACK_IMPORTED_MODULE_0___default.a.create(d3.select(\"#slider\").node(), {\n          start: [start.getTime()],\n          step: 7 * 24 * 60 * 60 * 1000,\n          range: {\n            'min': extentDates[0].getTime(),\n            'max': extentDates[1].getTime()\n          },\n          format: {\n            to: toFormat,\n            from: Number\n          },\n          connect: [true, false],\n          tooltips: [true],\n          orientation: orientation,\n          pips: {\n            mode: 'values',\n            values: yearArray,\n            density: 4,\n            stepped: true,\n            format: {\n              to: toFormatYear,\n              from: Number\n            }\n          }\n        });\n        sliderDates.on('start', function (values, handle) {\n          dragging = true;\n        });\n        sliderDates.on('change', function (values, handle, unencoded, tap, positions) {\n          console.log(\"changing\");\n          moveChart(unencoded);\n        });\n        sliderDates.on('end', function (values, handle, unencoded, tap, positions) {\n          dragging = false;\n          moveChart(unencoded);\n        });\n        var playVisible = true;\n        d3.select(\".start-button\").on(\"click\", function () {\n          d3.select(\".loading-screen\").style(\"opacity\", 0).style(\"pointer-events\", \"none\").transition().duration(0).delay(2000).remove();\n          d3.select(\"#content\").classed(\"not-loaded\", false);\n          moveChart(dates[0].getTime());\n          var playNow2 = createSource(scratch);\n          source2 = playNow2.source;\n\n          if (!source2.start) {\n            source2.start = source.noteOn;\n          }\n\n          source2.start(0);\n        });\n        d3.select(\".start-button-muted\").on(\"click\", function () {\n          d3.select(\".loading-screen\").style(\"opacity\", 0).style(\"pointer-events\", \"none\").transition().duration(0).delay(2000).remove();\n          d3.select(\"#content\").classed(\"not-loaded\", false);\n          d3.select(\".vol\").select(\".mute-icon\").style(\"display\", \"none\");\n          d3.select(\".vol\").select(\".vol-icon\").style(\"display\", \"block\");\n          var playNow2 = createSource(scratch);\n          source2 = playNow2.source;\n\n          if (!source2.start) {\n            source2.start = source.noteOn;\n          }\n\n          var gainNode = playNow2.gainNode;\n          gainNode.gain.value = 0;\n          source2.start(0); // var playNow = createSource(bufferNow);\n          // source = playNow.source;\n          // source.loop = true;\n          // var gainNode = playNow.gainNode;\n          // var duration = playingLength/1000 + 2;\n          //\n          //\n          // if(!muted){\n          // \tgainNode.gain.linearRampToValueAtTime(0, startingTime);\n          // \tgainNode.gain.linearRampToValueAtTime(1, startingTime + 1);\n          // }\n          // else {\n          // \tgainNode.gain.value = 0;\n          // }\n          //\n          // if (!source.start){\n          // \tsource.start = source.noteOn;\n          // }\n          //\n          // source.start(context.currentTime + (startingTime - context.currentTime));\n          //\n          // if(!muted){\n          // \tgainNode.gain.linearRampToValueAtTime(1, startingTime + duration-1);\n          // \tgainNode.gain.linearRampToValueAtTime(0, startingTime + duration);\n          // }\n          //\n          // source.stop(context.currentTime + (startingTime - context.currentTime) + duration + .1)\n          //\n          // globalGain = gainNode;\n\n          muted = true;\n          moveChart(dates[0].getTime());\n        });\n        d3.select(\".play-pause\").on(\"click\", function () {\n          if (playing) {\n            moveChart(\"stop\");\n          } else {\n            moveChart(dates[0].getTime());\n          }\n        });\n        d3.select(\".vol\").on(\"click\", function () {\n          if (muted) {\n            muted = false;\n            globalGain.gain.cancelScheduledValues(context.currentTime);\n            globalGain.gain.setValueAtTime(1, context.currentTime);\n            d3.select(\".vol\").select(\".mute-icon\").style(\"display\", null);\n            d3.select(\".vol\").select(\".vol-icon\").style(\"display\", null);\n          } else {\n            muted = true; //globalGain.gain.value = 0;\n\n            globalGain.gain.cancelScheduledValues(context.currentTime);\n            globalGain.gain.setValueAtTime(0, context.currentTime);\n            d3.select(\".vol\").select(\".mute-icon\").style(\"display\", \"none\");\n            d3.select(\".vol\").select(\".vol-icon\").style(\"display\", \"block\");\n          }\n        });\n        d3.selectAll(\".noUi-value\").text(function (d) {\n          return yearParse(new Date(+d3.select(this).text()));\n        });\n\n        function clickOnPip() {\n          var value = this.getAttribute('data-value');\n          sliderDates.set(Number(value));\n          moveChart(Number(value));\n        }\n\n        var pips = d3.select(\"#slider\").selectAll('.noUi-value').each(function (d) {\n          d3.select(this).node().addEventListener('click', clickOnPip);\n        });\n\n        function tick() {\n          if (unParse(dates[0]) == \"2019-03-30\") {\n            moveChart(\"stop\");\n            return null;\n          }\n\n          var currTime = context.currentTime;\n\n          for (var i in dates) {\n            dates[i] = d3.time.day.offset(dates[i], 7);\n          }\n\n          ;\n          var nextSong;\n\n          if (nestedDatesTwo[unParse(dates[0])][\"track\"] != nestedDatesTwo[unParse(d3.time.day.offset(dates[0], 7))][\"track\"] && 1 < 2) {\n            for (i = 2; i < 20; i++) {\n              var timeOne = d3.time.day.offset(dates[0], 7);\n              var timeTwo = d3.time.day.offset(dates[0], 7 * i);\n\n              if (nestedDatesTwo[unParse(timeOne)][\"track\"] != nestedDatesTwo[unParse(timeTwo)][\"track\"]) {\n                playLength = (i - 1) * shiftDuration;\n                break;\n              }\n            }\n\n            var previewItemId = nestedDatesTwo[unParse(d3.time.day.offset(dates[0], 7))][\"preview\"];\n            nextSong = \"https://p.scdn.co/mp3-preview/\" + previewItemId;\n\n            if (previewItemId === '') {\n              nextSong = \"https://p.scdn.co/mp3-preview/\" + \"NULL\";\n            }\n\n            if (previewItemId == \"manual\") {\n              var hostUrl = document.location.origin;\n              var pathUrl = document.location.pathname.replace(\"index.html\", \"\");\n              var idSong = nestedDatesTwo[unParse(d3.time.day.offset(dates[0], 7))][\"track\"];\n              nextSong = hostUrl + pathUrl + \"url/\" + idSong + \".m4a\";\n            }\n\n            startTime = currTime + shiftDuration / 1000;\n            loadSounds(nextSong, playLength, startTime, \"scheduled\");\n          }\n\n          ;\n          currentDate = unParse(dates[0]);\n          dateAhead = unParse(d3.time.day.offset(dates[0], 7));\n          twoDatesAhead = unParse(d3.time.day.offset(dates[0], 14));\n          console.log(currentDate);\n          changeYear(currentYear);\n          var numberOneDates = [dates[0]];\n\n          for (i = 0; i < 8; i++) {\n            var length = numberOneDates.length;\n            var date = d3.time.day.offset(numberOneDates[length - 1], 1);\n            numberOneDates.push(date);\n          }\n\n          if (!dragging) {\n            sliderDates.set(Number(dates[0].getTime()));\n          }\n\n          transition = transition.each(function () {\n            // var numberShiftDuration = shiftDuration/7;\n            // d3.select(\".year-drop-down-text\").text(currentDate.slice(0,4));\n            // d3.select(\"#top-date-sub\")\n            //   .transition().duration(numberShiftDuration).text(function(d){\n            //     return niceParseTwo(numberOneDates[0]);\n            //   })\n            //   .transition().duration(numberShiftDuration).text(function(d){\n            //     return niceParseTwo(numberOneDates[1]);\n            //   })\n            //   .transition().duration(numberShiftDuration).text(function(d){\n            //     return niceParseTwo(numberOneDates[2]);\n            //   })\n            //   .transition().duration(numberShiftDuration).text(function(d){\n            //     return niceParseTwo(numberOneDates[3]);\n            //   })\n            //   .transition().duration(numberShiftDuration).text(function(d){\n            //     return niceParseTwo(numberOneDates[4]);\n            //   })\n            //   .transition().duration(numberShiftDuration).text(function(d){\n            //     return niceParseTwo(numberOneDates[5]);\n            //   })\n            //   .transition().duration(numberShiftDuration).text(function(d){\n            //     return niceParseTwo(numberOneDates[6]);\n            //   })\n            //   .transition().duration(numberShiftDuration).text(function(d){\n            //     return niceParseTwo(numberOneDates[7]);\n            //   })\n            //   ;\n            d3.select(\"#top-title-sub\").text(function (d) {\n              var title = nestedDatesTwo[unParse(dates[0])].title;\n\n              if (title.length > 25 && mobile) {\n                return title.slice(0, 22) + \"...\";\n              }\n\n              return nestedDatesTwo[unParse(dates[0])].title;\n            });\n            d3.select(\"#top-artist-sub\").text(function () {\n              return artistClean(nestedDatesTwo[unParse(dates[0])].artist);\n            });\n\n            if (nestedDatesTwo[unParse(dates[0])][\"track\"] != nestedDatesTwo[unParse(dates[1])][\"track\"]) {\n              countStreak = 1; // d3.select(\"#top-title-sub\").text(nestedDatesTwo[unParse(dates[0])].title);\n              //var topArtistName = nestedDatesTwo[currentDate].artist.split(\" Feat\")[0];\n\n              d3.select(\".streak\").style(\"opacity\", 0); //d3.select(\".streak\").select(\".big\").text(countStreak)\n            } else {\n              countStreak = countStreak + 1;\n\n              if (countStreak > 2) {\n                d3.select(\".streak\").style(\"opacity\", 1);\n              }\n\n              d3.select(\".streak\").select(\".big\").text(countStreak); //.style(\"font-size\",\"70px\")\n              // window.setTimeout(function(){\n              // \td3.select(\".streak\").select(\".big\")\n              // \t\t.style(\"font-size\",null)\n              // },100)\n            }\n\n            x.domain([dates[0], dates[dates.length - 1]]);\n            face.style(\"opacity\", function (d) {\n              return faceOpacity(d);\n            }) // .style(\"display\",function(d){\n            // \treturn faceDisplay(d)\n            // })\n            .style(\"width\", faceSize + \"px\").style(\"height\", faceSize + \"px\").style(\"border-color\", function (d) {\n              return faceBorder(d);\n            }) // .style(\"box-shadow\",function(d){\n            // \treturn faceShadow(d);\n            // })\n            .transition().style(\"top\", function (d) {\n              return faceTop(d);\n            }).style(\"left\", function (d) {\n              var data = d;\n              return faceLeft(data);\n            });\n            lines.style(\"top\", function (d) {\n              return x(d) + \"px\";\n            }).transition().style(\"opacity\", function (d, i) {\n              if (i == 0) {\n                return 0;\n              }\n            });\n            d3.select(\".date-lines-container\").style(\"transform\", \"translate(0px,\" + x(d3.time.day.offset(dates[dates.length - 1], 7)) + \"px)\").transition().styleTween('transform', function (d) {\n              return d3.interpolateString(\"translate(0px,\" + x(d3.time.day.offset(dates[dates.length - 1], 7)) + \"px)\", \"translate(0px,0px)\");\n            });\n            path.attr(\"d\", function (d) {\n              //return lineFunction(d.values);\n              return line(d.values);\n              return line(getPathWeeks(d));\n            }).style(\"stroke\", function (d) {\n              var data = d;\n              return pathStroke(data);\n            }).style(\"opacity\", function (d) {\n              var data = d;\n              return pathOpacity(data);\n            }) // .style(\"display\",function(d){\n            // \treturn faceDisplay(d)\n            // })\n            .style(\"stroke-width\", function (d) {\n              var data = d;\n              return pathStrokeWidth(data);\n            }).each(function (d, i) {\n              if (dateAhead in d.nestedDateArray) {\n                var rank = d.nestedDateArray[dateAhead];\n\n                if (rank == 1) {\n                  clone(d3.select(this)).attr('filter', 'url(#blurred)').style(\"stroke\", colorScheme[0]).attr(\"id\", \"glow\").style(\"stroke-width\", '10px').style(\"opacity\", 1);\n                } else {\n                  clone(d3.select(this)) //.attr('filter', 'url(#blurredTwo)')\n                  .style(\"stroke\", \"#2a292f\").attr(\"id\", \"glow\").style(\"stroke-width\", '6px');\n                }\n              }\n            });\n            d3.select(\".path-container\").selectAll(\"path\").attr(\"transform\", \"translate(0,\" + x(d3.time.day.offset(dates[dates.length - 1], 7)) + \")\");\n            d3.select(\".path-container\").selectAll(\"path\").transition().attr(\"transform\", \"translate(0,0)\"); // }).transition().each(\"start\", tick);\n          }).transition().each(\"start\", function () {\n            if (this.__transition__.count < 2) tick(); //   //tick();\n          }); // });\n        }\n\n        ;\n\n        (function () {\n          hidden = \"hidden\"; // Standards:\n\n          if (hidden in document) document.addEventListener(\"visibilitychange\", onchange);else if ((hidden = \"mozHidden\") in document) document.addEventListener(\"mozvisibilitychange\", onchange);else if ((hidden = \"webkitHidden\") in document) document.addEventListener(\"webkitvisibilitychange\", onchange);else if ((hidden = \"msHidden\") in document) document.addEventListener(\"msvisibilitychange\", onchange); // IE 9 and lower:\n          else if (\"onfocusin\" in document) document.onfocusin = document.onfocusout = onchange; // All others:\n            else window.onpageshow = window.onpagehide = window.onfocus = window.onblur = onchange;\n\n          function onchange(evt) {\n            var v = \"visible\",\n                h = \"hidden\",\n                evtMap = {\n              focus: v,\n              focusin: v,\n              pageshow: v,\n              blur: h,\n              focusout: h,\n              pagehide: h\n            };\n            evt = evt || window.event;\n\n            if (evt.type in evtMap) {} else {\n              if (this[hidden] == true) {\n                if (playing) {\n                  console.log(\"stopped for hidden\");\n                  moveChart(\"stop\");\n                }\n              } else {\n                if (playing) {\n                  console.log(\"continuing\");\n                  moveChart(dates[0].getTime());\n                }\n              }\n            }\n          } // set the initial state (but only if browser supports the Page Visibility API)\n\n\n          if (document[hidden] !== undefined) onchange({\n            type: document[hidden] ? \"blur\" : \"focus\"\n          });\n        })();\n      });\n    });\n  });\n\n  function BufferLoader(context, urlList, callback, playingLength, startingTime, thing) {\n    this.context = context;\n    this.urlList = urlList;\n    this.onload = callback;\n    this.bufferList = new Array();\n    this.loadCount = 0;\n    this.startingTime = startingTime;\n    this.playingLength = playingLength;\n    this.thing = thing;\n  }\n\n  BufferLoader.prototype.loadBuffer = function (url, index) {\n    // Load buffer asynchronously\n    var request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n    request.responseType = \"arraybuffer\";\n    var loader = this;\n\n    request.onload = function () {\n      // Asynchronously decode the audio file data in request.response\n      loader.context.decodeAudioData(request.response, function (buffer) {\n        if (!buffer) {\n          alert('error decoding file data: ' + url);\n          return;\n        }\n\n        loader.bufferList[index] = buffer;\n        if (++loader.loadCount == loader.urlList.length) loader.onload(loader.bufferList, loader.playingLength, loader.startingTime, loader.thing);\n      }, function (error) {\n        console.error('decodeAudioData error', error);\n      });\n    };\n\n    request.onerror = function () {\n      alert('BufferLoader: XHR error');\n    };\n\n    request.send();\n  };\n\n  BufferLoader.prototype.load = function () {\n    for (var i = 0; i < this.urlList.length; ++i) {\n      this.loadBuffer(this.urlList[i], i);\n    }\n  };\n\n  function loadScratch(url) {\n    var req = new XMLHttpRequest();\n    req.open(\"GET\", url, true);\n    req.responseType = \"arraybuffer\";\n\n    req.onload = function () {\n      //decode the loaded data\n      context.decodeAudioData(req.response, function (buffer) {\n        scratch = buffer;\n      });\n    };\n\n    req.send();\n  }\n\n  function loadHit(url) {\n    var req = new XMLHttpRequest();\n    req.open(\"GET\", url, true);\n    req.responseType = \"arraybuffer\";\n\n    req.onload = function () {\n      //decode the loaded data\n      context.decodeAudioData(req.response, function (buffer) {\n        hit = buffer;\n      });\n    };\n\n    req.send();\n  }\n\n  function play() {\n    //create a source node from the buffer\n    var src = context.createBufferSource();\n    src.buffer = buf; //connect to the final output node (the speakers)\n\n    src.connect(context.destination); //play immediately\n\n    src.noteOn(0);\n  }\n\n  window.AudioContext = window.AudioContext || window.webkitAudioContext;\n  context = new AudioContext();\n  loadScratch(\"assets/i_wish.mp3\"); // loadHit(\"url/scratch.wav\");\n\n  function loadSounds(url, playingLength, startingTime, thing) {\n    if (url == \"https://p.scdn.co/mp3-preview/NULL\") {} else {\n      var bufferLoader = new BufferLoader(context, [url], finishedLoading, playingLength, startingTime, thing);\n      bufferLoader.load();\n    }\n  }\n\n  function finishedLoading(bufferList, playingLength, startingTime, thing) {\n    playHelper(bufferList[0], playingLength, startingTime, thing);\n  }\n\n  ;\n\n  function createSource(buffer) {\n    var source = context.createBufferSource();\n    var gainNode = context.createGain ? context.createGain() : context.createGainNode();\n    source.buffer = buffer; // Connect source to gain.\n\n    source.connect(gainNode); // Connect gain to destination.\n\n    gainNode.connect(context.destination);\n    return {\n      source: source,\n      gainNode: gainNode\n    };\n  }\n\n  function playHelper(bufferNow, playingLength, startingTime, thing) {\n    var currTime = context.currentTime;\n    lastSource = source;\n    var playNow = createSource(bufferNow);\n    source = playNow.source;\n    source.loop = true;\n    var gainNode = playNow.gainNode;\n    var duration = playingLength / 1000 + 2;\n\n    if (!muted) {\n      gainNode.gain.linearRampToValueAtTime(0, startingTime);\n      gainNode.gain.linearRampToValueAtTime(1, startingTime + 1);\n    } else {\n      gainNode.gain.value = 0;\n    }\n\n    if (!source.start) {\n      source.start = source.noteOn;\n    }\n\n    source.start(context.currentTime + (startingTime - context.currentTime));\n\n    if (!muted) {\n      gainNode.gain.linearRampToValueAtTime(1, startingTime + duration - 1);\n      gainNode.gain.linearRampToValueAtTime(0, startingTime + duration);\n    }\n\n    source.stop(context.currentTime + (startingTime - context.currentTime) + duration + .1);\n    globalGain = gainNode;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvZ3JhcGhpYy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9ncmFwaGljLmpzP2E5NDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIGQzICovXG5cblxuaW1wb3J0IG5vVWlTbGlkZXIgZnJvbSBcIm5vdWlzbGlkZXJcIjtcbi8vaW1wb3J0ICdub3Vpc2xpZGVyL2Rpc3RyaWJ1dGUvbm91aXNsaWRlci5jc3MnO1xudmFyIGNvdW50U3RyZWFrID0gMTtcbmxldCBkcmFnZ2luZyA9IGZhbHNlO1xubGV0IHN2ZyA9IG51bGw7XG5sZXQgZml4ZWRGYWNlID0gbnVsbDtcbmxldCBmYWNlcyA9IG51bGw7XG5sZXQgZmFjZSA9IG51bGw7XG5sZXQgbGluZXMgPSBudWxsO1xubGV0IGZhY2VBZGp1c3QgPSAwO1xubGV0IGdsb2JhbEdhaW4gPSBudWxsO1xubGV0IHNvdXJjZTIgPSBudWxsO1xuXG52YXIgdmlld3BvcnRXaWR0aDtcbnZhciB2aWV3cG9ydEhlaWdodDtcblxudmlld3BvcnRXaWR0aCA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG52aWV3cG9ydEhlaWdodCA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxudmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6MH0sXG5cdFx0d2lkdGggPSBNYXRoLm1pbigxMTAwLHZpZXdwb3J0V2lkdGgpIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG5cdFx0aGVpZ2h0ID0gKDcxMiAtIDExMikgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxubGV0IGZhY2VTaXplID0gTWF0aC5taW4oKHdpZHRoLTQwKS81LDExMCk7XG5cbmQzLnNlbGVjdChcIi5yYW5raW5nXCIpLnN0eWxlKFwibWFyZ2luLWxlZnRcIixmdW5jdGlvbigpe1xuXHRpZih2aWV3cG9ydFdpZHRoID4gNDIwKXtcblx0XHRyZXR1cm4gZmFjZVNpemUvMitcInB4XCJcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn0pXG5cbmlmKHZpZXdwb3J0V2lkdGggPCA3MDApe1xuXHR3aWR0aCA9IE1hdGguZmxvb3Iodmlld3BvcnRXaWR0aCw1NTApXG59XG5pZih2aWV3cG9ydFdpZHRoIDwgNDIxKXtcblx0d2lkdGggPSB2aWV3cG9ydFdpZHRoIC0gMDtcblx0aGVpZ2h0ID0gNTUwO1xuXHQvL2ZhY2VTaXplID0gTWF0aC5taW4oZmFjZVNpemUsKHdpZHRoKS81KTtcbn1cblxuLy8gaWYodmlld3BvcnRIZWlnaHQgLSAxMTIgPCA2MDApe1xuLy8gXHRoZWlnaHQgPSB2aWV3cG9ydEhlaWdodCAtIDExMjtcbi8vIH1cblxuZDMuc2VsZWN0KFwiLmNoYXJ0XCIpLnN0eWxlKFwid2lkdGhcIix3aWR0aCtcInB4XCIpLnN0eWxlKFwiaGVpZ2h0XCIsaGVpZ2h0K1wicHhcIilcblxuZnVuY3Rpb24gcmVzaXplKCkge31cblxuZnVuY3Rpb24gaW5pdCgpIHtcblx0bmV3Q29kZSgpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCwgcmVzaXplIH07XG5cbmZ1bmN0aW9uIG5ld0NvZGUoKXtcblx0dmFyIGN1bXVsYXRpdmVTdGF0cyA9IGQzLnNlbGVjdChcIi5jdW11bGF0aXZlLWNvbnRhaW5lclwiKTtcblx0dmFyIG4gPSA5LFxuXHQgICAgZHVyYXRpb24gPSAxNTAwLFxuXHQgICAgbm93ID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIGR1cmF0aW9uKTtcblxuXHR2YXIgc2VhcmNoRGF0YTtcblx0dmFyIGNvdW50ID0gW107XG5cdHZhciBzdGFydGVkID0gZmFsc2U7XG5cdHZhciBheGlzO1xuXHR2YXIgY2hhcnREYXRhO1xuXHR2YXIgbmVzdGVkRGF0ZXNUd287XG5cdHZhciBpbWFnZURhdGE7XG5cdHZhciBzaGlmdER1cmF0aW9uID0gMzAwMDtcblx0dmFyIHRpY2tEZWxheTtcblx0dmFyIHBsYXlMZW5ndGggPSAwO1xuXHR2YXIgc3RhcnRUaW1lID0gMDtcblx0dmFyIGNvbG9yT25lID0gXCIjRkYyRjI4XCI7XG5cdHZhciBjb2xvclR3byA9IFwiI0ZGMkYyOFwiO1xuXHR2YXIgY29udGV4dDtcblx0dmFyIGJ1ZmZlckxvYWRlcjtcblx0dmFyIHNjcmF0Y2g7XG5cdHZhciBoaXQ7XG5cdHZhciBzb3VyY2U7XG5cdHZhciBsYXN0U291cmNlO1xuXHR2YXIgY3VycmVudFllYXIgPSAyMDE5O1xuXHR2YXIgd2luZG93Rm9jdXMgPSAwO1xuXHR2YXIgaGlkZGVuO1xuXHR2YXIgdGV4dEFkanVzdCA9IDY7XG5cdHZhciB0ZXh0Q29sb3IgPSBcIiM3OTc5NzlcIjtcblx0dmFyIHBhdGhDb2xvciA9IFwiI0ZGRkZGRlwiO1xuXHR2YXIgcGxheWluZyA9IGZhbHNlO1xuXHR2YXIgbXV0ZWQgPSBmYWxzZTtcblx0dmFyIGhpZGRlbjtcblx0dmFyIG1vYmlsZSA9IGZhbHNlO1xuXG5cdHZhciBwYXJzZURhdGUgPSBkMy50aW1lLmZvcm1hdChcIiVZLSVtLSVkXCIpLnBhcnNlO1xuXHR2YXIgdW5QYXJzZSA9IGQzLnRpbWUuZm9ybWF0KFwiJVktJW0tJWRcIik7XG5cdHZhciBuaWNlUGFyc2UgPSBkMy50aW1lLmZvcm1hdChcIiViLCAnJXlcIik7XG5cdHZhciBuaWNlUGFyc2VUd28gPSBkMy50aW1lLmZvcm1hdChcIiVCICVkLCAnJXlcIik7XG5cdHZhciBuaWNlUGFyc2VUaHJlZSA9IGQzLnRpbWUuZm9ybWF0KFwiJWIgJWUsICcleVwiKTtcblxuXHRpZih2aWV3cG9ydFdpZHRoIDwgNzAwKXtcblx0XHRuaWNlUGFyc2VUaHJlZSA9IGQzLnRpbWUuZm9ybWF0KFwiJWI8YnI+JVlcIik7XG5cdH1cblxuXHR2YXIgbnVtUGFyc2UgPSBkMy50aW1lLmZvcm1hdChcIiVZJW0lZFwiKTtcblx0dmFyIG51bVBhcnNlRGF0ZSA9IGQzLnRpbWUuZm9ybWF0KFwiJVklbSVkXCIpLnBhcnNlO1xuXG5cdHZhciBzaWRlQmFyUGFyc2UgPSBkMy50aW1lLmZvcm1hdChcIiViICcleVwiKTtcblx0dmFyIHllYXJQYXJzZSA9IGQzLnRpbWUuZm9ybWF0KFwiJVlcIilcblxuXHR2YXIgdW5pcXVlUm93c0NzdiA9IFwiYXNzZXRzL2RhdGEvbXlfdW5pcXVlX3Jvd3MuY3N2XCI7XG5cblx0dmFyIHN0YXJ0U3RyaW5nID0gXCIyMDE5LTAxLTAxXCI7XG5cdGlmKCAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICkge1xuXHQgIG1vYmlsZSA9IHRydWU7XG5cdH1cblx0dmFyIHN0YXJ0ID0gbmV3IERhdGUocGFyc2VEYXRlKHN0YXJ0U3RyaW5nKSk7XG5cblx0Ly9pbnRlcmF0ZSB0aHJvdWdoIDE3IHdlZWtzIGJ5IGFkZGluZyA3IHRvIHRoZSBzdGFydCBkYXlcblx0dmFyIGRhdGVzID0gW3N0YXJ0XTtcblx0dmFyIGk7XG5cdGZvciAoaT0wOyBpPDUyOyBpKyspe1xuXHQgIHZhciBsZW5ndGggID0gZGF0ZXMubGVuZ3RoO1xuXHQgIHZhciBkYXRlID0gZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzW2xlbmd0aCAtIDFdLDcpO1xuXHQgIGRhdGVzLnB1c2goZGF0ZSk7XG5cdH1cblx0dmFyIGRhdGVBaGVhZCA9IHVuUGFyc2UoZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzWzBdLCA3KSk7XG5cdGxldCB0d29EYXRlc0FoZWFkID0gdW5QYXJzZShkMy50aW1lLmRheS5vZmZzZXQoZGF0ZXNbMF0sIDE0KSk7XG5cdHZhciBjdXJyZW50RGF0ZSA9IHVuUGFyc2UoZGF0ZXNbMF0pO1xuXG5cdCQoIGRvY3VtZW50ICkucmVhZHkoZnVuY3Rpb24oKSB7XG5cblx0ZDMuY3N2KFwiYXNzZXRzL2RhdGEvbXlfYWxsX3Jvd3MuY3N2XCIsIGZ1bmN0aW9uKGVycm9yLCBkYXRhKSB7XG5cdCAgZDMuY3N2KHVuaXF1ZVJvd3NDc3YsIGZ1bmN0aW9uKGVycm9yLCBzb25nc1VuaXF1ZSkge1xuXG5cdCAgaWYoIC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgKSB7XG5cblx0ICB9XG5cblx0ICB2YXIgc29uZ3NVbmlxdWVNYXAgPSBkMy5tYXAoc29uZ3NVbmlxdWUsIGZ1bmN0aW9uKGQpeyByZXR1cm4gZC5rZXkgfSk7XG5cblx0ICB2YXIgeCA9IGQzLnRpbWUuc2NhbGUoKS5kb21haW4oW2RhdGVzWzBdLGRhdGVzW2RhdGVzLmxlbmd0aC0xXV0pLnJhbmdlKFtoZWlnaHQsIDBdKTtcblxuXHQgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcblx0ICAgICAgLmRvbWFpbihbNiwgMV0pXG5cdCAgICAgIC5yYW5nZShbd2lkdGgsIDBdKVxuXHRcdFx0XHQ7XG5cblx0ICB2YXIgbGluZSA9IGQzLnN2Zy5saW5lKClcbiAgICAgIC5pbnRlcnBvbGF0ZShcImxpbmVhclwiKVxuICAgICAgLngoZnVuY3Rpb24oZCwgaSkge1xuXHRcdFx0XHRyZXR1cm4geSgrZC5yYW5rKTtcblx0XHRcdH0pXG5cdFx0XHQueShmdW5jdGlvbihkLGkpe1xuXHRcdFx0XHRyZXR1cm4geChkLmNoYXJ0X2RhdGUpO1xuXHRcdFx0fSlcblx0XHRcdDtcblxuXG5cdCAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgIGQuY2hhcnRfZGF0ZV9udW0gPSBkLmNoYXJ0X2RhdGU7XG4gICAgICBkLmNoYXJ0X2RhdGUgPSBwYXJzZURhdGUoZC5jaGFydF9kYXRlKTtcblxuXHQgICAgLy8gZC5pZCA9IGQudGl0bGUgKyBcIiBieSBcIiArIGQuYXJ0aXN0O1xuXHQgICAgZC5pZCA9IGQudHJhY2tfaWQ7XG5cdCAgICBpZihzb25nc1VuaXF1ZU1hcC5oYXMoZC5pZCkpe1xuXG5cdCAgICB9ZWxzZXtcblx0ICAgICAgLy8gY29uc29sZS5sb2coZC5pZCk7XG5cdCAgICB9XG5cdCAgICBkLnRyYWNrX2luZm8gPSBzb25nc1VuaXF1ZU1hcC5nZXQoZC5pZCk7XG5cdCAgfSk7XG5cblx0ICB2YXIgYXJ0aXN0RGF0YSA9IGQzLm5lc3QoKS5rZXkoZnVuY3Rpb24oZCl7XG5cdFx0ICAgICAgcmV0dXJuIGQuaWQ7XG5cdFx0ICB9KVxuXHRcdCAgLmVudHJpZXMoZGF0YSk7XG5cblx0ICB2YXIgdGVzdERhdGVzID0gZDMubmVzdCgpLmtleShmdW5jdGlvbihkKXtcblx0XHQgICAgcmV0dXJuIGQuY2hhcnRfZGF0ZV9udW0uc2xpY2UoMCw3KTtcblx0XHQgIH0pXG5cdFx0ICAuZW50cmllcyhkYXRhLmZpbHRlcihmdW5jdGlvbihkKXtcblx0XHRcdFx0cmV0dXJuICtkLnJhbmsgPCA2XG5cdFx0XHR9KSk7XG5cblx0ICAvL2NoYXJ0ZGF0YSBpcyBuZXN0ZWQgYnkgYXJ0aXN0XG5cdCAgY2hhcnREYXRhID0gZDMubmVzdCgpLmtleShmdW5jdGlvbihkKXtcblx0ICAgICAgcmV0dXJuIGQuaWQ7XG5cdCAgfSlcblx0ICAuZW50cmllcyhkYXRhKTtcblxuXHQgIC8vbmVzdGVkRGF0ZXMgaXMgbmVzdGVkIGJ5IHdlZWtcblx0ICB2YXIgbmVzdGVkRGF0ZXMgPSBkMy5uZXN0KCkua2V5KGZ1bmN0aW9uKGQpe1xuXHRcdCAgICAgIHJldHVybiBkLmNoYXJ0X2RhdGVfbnVtO1xuXHRcdCAgfSlcblx0XHQgIC5lbnRyaWVzKGRhdGEpO1xuXG5cblxuXHRcdHZhciB3ZWVrc0ZvckRhdGVMaW5lcyA9IG5lc3RlZERhdGVzLm1hcChmdW5jdGlvbihkKXtcblx0XHRcdHJldHVybiArZC5rZXkucmVwbGFjZShcIi1cIixcIlwiKS5yZXBsYWNlKFwiLVwiLFwiXCIpXG5cdFx0fSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSl7XG5cdFx0XHRyZXR1cm4gaSAlIDQgPT0gMFxuXHRcdH0pXG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0RGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgLy9hZGQgcGVhayB0byB0aGUgdG9wLWxldmVsIG5vZGVcblxuXHQgICAgLy9yYW5rIGJ5IHdlZWtcblx0ICAgIHZhciBkYXRlUmFuayA9IHt9O1xuXHQgICAgZm9yICh2YXIgaj0wOyBqIDwgY2hhcnREYXRhW2ldLnZhbHVlcy5sZW5ndGg7IGorKyl7XG5cdCAgICAgIHZhciBkYXRlID0gY2hhcnREYXRhW2ldLnZhbHVlc1tqXS5jaGFydF9kYXRlX251bTtcblx0ICAgICAgdmFyIHJhbmsgPSBjaGFydERhdGFbaV0udmFsdWVzW2pdLnJhbms7XG5cdFx0XHRcdGlmKHJhbmsgPCA2KXtcblx0XHRcdFx0XHRkYXRlUmFua1tkYXRlXSA9IHJhbmtcblx0XHRcdFx0fVxuXHQgICAgfVxuXHQgICAgY2hhcnREYXRhW2ldLm5lc3RlZERhdGVBcnJheSA9IGRhdGVSYW5rO1xuXHQgIH1cblxuXHQgIHZhciBjaGFydE1hcCA9IGQzLm1hcChjaGFydERhdGEsIGZ1bmN0aW9uKGQpeyByZXR1cm4gZC5rZXkgfSk7XG5cblx0ICBmb3IgKHZhciBkYXRlIGluIHRlc3REYXRlcyl7XG5cdCAgICBmb3IgKHZhciB0cmFjayBpbiB0ZXN0RGF0ZXNbZGF0ZV0udmFsdWVzKXtcblx0ICAgICAgdmFyIGl0ZW0gPSBjaGFydE1hcC5nZXQodGVzdERhdGVzW2RhdGVdLnZhbHVlc1t0cmFja10uaWQpO1xuXHQgICAgICB0ZXN0RGF0ZXNbZGF0ZV0udmFsdWVzW3RyYWNrXS5uZXN0ZWREYXRlQXJyYXkgPSBpdGVtLm5lc3RlZERhdGVBcnJheTtcblx0ICAgICAgdGVzdERhdGVzW2RhdGVdLnZhbHVlc1t0cmFja10ua2V5ID0gaXRlbS5rZXk7XG5cdCAgICAgIHRlc3REYXRlc1tkYXRlXS52YWx1ZXNbdHJhY2tdLnZhbHVlcyA9IGl0ZW0udmFsdWVzXG5cdFx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbihkKXtcblx0XHRcdFx0XHRcdHJldHVybiArZC5yYW5rIDwgNjtcblx0XHRcdFx0XHR9KTtcblx0ICAgIH1cblx0ICB9XG5cblxuXHQgIHRlc3REYXRlcyA9IGQzLm1hcCh0ZXN0RGF0ZXMsIGZ1bmN0aW9uKGQpeyByZXR1cm4gZC5rZXkgfSk7XG5cdFx0Y29uc29sZS5sb2codW5QYXJzZShkYXRlc1swXSkuc2xpY2UoMCw3KSlcblx0XHR2YXIgZmlsdGVyZWREYXRhID0gdGVzdERhdGVzLmdldCh1blBhcnNlKGRhdGVzWzBdKS5zbGljZSgwLDcpKS52YWx1ZXM7XG5cblx0XHR2YXIgbmV4dE1vbnRoID0gdW5QYXJzZShkMy50aW1lLm1vbnRoLm9mZnNldChkYXRlc1swXSwxKSkuc2xpY2UoMCw3KVxuXHRcdHZhciBmaWx0ZXJlZERhdGFOZXh0ID0gdGVzdERhdGVzLmdldCh1blBhcnNlKGQzLnRpbWUubW9udGgub2Zmc2V0KGRhdGVzWzBdLDEpKS5zbGljZSgwLDcpKS52YWx1ZXM7XG5cdFx0ZmlsdGVyZWREYXRhID0gXy51bmlvbkJ5KGZpbHRlcmVkRGF0YSwgZmlsdGVyZWREYXRhTmV4dCk7XG5cblx0ICAvL25lc3RlZERhdGVzVHdvIGlzIGZvciB0aGUgYXVkaW8gc28gdGhhdCBpdCBrbm93cyB3aGF0IGl0IHdpbGwgcGxheSBlYWNoIHdlZWtcblx0ICB2YXIgbmVzdGVkRGF0ZXNUd28gPSB7fTtcblxuXHQgIC8vc29ydHMgZXZlcnl0aGluZyBmb3IgZ2V0dGluZyB0aGUgdG9wIHJhbmtlZCB0cmFjayB0aGF0IGdvZXMgaW50byBuZXN0ZWREYXRlc1R3b1xuXHQgIGZvciAodmFyIGkgaW4gbmVzdGVkRGF0ZXMpe1xuXHQgICAgbmVzdGVkRGF0ZXNbaV0udmFsdWVzLnNvcnQoZnVuY3Rpb24oYSxiKSB7cmV0dXJuIGEucmFuay1iLnJhbms7fSk7XG5cdCAgfVxuXG5cdCAgLy9uZXN0ZWREYXRlcyBpcyB0aGUgZGF0YSBuZXN0ZWQgYnkgd2Vla1xuXHQgIGZvciAodmFyIGkgaW4gbmVzdGVkRGF0ZXMpe1xuXHQgICAgdmFyIGRhdGUgPSBuZXN0ZWREYXRlc1tpXS5rZXk7XG5cdCAgICBuZXN0ZWREYXRlc1R3b1tkYXRlXSA9IHtcblx0ICAgICAgdHJhY2s6bmVzdGVkRGF0ZXNbaV1bXCJ2YWx1ZXNcIl1bMF1bXCJpZFwiXSxcblx0ICAgICAgcHJldmlldzpuZXN0ZWREYXRlc1tpXVtcInZhbHVlc1wiXVswXVtcInRyYWNrX2luZm9cIl1bXCJzb25nX3VybFwiXSxcblx0ICAgICAgYXJ0aXN0Om5lc3RlZERhdGVzW2ldW1widmFsdWVzXCJdWzBdW1widHJhY2tfaW5mb1wiXVtcImFydGlzdFwiXSxcblx0ICAgICAgdGl0bGU6bmVzdGVkRGF0ZXNbaV1bXCJ2YWx1ZXNcIl1bMF1bXCJ0cmFja19pbmZvXCJdW1widGl0bGVcIl1cblx0ICAgIH07XG5cdCAgfVxuXG5cblx0XHQvL3dlZWsgbWFwIGZvciBnZXR0aW5nIHRvcCByYW5rZWQgc29uZ3Ncblx0XHR2YXIgcmFua2luZ01hcCA9IGQzLm1hcChuZXN0ZWREYXRlcyxmdW5jdGlvbihkKXtcblx0XHRcdHJldHVybiBkLmtleTtcblx0XHR9KVxuXG5cdCAgZnVuY3Rpb24gY2hhbmdlWWVhcihjaGFuZ2VkWWVhcil7XG5cblx0ICAgIHZhciBkdXJhdGlvbjEgPSA4MDA7XG5cdCAgICB2YXIgZHVyYXRpb24yID0gNDAwO1xuXG5cdFx0XHR2YXIgZmlsdGVyZWREYXRhRmlyc3QgPSB0ZXN0RGF0ZXMuZ2V0KHVuUGFyc2UoZGF0ZXNbMF0pLnNsaWNlKDAsNykpLnZhbHVlcztcblx0XHRcdGlmKGRhdGVzWzBdIDw9IG5ldyBEYXRlKHBhcnNlRGF0ZShcIjIwMTktMDEtMDFcIikpKXtcblx0XHRcdFx0dmFyIGZpbHRlcmVkRGF0YU5leHQgPSB0ZXN0RGF0ZXMuZ2V0KHVuUGFyc2UoZDMudGltZS5tb250aC5vZmZzZXQoZGF0ZXNbMF0sMSkpLnNsaWNlKDAsNykpLnZhbHVlcztcblx0XHRcdFx0dmFyIGZpbHRlcmVkRGF0YVRoaXJkID0gdGVzdERhdGVzLmdldCh1blBhcnNlKGQzLnRpbWUubW9udGgub2Zmc2V0KGRhdGVzWzBdLDIpKS5zbGljZSgwLDcpKS52YWx1ZXM7XG5cdFx0XHRcdHZhciBmaWx0ZXJlZERhdGFGb3VydGggPSB0ZXN0RGF0ZXMuZ2V0KHVuUGFyc2UoZDMudGltZS5tb250aC5vZmZzZXQoZGF0ZXNbMF0sMikpLnNsaWNlKDAsNykpLnZhbHVlcztcblx0XHRcdFx0ZmlsdGVyZWREYXRhID0gXy51bmlvbkJ5KGZpbHRlcmVkRGF0YUZpcnN0LCBmaWx0ZXJlZERhdGFOZXh0LGZpbHRlcmVkRGF0YVRoaXJkLGZpbHRlcmVkRGF0YUZvdXJ0aCwgJ2tleScpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZpbHRlcmVkRGF0YSA9IGZpbHRlcmVkRGF0YUZpcnN0O1xuXHRcdFx0fVxuXG5cdFx0XHRkMy5zZWxlY3RBbGwoXCIjZ2xvd1wiKS5yZW1vdmUoKTtcblxuXHQgICAgcGF0aCA9IHBhdGguZGF0YShmaWx0ZXJlZERhdGEsIGZ1bmN0aW9uKGQpe1xuXHQgICAgICByZXR1cm4gZC5rZXk7XG5cdCAgICB9KVxuXHQgICAgO1xuXG5cdFx0XHRsaW5lcyA9IGxpbmVzLmRhdGEoZGF0ZXMsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0fSk7XG5cblx0ICAgIGZhY2UgPSBmYWNlLmRhdGEoZmlsdGVyZWREYXRhLCBmdW5jdGlvbihkKXtcblx0ICAgICAgcmV0dXJuIGQua2V5O1xuXHQgICAgfSk7XG5cblx0ICAgIHBhdGguZW50ZXIoKVxuXHRcdFx0XHQuYXBwZW5kKFwicGF0aFwiKVxuXHQgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGluZVwiKVxuXHQgICAgICAuYXR0cihcImRcIiwgZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0cmV0dXJuIGxpbmUoZC52YWx1ZXMpO1xuXHQgICAgICAgIC8vcmV0dXJuIGxpbmVGdW5jdGlvbihkLnZhbHVlcyk7XG5cdFx0XHRcdFx0cmV0dXJuIGxpbmUoZ2V0UGF0aFdlZWtzKGQpKTtcblx0ICAgICAgfSlcblx0ICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB4KGRhdGVzW2RhdGVzLmxlbmd0aC0xXSkgKyBcIilcIilcblx0ICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGZ1bmN0aW9uKGQpe1xuXHQgICAgICAgIHZhciBkYXRhID0gZDtcblx0ICAgICAgICByZXR1cm4gcGF0aFN0cm9rZShkYXRhKTtcblx0ICAgICAgfSlcblx0XHRcdFx0Ly8gLnN0eWxlKFwiZGlzcGxheVwiLGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHQvLyBcdHJldHVybiBmYWNlRGlzcGxheShkKVxuXHRcdFx0XHQvLyB9KVxuXHQgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdGhPcGFjaXR5KGQpO1xuXHQgICAgICB9KVxuXHQgICAgICA7XG5cblx0XHRcdGxpbmVzLmVudGVyKClcblx0XHRcdFx0LmFwcGVuZChcImRpdlwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsXCJkYXRlLWxpbmVcIilcblx0XHRcdFx0LnN0eWxlKFwidG9wXCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0cmV0dXJuIHgoZCkrXCJweFwiO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0dmFyIGRhdGUgPSArdW5QYXJzZShkKS5yZXBsYWNlKFwiLVwiLFwiXCIpLnJlcGxhY2UoXCItXCIsXCJcIik7XG5cdFx0XHRcdFx0aWYod2Vla3NGb3JEYXRlTGluZXMuaW5kZXhPZihkYXRlKSA+IC0xKXtcblx0XHRcdFx0XHRcdHJldHVybiBcImJsb2NrXCJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYXBwZW5kKFwicFwiKVxuXHRcdFx0XHQuaHRtbChmdW5jdGlvbihkKXtcblx0XHRcdFx0XHRyZXR1cm4gbmljZVBhcnNlVGhyZWUoZCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdDtcblxuXHQgICAgZmFjZS5lbnRlcigpXG5cdFx0XHRcdC5hcHBlbmQoXCJkaXZcIilcblx0ICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZmFjZSB0ay1mdXR1cmEtcHRcIilcblx0XHRcdFx0Ly8gLnN0eWxlKFwiZGlzcGxheVwiLGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHQvLyBcdHJldHVybiBmYWNlRGlzcGxheShkKVxuXHRcdFx0XHQvLyB9KVxuXHQgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWltYWdlXCIsIGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRcdGlmKGNoYW5nZWRZZWFyID09IFwic2Nyb2xsXCIpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHQgICAgICAgIGlmKGRbXCJ0cmFja19pbmZvXCJdW1wiYXJ0aXN0X3VybFwiXSA9PSBcIk5VTExcIil7XG5cdCAgICAgICAgICByZXR1cm4gbnVsbFxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZihkW1widHJhY2tfaW5mb1wiXVtcImFydGlzdF91cmxcIl0gPT0gXCJtYW51YWxcIil7XG5cdCAgICAgICAgICB2YXIgaG9zdFVybCA9IGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbjtcblx0ICAgICAgICAgIHZhciBwYXRoVXJsID0gZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZShcImluZGV4Lmh0bWxcIixcIlwiKTtcblx0ICAgICAgICAgIHZhciBpZFNvbmcgPSBuZXN0ZWREYXRlc1R3b1t1blBhcnNlKGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1tkYXRlcy5sZW5ndGgtMV0sIDcpKV1bXCJ0cmFja1wiXTtcblx0ICAgICAgICAgIG5leHRTb25nID0gaG9zdFVybCtwYXRoVXJsK1widXJsL1wiK2lkU29uZyArIFwiLm00YVwiXG5cdCAgICAgICAgICByZXR1cm4gXCJ1cmwoXCIrbmV4dFNvbmcrXCIpXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBcInVybChodHRwczovL2kuc2Nkbi5jby9pbWFnZS9cIitkW1widHJhY2tfaW5mb1wiXVtcImFydGlzdF91cmxcIl0rXCIpXCJcblx0ICAgICAgfSlcblx0XHRcdFx0LnN0eWxlKFwidG9wXCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0cmV0dXJuIGZhY2VUb3AoZCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5zdHlsZShcImxlZnRcIixmdW5jdGlvbihkKXtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IGQ7XG5cdFx0XHRcdFx0cmV0dXJuIGZhY2VMZWZ0KGRhdGEpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYXBwZW5kKFwicFwiKVxuXHRcdFx0XHQuYXBwZW5kKFwic3BhblwiKVxuXHRcdFx0XHQudGV4dChmdW5jdGlvbihkKXtcblx0XHRcdFx0XHR2YXIgdGl0bGUgPSBkLnRyYWNrX2luZm8udGl0bGU7XG5cdFx0XHRcdFx0aWYodGl0bGUubGVuZ3RoID4gMjApe1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRpdGxlLnNsaWNlKDAsMTcpK1wiLi4uXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRpdGxlO1xuXHRcdFx0XHR9KVxuXHQgICAgICA7XG5cblx0ICAgIHBhdGguZXhpdCgpLnJlbW92ZSgpO1xuXHQgICAgZmFjZS5leGl0KCkucmVtb3ZlKCk7XG5cdFx0XHRsaW5lcy5leGl0KCkucmVtb3ZlKCk7XG5cdCAgfVxuXG5cdCAgdmFyIGN1cnJlbnREYXRlID0gdW5QYXJzZShkYXRlc1swXSk7XG5cdCAgdmFyIGRhdGVBaGVhZCA9IHVuUGFyc2UoZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzWzBdLCA3KSk7XG5cdFx0dmFyIHR3b0RhdGVzQWhlYWQgPSB1blBhcnNlKGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1swXSwgMTQpKTtcblxuXHQgIHZhciBvcGFjaXR5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oWzUsMywxXSkucmFuZ2UoWy4wMSwuMjUsMV0pO1xuXHQgIHZhciB0aW1lbGluZVNjYWxlID0gZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKFswLDM1NF0pLnJhbmdlKFsyMywzNzVdKTtcblxuXHQgIGZ1bmN0aW9uIHRvcEFydGlzdChkKXtcblx0ICAgIHJldHVybiBuZXN0ZWREYXRlc1R3b1tjdXJyZW50RGF0ZV0udGl0bGUrXCLDouKCrOKAnVwiK25lc3RlZERhdGVzVHdvW2N1cnJlbnREYXRlXS5hcnRpc3Q7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZmFjZUJhY2tncm91bmQoZCkge1xuXHQgICAgdmFyIHJhbmsgPSBkLm5lc3RlZERhdGVBcnJheVtkYXRlQWhlYWRdO1xuXHQgICAgaWYgKHJhbmsgPT0gMSl7XG5cdCAgICAgIHJldHVybiBjb2xvclR3bztcblx0ICAgIH1cblx0ICAgIGVsc2V7XG5cdCAgICAgIGlmIChjdXJyZW50RGF0ZSBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdCAgICAgICAgdmFyIHJhbmsgPSBkLm5lc3RlZERhdGVBcnJheVtjdXJyZW50RGF0ZV07XG5cdCAgICAgICAgcmV0dXJuIGQzLmludGVycG9sYXRlKFwiI2ZmZlwiLCBcIiMwMDBcIikob3BhY2l0eVNjYWxlKHJhbmspKTtcblx0ICAgICAgfVxuXHQgICAgICBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gZDMuaW50ZXJwb2xhdGUoXCIjZmZmXCIsIFwiIzAwMFwiKShvcGFjaXR5U2NhbGUoLjAxKSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgc3ZnID0gZDMuc2VsZWN0KFwiLmNoYXJ0XCIpLmFwcGVuZChcInN2Z1wiKVxuXHQgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KVxuXHQgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG5cdFx0XHQuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0ICsgXCJweFwiKVxuXHRcdFx0LnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tICsgXCJweFwiKVxuXHQgICAgLmF0dHIoXCJjbGFzc1wiLFwibGluZXMtY29udGFpbmVyXCIpXG5cdCAgICA7XG5cblx0XHQvLyB2YXIgY29sb3JTY2hlbWUgPSBkMy5zY2hlbWVZbEduQnVbNV07XG5cdFx0Ly9jb2xvclNjaGVtZSA9IGQzLnNjaGVtZUduQnVbNV07XG5cdFx0dmFyIGNvbG9yU2NoZW1lID0gW1wiIzQ5MjE3YVwiLFwiIzg1MmM4MlwiLFwiI2I1MmY1OVwiLFwiI2Y1YWY3MVwiLFwiI2ZjZmJiY1wiXS5yZXZlcnNlKClcblx0XHQvL2NvbG9yU2NoZW1lID0gW1wieWVsbG93XCIsXCJvcmFuZ2VcIixcInJlZFwiLFwiZ3JlZW5cIixcInN0ZWVsYmx1ZVwiXS8vLnJldmVyc2UoKVxuXG5cblxuXHQgIHN2Zy5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKVxuXHQgICAgICAuYXR0cihcImlkXCIsIFwidGVtcGVyYXR1cmUtZ3JhZGllbnRcIilcblx0ICAgICAgLmF0dHIoXCJncmFkaWVudFVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIilcblx0ICAgICAgLmF0dHIoXCJ4MVwiLCB5KDUpKVxuXHRcdFx0XHQuYXR0cihcInkxXCIsIDApXG5cdCAgICAgIC5hdHRyKFwieDJcIiwgeSgxKSlcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAwKVxuXHQgICAgICAuc2VsZWN0QWxsKFwic3RvcFwiKVxuXHQgICAgICAgIC5kYXRhKFxuXHRcdFx0XHRcdFx0Y29sb3JTY2hlbWUucmV2ZXJzZSgpXG5cdFx0XHRcdFx0XHRcdC5tYXAoZnVuY3Rpb24oZCxpKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtvZmZzZXQ6KGkqMjUpK1wiJVwiLGNvbG9yOmR9XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC8vIFx0W1xuXHQgICAgICAgIC8vICAge29mZnNldDogXCIwJVwiLCBjb2xvcjogXCJzdGVlbGJsdWVcIn0sXG5cdFx0XHRcdFx0Ly8gXHR7b2Zmc2V0OiBcIjIwJVwiLCBjb2xvcjogXCJncmVlblwifSxcblx0XHRcdFx0XHQvLyBcdHtvZmZzZXQ6IFwiNDAlXCIsIGNvbG9yOiBcInllbGxvd1wifSxcblx0ICAgICAgICAvLyAgIHtvZmZzZXQ6IFwiNjAlXCIsIGNvbG9yOiBcIm9yYW5nZVwifSxcblx0ICAgICAgICAvLyAgIHtvZmZzZXQ6IFwiMTAwJVwiLCBjb2xvcjogXCIjRkYyRjI4XCJ9XG5cdCAgICAgICAgLy8gXVxuXHRcdFx0XHQpXG5cdCAgICAgIC5lbnRlcigpLmFwcGVuZChcInN0b3BcIilcblx0ICAgICAgICAuYXR0cihcIm9mZnNldFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLm9mZnNldDsgfSlcblx0ICAgICAgICAuYXR0cihcInN0b3AtY29sb3JcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5jb2xvcjsgfSk7XG5cblx0XHRzdmcuYXBwZW5kKFwiZGVmc1wiKS5odG1sKCc8ZmlsdGVyIGlkPVwib3V0bGluZVwiPiA8ZmVNb3JwaG9sb2d5IGluPVwiU291cmNlQWxwaGFcIiByZXN1bHQ9XCJESUxBVEVEXCIgb3BlcmF0b3I9XCJkaWxhdGVcIiByYWRpdXM9XCIzXCI+PC9mZU1vcnBob2xvZ3k+IDxmZUZsb29kIGZsb29kLWNvbG9yPVwiIzExMVwiIGZsb29kLW9wYWNpdHk9XCIxXCIgcmVzdWx0PVwiUElOS1wiPjwvZmVGbG9vZD4gPGZlQ29tcG9zaXRlIGluPVwiUElOS1wiIGluMj1cIkRJTEFURURcIiBvcGVyYXRvcj1cImluXCIgcmVzdWx0PVwiT1VUTElORVwiPjwvZmVDb21wb3NpdGU+IDxmZU1lcmdlPiA8ZmVNZXJnZU5vZGUgaW49XCJPVVRMSU5FXCI+PC9mZU1lcmdlTm9kZT4gPGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiPjwvZmVNZXJnZU5vZGU+IDwvZmVNZXJnZT4gPC9maWx0ZXI+JylcblxuXHQgIHN2Zy5hcHBlbmQoXCJkZWZzXCIpXG5cdCAgICAuYXBwZW5kKFwiY2xpcFBhdGhcIilcblx0ICAgIC5hdHRyKFwiaWRcIiwgXCJjbGlwXCIpXG5cdCAgICAuYXBwZW5kKFwicmVjdFwiKVxuXHQgICAgLmF0dHIoXCJ4XCIsIDApXG5cdCAgICAuYXR0cihcInlcIiwgLTUwMClcblx0ICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG5cdCAgICAuYXR0cihcImhlaWdodFwiLGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRpZih2aWV3cG9ydFdpZHRoIDwgMzI2KXtcblx0XHRcdFx0XHRyZXR1cm4gNTAwICsgaGVpZ2h0IC0gZmFjZVNpemUqLjlcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih2aWV3cG9ydFdpZHRoIDwgMzc2KXtcblx0XHRcdFx0XHRyZXR1cm4gNTAwICsgaGVpZ2h0IC0gZmFjZVNpemUqLjhcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih2aWV3cG9ydFdpZHRoIDwgNDExKXtcblx0XHRcdFx0XHRyZXR1cm4gNTAwICsgaGVpZ2h0IC0gZmFjZVNpemUqLjc1XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodmlld3BvcnRXaWR0aCA8IDQyMSl7XG5cdFx0XHRcdFx0cmV0dXJuIDUwMCArIGhlaWdodCAtIGZhY2VTaXplKi43XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIDUwMCArIGhlaWdodCAtIGZhY2VTaXplKi42XG5cdFx0XHR9KVxuXG5cdCAgc3ZnLmFwcGVuZChcImRlZnNcIilcblx0ICAgIC5hcHBlbmQoXCJjbGlwUGF0aFwiKVxuXHQgICAgLmF0dHIoXCJpZFwiLCBcInhheGlzY2xpcFwiKVxuXHQgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyAyMClcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi5ib3R0b20gKiAyICsgbWFyZ2luLnRvcCk7XG5cblxuXHRcdHN2Zy5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcImZpbHRlclwiKVxuICAgICAgLmF0dHIoXCJpZFwiLCdibHVycmVkJylcbiAgICBcdC8vLmF0dHIoe1wid2lkdGhcIjpcIjIwMCVcIiwgXCJoZWlnaHRcIjpcIjIwMCVcIn0pXG4gICAgXHQuYXBwZW5kKFwiZmVHYXVzc2lhbkJsdXJcIikuYXR0cihcInN0ZERldmlhdGlvblwiLCA4KTtcblxuXHRcdHN2Zy5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcImZpbHRlclwiKVxuICAgICAgLmF0dHIoXCJpZFwiLCdibHVycmVkVHdvJylcbiAgICBcdC8vLmF0dHIoe1wid2lkdGhcIjpcIjIwMCVcIiwgXCJoZWlnaHRcIjpcIjIwMCVcIn0pXG4gICAgXHQuYXBwZW5kKFwiZmVHYXVzc2lhbkJsdXJcIikuYXR0cihcInN0ZERldmlhdGlvblwiLCAyKTtcblxuXHRcdC8vIGJ1aWxkIHBhdGhzXG5cblx0XHR2YXIgcGF0aFN2ZyA9IHN2Zy5hcHBlbmQoXCJnXCIpXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBcInVybCgjY2xpcClcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIixcInBhdGgtY29udGFpbmVyXCIpXG5cdFx0XHQ7XG5cblx0XHRmdW5jdGlvbiBnZXRQYXRoV2Vla3MoZCl7XG5cdFx0XHR2YXIgd2Vla3MgPSBkLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCl7cmV0dXJuIGQ7fSk7XG5cdFx0XHR2YXIgd2Vla0FycmF5ID0gW107XG5cblx0XHRcdHZhciBzdGFydE9mV2VlayA9IGQudmFsdWVzWzBdXG5cdFx0XHR2YXIgZW5kID0gZDMudGltZS5kYXkub2Zmc2V0KHN0YXJ0T2ZXZWVrLmNoYXJ0X2RhdGUsMylcblx0XHRcdHZhciByYW5nZSA9IGQzLnRpbWUuZGF5LnJhbmdlKHN0YXJ0T2ZXZWVrLmNoYXJ0X2RhdGUsZW5kKTtcblxuXHRcdFx0Zm9yICh2YXIgaXRlbSBpbiByYW5nZSl7XG5cdFx0XHRcdHdlZWtzLnB1c2goe3Jhbms6c3RhcnRPZldlZWsucmFuaywgY2hhcnRfZGF0ZTpyYW5nZVtpdGVtXX0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZW5kT2ZXZWVrID0gZC52YWx1ZXNbZC52YWx1ZXMubGVuZ3RoLTFdXG5cdFx0XHR2YXIgZW5kVHdvID0gZDMudGltZS5kYXkub2Zmc2V0KGVuZE9mV2Vlay5jaGFydF9kYXRlLDMpXG5cdFx0XHR2YXIgcmFuZ2VUd28gPSBkMy50aW1lLmRheS5yYW5nZShlbmRPZldlZWsuY2hhcnRfZGF0ZSxlbmRUd28pO1xuXG5cdFx0XHRmb3IgKHZhciBpdGVtIGluIHJhbmdlVHdvKXtcblx0XHRcdFx0d2Vla3MucHVzaCh7cmFuazplbmRPZldlZWsucmFuaywgY2hhcnRfZGF0ZTpyYW5nZVR3b1tpdGVtXX0pO1xuXHRcdFx0fVxuXG5cdFx0XHR3ZWVrcyA9IHdlZWtzLnNvcnQoZnVuY3Rpb24oYSxiKXtcblx0XHRcdFx0cmV0dXJuIGEuY2hhcnRfZGF0ZSAtIGIuY2hhcnRfZGF0ZTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gd2Vla3Ncblx0XHR9XG5cblx0XHR2YXIgbGluZUZ1bmN0aW9uID0gZDMuc3ZnLmxpbmUoKVxuXHRcdFx0LmludGVycG9sYXRlKGZ1bmN0aW9uKHBvaW50cyl7XG5cdFx0XHRcdGZvciAodmFyIHBvaW50IGluIHBvaW50cyl7XG5cdFx0XHRcdFx0cG9pbnRzW3BvaW50XSA9IHByb2plY3QobWF0cml4LCBwb2ludHNbcG9pbnRdKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwb2ludHMuam9pbihcIkxcIik7XG5cdFx0XHR9KVxuXHRcdFx0LngoZnVuY3Rpb24oZCwgaSkge1xuXHRcdFx0XHRyZXR1cm4geSgrZC5yYW5rKTtcblx0XHRcdH0pXG5cdFx0XHQueShmdW5jdGlvbihkLGkpe1xuXHRcdFx0XHRyZXR1cm4geChkLmNoYXJ0X2RhdGUpOyAvL3RoaXMgeCBpcyBub3cgdHJhbnNsYXRpbmcgYmV0d2VlbiAwIGFuZCBoZWlnaHQgd2l0aCBkYXRlIG9uIHktYXhpc1xuXHRcdFx0fSlcblx0XHRcdDtcblxuXG5cdFx0dmFyIHBhdGggPSBwYXRoU3ZnLnNlbGVjdEFsbCgncGF0aCcpLmRhdGEoZmlsdGVyZWREYXRhLCBmdW5jdGlvbihkKXtcblx0XHRcdFx0cmV0dXJuIGQua2V5O1xuXHRcdFx0fSlcblx0XHRcdC5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5lXCIpXG5cdFx0XHQuYXR0cihcImRcIiwgZnVuY3Rpb24oZCl7XG5cdFx0XHRcdHJldHVybiBsaW5lKGQudmFsdWVzKTtcblx0XHRcdFx0Ly9yZXR1cm4gbGluZUZ1bmN0aW9uKGQudmFsdWVzKTtcblx0XHRcdFx0cmV0dXJuIGxpbmUoZ2V0UGF0aFdlZWtzKGQpKTtcblxuXHRcdFx0fSlcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCBmdW5jdGlvbihkKXtcblx0XHRcdFx0Ly92YXIgZGF0YSA9IGQ7XG5cdFx0XHRcdC8vcmV0dXJuIFwicmVkXCJcblx0XHRcdFx0cmV0dXJuIHBhdGhTdHJva2UoZCk7XG5cdFx0XHR9KVxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHR2YXIgZGF0YSA9IGQ7XG5cdFx0XHRcdHJldHVybiBwYXRoT3BhY2l0eShkYXRhKTtcblx0XHRcdH0pXG5cdFx0XHQ7XG5cblx0XHRmdW5jdGlvbiBjbG9uZShzZWxlY3Rvcikge1xuXHQgICAgdmFyIG5vZGUgPSBzZWxlY3Rvci5ub2RlKCk7XG5cdCAgICByZXR1cm4gZDMuc2VsZWN0KG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZS5jbG9uZU5vZGUodHJ1ZSksXG5cdFx0XHRub2RlKSk7XG5cdFx0fVxuXG5cdFx0cGF0aC5lYWNoKGZ1bmN0aW9uKGQsaSl7XG5cdFx0XHRpZiAoZGF0ZUFoZWFkIGluIGQubmVzdGVkRGF0ZUFycmF5KXtcblx0XHRcdFx0dmFyIHJhbmsgPSBkLm5lc3RlZERhdGVBcnJheVtkYXRlQWhlYWRdO1xuXHRcdFx0XHRpZihyYW5rPT0xKXtcblx0XHRcdFx0XHRjbG9uZShkMy5zZWxlY3QodGhpcykpLmF0dHIoJ2ZpbHRlcicsICd1cmwoI2JsdXJyZWQpJykuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwnOXB4Jykuc3R5bGUoXCJzdHJva2VcIixjb2xvclNjaGVtZVswXSkuc3R5bGUoXCJvcGFjaXR5XCIsLjgpLmF0dHIoXCJpZFwiLFwiZ2xvd1wiKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHZhciBib3R0b21GcmFtZSA9IGQzLnNlbGVjdChcIi5ib3R0b20tZnJhbWVcIilcblx0XHRcdC5zdHlsZShcIndpZHRoXCIsd2lkdGgrXCJweFwiKVxuXHRcdFx0Ly8uc3R5bGUoXCJ3aWR0aFwiLCg2MjApK1wicHhcIilcblx0XHRcdC5zdHlsZShcImhlaWdodFwiLGhlaWdodCtcInB4XCIpO1xuXG5cdFx0Ym90dG9tRnJhbWUuc2VsZWN0KFwiLnJhbmtpbmdcIikuc2VsZWN0QWxsKFwiLnJhbmstbnVtXCIpXG5cdFx0XHQuc3R5bGUoXCJjb2xvclwiLGZ1bmN0aW9uKGQsaSl7XG5cdFx0XHRcdGlmKGk9PTQpe1xuXHRcdFx0XHRcdHJldHVybiBcIiM3MTU5OGVcIlxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb2xvclNjaGVtZVtjb2xvclNjaGVtZS5sZW5ndGggLSBpIC0gMV07XG5cdFx0XHR9KVxuXHRcdFx0O1xuXG5cdFx0Ly9ndWl0YXIgaGVybyBvdXRsaW5lXG5cdFx0dmFyIGd1aXRhckhlcm9PdXRsaW5lID0gZDMuc2VsZWN0KFwiLmd1aXRhci1mcmFtZVwiKVxuXHRcdFx0LnN0eWxlKFwid2lkdGhcIix3aWR0aCtcInB4XCIpXG5cdFx0XHQvLy5zdHlsZShcIndpZHRoXCIsKDYyMCkrXCJweFwiKVxuXHRcdFx0LnN0eWxlKFwiaGVpZ2h0XCIsaGVpZ2h0K1wicHhcIilcblx0XHRcdC5hcHBlbmQoXCJzdmdcIik7XG5cblx0XHQvLyBndWl0YXJIZXJvT3V0bGluZS5hcHBlbmQoXCJyZWN0XCIpXG5cdFx0Ly8gXHQuYXR0cihcInhcIixcIjBcIilcblx0XHQvLyBcdC5hdHRyKFwieVwiLGhlaWdodC0zMC0xKVxuXHRcdC8vIFx0LmF0dHIoXCJoZWlnaHRcIiwzMClcblx0XHQvLyBcdC5hdHRyKFwid2lkdGhcIixcIjEwMCVcIilcblx0XHQvLyBcdDtcblxuXHRcdHN2Zy5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKVxuXHQgICAgICAuYXR0cihcImlkXCIsIFwid2hpdGUtZmFkZVwiKVxuXHQgICAgICAuYXR0cihcImdyYWRpZW50VW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKVxuXHQgICAgICAuYXR0cihcIngxXCIsIDApXG5cdFx0XHRcdC5hdHRyKFwieTFcIiwgLTQwMClcblx0ICAgICAgLmF0dHIoXCJ4MlwiLCBcIjIwJVwiKVxuXHRcdFx0XHQuYXR0cihcInkyXCIsIGhlaWdodC0zMClcblx0ICAgICAgLnNlbGVjdEFsbChcInN0b3BcIilcblx0ICAgICAgICAuZGF0YShbXG5cdFx0XHRcdFx0XHR7b2Zmc2V0OigwKStcIiVcIixjb2xvcjpcInJnYmEoMjU1LDI1NSwyNTUsMC4wKVwifSxcblx0XHRcdFx0XHRcdHtvZmZzZXQ6KDEwMCkrXCIlXCIsY29sb3I6XCJyZ2JhKDI1NSwyNTUsMjU1LDEpXCJ9XG5cdFx0XHRcdFx0XVxuXHRcdFx0XHQpXG5cdCAgICAgIC5lbnRlcigpLmFwcGVuZChcInN0b3BcIilcblx0ICAgICAgICAuYXR0cihcIm9mZnNldFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLm9mZnNldDsgfSlcblx0ICAgICAgICAuYXR0cihcInN0b3AtY29sb3JcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5jb2xvcjsgfSk7XG5cblxuXHRcdHN2Zy5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKVxuXHQgICAgICAuYXR0cihcImlkXCIsIFwieWVsbG93LWZhZGVcIilcblx0ICAgICAgLmF0dHIoXCJncmFkaWVudFVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIilcblx0ICAgICAgLmF0dHIoXCJ4MVwiLCAwKVxuXHRcdFx0XHQuYXR0cihcInkxXCIsIC00MDApXG5cdCAgICAgIC5hdHRyKFwieDJcIiwgXCIyMCVcIilcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCBoZWlnaHQtMzApXG5cdCAgICAgIC5zZWxlY3RBbGwoXCJzdG9wXCIpXG5cdCAgICAgICAgLmRhdGEoW1xuXHRcdFx0XHRcdFx0e29mZnNldDooMCkrXCIlXCIsY29sb3I6XCJyZ2IoMjU1LDE5Myw3KVwiLG9wYWNpdHk6IDB9LFxuXHRcdFx0XHRcdFx0e29mZnNldDooMTAwKStcIiVcIixjb2xvcjpcInJnYigyNTUsMTkzLDcpXCIsb3BhY2l0eTogLjJ9XG5cdFx0XHRcdFx0XVxuXHRcdFx0XHQpXG5cdCAgICAgIC5lbnRlcigpLmFwcGVuZChcInN0b3BcIilcblx0ICAgICAgICAuYXR0cihcIm9mZnNldFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLm9mZnNldDsgfSlcblx0ICAgICAgICAuYXR0cihcInN0b3AtY29sb3JcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5jb2xvcjsgfSlcblx0XHRcdFx0XHQuYXR0cihcInN0b3Atb3BhY2l0eVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLm9wYWNpdHk7IH0pO1xuXG5cdFx0Z3VpdGFySGVyb091dGxpbmUuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0LmF0dHIoXCJ4XCIsMClcblx0XHRcdC5hdHRyKFwid2lkdGhcIixcIjIwJVwiKVxuXHRcdFx0LmF0dHIoXCJ5XCIsLTQwMClcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdHJldHVybiA0MDAraGVpZ2h0LTMwO1xuXHRcdFx0fSlcblx0XHRcdC5zdHlsZShcImZpbGxcIixcInVybCgjeWVsbG93LWZhZGUpXCIpO1xuXG5cdFx0Z3VpdGFySGVyb091dGxpbmUuc2VsZWN0QWxsKFwibGluZVwiKVxuXHRcdFx0LmRhdGEoZDMucmFuZ2UoNikpXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcImxpbmVcIilcblx0XHRcdC5hdHRyKFwieDFcIixmdW5jdGlvbihkLGkpe1xuXHRcdFx0XHRpZihpPT0wKXtcblx0XHRcdFx0XHRyZXR1cm4gMVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGk9PTUpe1xuXHRcdFx0XHRcdHJldHVybiBcIjEwMCVcIlxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBpKjIwK1wiJVwiXG5cdFx0XHR9KVxuXHRcdFx0LmF0dHIoXCJ4MlwiLGZ1bmN0aW9uKGQsaSl7XG5cdFx0XHRcdGlmKGk9PTApe1xuXHRcdFx0XHRcdHJldHVybiAxXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoaT09NSl7XG5cdFx0XHRcdFx0cmV0dXJuIFwiMTAwJVwiXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGkqMjArXCIlXCJcblx0XHRcdH0pXG5cdFx0XHQuYXR0cihcInkxXCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdHJldHVybiAtNDAwXG5cdFx0XHR9KVxuXHRcdFx0LmF0dHIoXCJ5MlwiLGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRyZXR1cm4gaGVpZ2h0LTMwLTFcblx0XHRcdH0pXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIixcInVybCgjd2hpdGUtZmFkZSlcIik7XG5cblx0XHRcdDtcblxuXG5cblxuXHRcdC8vIGJ1aWxkIGZhY2VzXG5cdCAgZmFjZXMgPSBkMy5zZWxlY3QoXCIuY2hhcnRcIikuYXBwZW5kKFwiZGl2XCIpXG5cdCAgICAuYXR0cihcImlkXCIsXCJmYWNlc1wiKVxuXHQgICAgO1xuXG5cdFx0ZmFjZSA9IGZhY2VzLmFwcGVuZChcImRpdlwiKS5hdHRyKFwiY2xhc3NcIixcImZhY2UtY29udGFpbmVyXCIpXG5cdFx0XHQuc2VsZWN0QWxsKFwiLmZhY2VcIilcblx0XHRcdC5kYXRhKGZpbHRlcmVkRGF0YSwgZnVuY3Rpb24oZCl7XG5cdFx0XHRcdHJldHVybiBkLmtleTtcblx0XHRcdH0pXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcImRpdlwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLFwiZmFjZSB0ay1mdXR1cmEtcHRcIilcblx0XHRcdC5zdHlsZShcImJhY2tncm91bmQtaW1hZ2VcIiwgZnVuY3Rpb24oZCl7XG5cdFx0XHRcdHZhciBkYXRhID0gZDtcblx0XHRcdFx0cmV0dXJuIGZhY2VCYWNrZ3JvdW5kSW1hZ2UoZGF0YSk7XG5cdFx0XHR9KVxuXHRcdFx0LnN0eWxlKFwiYm9yZGVyLWNvbG9yXCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdHJldHVybiBmYWNlQm9yZGVyKGQpO1xuXHRcdFx0fSlcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIixmdW5jdGlvbihkKXtcblx0XHRcdFx0dmFyIGRhdGEgPSBkO1xuXHRcdFx0XHRyZXR1cm4gZmFjZU9wYWNpdHkoZGF0YSk7XG5cdFx0XHR9KVxuXHRcdFx0LnN0eWxlKFwidG9wXCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdHJldHVybiBmYWNlVG9wKGQpO1xuXHRcdFx0fSlcblx0XHRcdC5zdHlsZShcImxlZnRcIixmdW5jdGlvbihkKXtcblx0XHRcdFx0dmFyIGRhdGEgPSBkO1xuXHRcdFx0XHRyZXR1cm4gZmFjZUxlZnQoZGF0YSk7XG5cdFx0XHR9KVxuXHRcdFx0LnN0eWxlKFwid2lkdGhcIixmYWNlU2l6ZStcInB4XCIpXG5cdFx0XHQuc3R5bGUoXCJoZWlnaHRcIixmYWNlU2l6ZStcInB4XCIpXG5cdFx0XHQub24oXCJtb3VzZW92ZXJcIixmdW5jdGlvbihkKXtcblx0XHRcdFx0dmFyIGRhdGEgPSBkO1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IGQzLnNlbGVjdCh0aGlzKTtcblx0XHRcdFx0ZmFjZU1vdXNlT3ZlcihkYXRhLGVsZW1lbnQpO1xuXHRcdFx0fSlcblxuXHRcdGZhY2Vcblx0XHRcdC5hcHBlbmQoXCJwXCIpXG5cdFx0XHQuYXBwZW5kKFwic3BhblwiKVxuXHRcdFx0LnRleHQoZnVuY3Rpb24oZCl7XG5cdFx0XHRcdHZhciB0aXRsZSA9IGQudHJhY2tfaW5mby50aXRsZTtcblx0XHRcdFx0aWYodGl0bGUubGVuZ3RoID4gMjApe1xuXHRcdFx0XHRcdHJldHVybiB0aXRsZS5zbGljZSgwLDE3KStcIi4uLlwiXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRpdGxlO1xuXHRcdFx0fSlcblx0XHRcdDtcblxuXG5cdFx0bGluZXMgPSBmYWNlcy5hcHBlbmQoXCJkaXZcIikuYXR0cihcImNsYXNzXCIsXCJkYXRlLWxpbmVzLWNvbnRhaW5lclwiKVxuXHRcdFx0LnNlbGVjdEFsbChcImRpdlwiKVxuXHRcdFx0LmRhdGEoZGF0ZXMpXG5cdFx0XHQuZW50ZXIoKVxuXHRcdFx0LmFwcGVuZChcImRpdlwiKVxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLFwiZGF0ZS1saW5lXCIpXG5cdFx0XHQuc3R5bGUoXCJ0b3BcIixmdW5jdGlvbihkKXtcblx0XHRcdFx0cmV0dXJuIHgoZCkrXCJweFwiO1xuXHRcdFx0fSlcblx0XHRcdC5zdHlsZShcImRpc3BsYXlcIixmdW5jdGlvbihkKXtcblx0XHRcdFx0dmFyIGRhdGUgPSArdW5QYXJzZShkKS5yZXBsYWNlKFwiLVwiLFwiXCIpLnJlcGxhY2UoXCItXCIsXCJcIik7XG5cdFx0XHRcdGlmKHdlZWtzRm9yRGF0ZUxpbmVzLmluZGV4T2YoZGF0ZSkgPiAtMSl7XG5cdFx0XHRcdFx0cmV0dXJuIFwiYmxvY2tcIlxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0pXG5cblx0XHRsaW5lc1xuXHRcdFx0LmFwcGVuZChcInBcIilcblx0XHRcdC5odG1sKGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRyZXR1cm4gbmljZVBhcnNlVGhyZWUoZCk7XG5cdFx0XHR9KVxuXHRcdFx0O1xuXG5cblxuXG5cdCAgLy8gdmFyIGNoYXJ0Q29udGFpbmVyID0gZDMuc2VsZWN0KFwiLmNoYXJ0XCIpXG5cdCAgLy8gICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKXtcblx0XHQvLyBcdFx0Y29uc29sZS5sb2coJ21vdXNlb3ZlcicpXG5cdCAgLy8gICAgIGlmKCFwbGF5aW5nKXtcblx0ICAvLyAgICAgICBwYXVzZVBsYXkuc3R5bGUoXCJvcGFjaXR5XCIsMSk7XG5cdCAgLy8gICAgIH1cblx0ICAvLyAgIH0pXG5cdCAgLy8gICAub24oXCJtb3VzZW91dFwiLGZ1bmN0aW9uKCl7XG5cdCAgLy8gICAgIGlmKCFwbGF5aW5nKXtcblx0ICAvLyAgICAgICBwYXVzZVBsYXkuc3R5bGUoXCJvcGFjaXR5XCIsMCk7XG5cdCAgLy8gICAgIH1cblx0ICAvLyAgIH0pXG5cdCAgLy8gICA7XG5cblx0ICB2YXIgdGV4dExlZnRPZmZzZXQgPSAyNDA7XG5cblx0ICB2YXIgc3ZnVHdvID0gZDMuc2VsZWN0KFwiLmNoYXJ0XCIpLmFwcGVuZChcInN2Z1wiKVxuXHQgICAgLmF0dHIoXCJjbGFzc1wiLFwidGV4dC1jb250YWluZXJcIilcblx0ICAgIC5hcHBlbmQoXCJnXCIpXG5cdCAgICAuYXR0cihcImNsaXAtcGF0aFwiLCBcInVybCgjY2xpcClcIilcblx0ICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKCl7XG5cdCAgICAgIHZhciBtYXJnaW5Ub3AgPSBtYXJnaW4udG9wO1xuXHQgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0ZXh0TGVmdE9mZnNldCArIFwiLFwiICsgbWFyZ2luVG9wICsgXCIpXCI7XG5cdCAgICB9KVxuXHQgICAgO1xuXG5cdCAgdmFyIGNsaWNrUGxheVRpcCA9IGQzLnNlbGVjdChcIi5jbGljay10by1wbGF5XCIpO1xuXG5cdCAgdmFyIHRyYWNrTGVnZW5kID0gZDMuc2VsZWN0KFwiLnRyYWNrLWxlZ2VuZFwiKS5zZWxlY3RBbGwoXCJkaXZcIik7XG5cblx0ICB2YXIgaW50ZXJwb2xhdGVPbmUgPSBkMy5pbnRlcnBvbGF0ZShcIiMwQzBDMENcIixcIiNGRkZGRkZcIik7XG5cblx0XHRmdW5jdGlvbiBmYWNlVG9wKGQpe1xuXHRcdFx0aWYoZGF0ZUFoZWFkIGluIGQubmVzdGVkRGF0ZUFycmF5KXtcblx0XHRcdFx0cmV0dXJuIHgoZGF0ZXNbMV0pK1wicHhcIjtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZihjdXJyZW50RGF0ZSBpbiBkLm5lc3RlZERhdGVBcnJheSB8fCB1blBhcnNlKGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1swXSwgLTcpKSBpbiBkLm5lc3RlZERhdGVBcnJheSB8fCB1blBhcnNlKGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1swXSwgLTE0KSkgaW4gZC5uZXN0ZWREYXRlQXJyYXkpe1xuXHRcdFx0XHRcdHJldHVybiB4KGRhdGVzWzBdKStcInB4XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGNoYXJ0X2RhdGUgPSBkLnZhbHVlc1tkLnZhbHVlcy5sZW5ndGgtMV0uY2hhcnRfZGF0ZTtcblx0XHRcdFx0cmV0dXJuIHgoY2hhcnRfZGF0ZSkrXCJweFwiOyAvL3RoaXMgeCBpcyBub3cgdHJhbnNsYXRpbmcgYmV0d2VlbiAwIGFuZCBoZWlnaHQgd2l0aCBkYXRlIG9uIHktYXhpc1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZhY2VMZWZ0KGQpe1xuXHQgICAgaWYgKGRhdGVBaGVhZCBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdCAgICAgIHZhciByYW5rID0gZC5uZXN0ZWREYXRlQXJyYXlbZGF0ZUFoZWFkXTtcblx0ICAgICAgcmV0dXJuIHkocmFuaykgKyBmYWNlQWRqdXN0ICsgbWFyZ2luLnRvcCArIFwicHhcIjtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHRcdFx0XHRpZih1blBhcnNlKGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1swXSwgLTcpKSBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdFx0XHRcdFx0dmFyIHJhbmsgPSBkLm5lc3RlZERhdGVBcnJheVtjdXJyZW50RGF0ZV07XG5cdFx0XHRcdFx0cmV0dXJuIHkocmFuaykgKyBmYWNlQWRqdXN0ICsgbWFyZ2luLnRvcCArIFwicHhcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcmFuayA9IGQudmFsdWVzW2QudmFsdWVzLmxlbmd0aC0xXS5yYW5rO1xuXHRcdFx0XHRyZXR1cm4geShyYW5rKSArIGZhY2VBZGp1c3QgKyBtYXJnaW4udG9wICsgXCJweFwiO1xuXHQgICAgfVxuXHRcdH1cblxuXHQgIGZ1bmN0aW9uIGZhY2VUb3BQb3NpdGlvbihkKXtcblx0ICAgIGlmIChkYXRlQWhlYWQgaW4gZC5uZXN0ZWREYXRlQXJyYXkpe1xuXHQgICAgICB2YXIgcmFuayA9IGQubmVzdGVkRGF0ZUFycmF5W2RhdGVBaGVhZF07XG5cdCAgICAgIHJldHVybiB5KHJhbmspICsgZmFjZUFkanVzdCArIG1hcmdpbi50b3AgKyBcInB4XCI7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHdpZHRoICsgMTAwICsgXCJweFwiO1xuXHQgICAgfVxuXHQgIH1cblx0ICA7XG5cblx0ICBmdW5jdGlvbiBmYWNlQmFja2dyb3VuZEltYWdlKGQpe1xuXHQgICAgaWYoZFtcInRyYWNrX2luZm9cIl1bXCJhcnRpc3RfdXJsXCJdID09IFwiTlVMTFwiKXtcblx0ICAgICAgcmV0dXJuIG51bGxcblx0ICAgIH1cblx0ICAgIHJldHVybiBcInVybChodHRwczovL2kuc2Nkbi5jby9pbWFnZS9cIitkW1widHJhY2tfaW5mb1wiXVtcImFydGlzdF91cmxcIl0rXCIpXCJcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBmYWNlT3BhY2l0eShkKXtcblx0XHRcdGlmKGRhdGVBaGVhZCBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmKHVuUGFyc2UoZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzWzBdLCAtNykpIGluIGQubmVzdGVkRGF0ZUFycmF5IHx8IHVuUGFyc2UoZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzWzBdLCAtMTQpKSBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodW5QYXJzZShkYXRlc1syXSkgaW4gZC5uZXN0ZWREYXRlQXJyYXkgfHwgdW5QYXJzZShkYXRlc1szXSkgaW4gZC5uZXN0ZWREYXRlQXJyYXkgfHwgdW5QYXJzZShkYXRlc1s0XSkgaW4gZC5uZXN0ZWREYXRlQXJyYXkpe1xuXHRcdFx0XHRcdHJldHVybiAuODtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihkYXRlc1swXSA+IGQzLm1heChkLnZhbHVlcywgZnVuY3Rpb24oZCl7IHJldHVybiBkLmNoYXJ0X2RhdGV9KSl7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZXtcblx0XHRcdFx0XHRyZXR1cm4gLjFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHQgIH1cblxuXHRcdGZ1bmN0aW9uIGZhY2VEaXNwbGF5KGQpe1xuXHRcdFx0aWYoZGF0ZUFoZWFkIGluIGQubmVzdGVkRGF0ZUFycmF5KXtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYodW5QYXJzZShkMy50aW1lLmRheS5vZmZzZXQoZGF0ZXNbMF0sIC03KSkgaW4gZC5uZXN0ZWREYXRlQXJyYXkgfHwgdW5QYXJzZShkMy50aW1lLmRheS5vZmZzZXQoZGF0ZXNbMF0sIC0xNCkpIGluIGQubmVzdGVkRGF0ZUFycmF5KXtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih1blBhcnNlKGRhdGVzWzJdKSBpbiBkLm5lc3RlZERhdGVBcnJheSB8fCB1blBhcnNlKGRhdGVzWzNdKSBpbiBkLm5lc3RlZERhdGVBcnJheSB8fCB1blBhcnNlKGRhdGVzWzRdKSBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZGF0ZXNbMF0gPiBkMy5tYXgoZC52YWx1ZXMsIGZ1bmN0aW9uKGQpeyByZXR1cm4gZC5jaGFydF9kYXRlfSkpe1xuXHRcdFx0XHRcdHJldHVybiBcIm5vbmVcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNle1xuXHRcdFx0XHRcdHJldHVybiBcIm5vbmVcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHQgIH1cblxuXHQgIHZhciBiaW9OYW1lID0gZDMuc2VsZWN0KFwiLmJpby1uYW1lXCIpO1xuXHQgIHZhciBiaW9UZXh0ID0gZDMuc2VsZWN0KFwiLmJpby1pbmZvXCIpO1xuXG5cdFx0dmFyIHBhdXNlUGxheSA9IGQzLnNlbGVjdEFsbChcIi5wYXVzZWQtcGxheS1idXR0b25cIilcblx0ICAgIC5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtcblx0ICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIixcIm5vbmVcIik7XG5cdCAgICAgIGQzLnNlbGVjdChcIi5wYXVzZS1zZWN0aW9uXCIpLnN0eWxlKFwiZGlzcGxheVwiLFwiaW5pdGlhbFwiKTtcblx0ICAgICAgcmV0dXJuUGF0aCgpO1xuXHQgICAgfSlcblx0ICAgIDtcblxuXHQgIHZhciBzZWFyY2hBcnJheSA9IFtdO1xuXHQgIHZhciBzZWFyY2hSZXN1bHRzID0gZDMuc2VsZWN0KFwiLnNlYXJjaC1yZXN1bHRzLW5ld1wiKTtcblx0ICB2YXIgc2VhcmNoUmVzdWx0TW91c2VPdmVyID0gZmFsc2U7XG5cblx0ICBmdW5jdGlvbiBhcnRpc3RDbGVhbihhcnRpc3Qpe1xuXHQgICAgcmV0dXJuIGFydGlzdC5zcGxpdChcIiBGZWF0dXJpbmdcIilbMF07XG5cdCAgfVxuXG5cdCAgdmFyIHNhbXBsZVJvdGF0ZTtcblxuXHRcdC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgZXZlbnQgPT4ge1xuXHQgIC8vICAgY29uc3QgZGVsdGEgPSBNYXRoLnNpZ24oZXZlbnQuZGVsdGFZKTtcblx0XHQvLyBcdGlmKE1hdGgucm91bmQoZXZlbnQudGltZVN0YW1wKSAlIDIgPT0gMCl7XG5cdFx0Ly8gXHRcdHRlc3RTY3JvbGwoZGVsdGEpO1xuXHRcdC8vIFx0fVxuXHRcdC8vIH0pO1xuXG5cdFx0dmFyIHRpbWVvdXRTY3JvbGwgPSBudWxsO1xuXG5cdFx0ZnVuY3Rpb24gdGVzdFNjcm9sbChkaXJlY3Rpb24pe1xuXG5cdFx0XHRpZihwbGF5aW5nKXtcblx0XHRcdFx0bW92ZUNoYXJ0KFwic3RvcFwiKVxuXHRcdFx0fVxuXG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRTY3JvbGwpO1xuXG5cdFx0XHR0aW1lb3V0U2Nyb2xsID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oZCl7XG5cblx0XHRcdFx0ZmFjZVxuXHRcdCAgICAgIC5zdHlsZShcImJhY2tncm91bmQtaW1hZ2VcIiwgZnVuY3Rpb24oZCl7XG5cdFx0ICAgICAgICBpZihkW1widHJhY2tfaW5mb1wiXVtcImFydGlzdF91cmxcIl0gPT0gXCJOVUxMXCIpe1xuXHRcdCAgICAgICAgICByZXR1cm4gbnVsbFxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYoZFtcInRyYWNrX2luZm9cIl1bXCJhcnRpc3RfdXJsXCJdID09IFwibWFudWFsXCIpe1xuXHRcdCAgICAgICAgICB2YXIgaG9zdFVybCA9IGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbjtcblx0XHQgICAgICAgICAgdmFyIHBhdGhVcmwgPSBkb2N1bWVudC5sb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKFwiaW5kZXguaHRtbFwiLFwiXCIpO1xuXHRcdCAgICAgICAgICB2YXIgaWRTb25nID0gbmVzdGVkRGF0ZXNUd29bdW5QYXJzZShkMy50aW1lLmRheS5vZmZzZXQoZGF0ZXNbZGF0ZXMubGVuZ3RoLTFdLCA3KSldW1widHJhY2tcIl07XG5cdFx0ICAgICAgICAgIG5leHRTb25nID0gaG9zdFVybCtwYXRoVXJsK1widXJsL1wiK2lkU29uZyArIFwiLm00YVwiXG5cdFx0ICAgICAgICAgIHJldHVybiBcInVybChcIituZXh0U29uZytcIilcIjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBcInVybChodHRwczovL2kuc2Nkbi5jby9pbWFnZS9cIitkW1widHJhY2tfaW5mb1wiXVtcImFydGlzdF91cmxcIl0rXCIpXCJcblx0XHQgICAgICB9KVxuXG5cdFx0XHRcdG1vdmVDaGFydChkYXRlc1swXS5nZXRUaW1lKCkpXG5cblx0XHRcdH0sMTAwMClcblxuXHRcdFx0Zm9yICh2YXIgaSBpbiBkYXRlcyl7XG5cdCAgICAgIGRhdGVzW2ldID0gZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzW2ldLCA3KmRpcmVjdGlvbik7XG5cdCAgICB9O1xuXG5cdFx0XHRjdXJyZW50RGF0ZSA9IHVuUGFyc2UoZGF0ZXNbMF0pO1xuXHRcdFx0ZGF0ZUFoZWFkID0gdW5QYXJzZShkMy50aW1lLmRheS5vZmZzZXQoZGF0ZXNbMF0sIDcpKTtcblx0XHRcdHR3b0RhdGVzQWhlYWQgPSB1blBhcnNlKGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1swXSwgMTQpKTtcblxuXHRcdFx0Y2hhbmdlWWVhcihcInNjcm9sbFwiKTtcblxuXHRcdFx0eC5kb21haW4oW2RhdGVzWzBdLCBkYXRlc1tkYXRlcy5sZW5ndGgtMV1dKTtcblxuXHRcdFx0ZmFjZVxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0cmV0dXJuIGZhY2VPcGFjaXR5KGQpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5zdHlsZShcIndpZHRoXCIsZmFjZVNpemUrXCJweFwiKVxuXHRcdFx0XHQuc3R5bGUoXCJoZWlnaHRcIixmYWNlU2l6ZStcInB4XCIpXG5cdFx0XHRcdC5zdHlsZShcImJvcmRlci1jb2xvclwiLGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRcdHJldHVybiBmYWNlQm9yZGVyKGQpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuc3R5bGUoXCJ0b3BcIixmdW5jdGlvbihkKXtcblx0XHRcdFx0XHRyZXR1cm4gZmFjZVRvcChkKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnN0eWxlKFwibGVmdFwiLGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRcdHZhciBkYXRhID0gZDtcblx0XHRcdFx0XHRyZXR1cm4gZmFjZUxlZnQoZGF0YSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdDtcblxuXHRcdFx0bGluZXNcblx0XHRcdFx0LnN0eWxlKFwidG9wXCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0cmV0dXJuIHgoZCkrXCJweFwiO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsZnVuY3Rpb24oZCxpKXtcblx0XHRcdFx0XHRpZihpPT0wKXtcblx0XHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0O1xuXG5cdFx0XHRkMy5zZWxlY3QoXCIuZGF0ZS1saW5lcy1jb250YWluZXJcIilcblx0XHRcdFx0LnN0eWxlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDBweCxcIisgeChkMy50aW1lLmRheS5vZmZzZXQoZGF0ZXNbZGF0ZXMubGVuZ3RoLTFdLCA3KSkgKyBcInB4KVwiKVxuXHRcdFx0XHQ7XG5cblx0XHRcdHBhdGhcblx0XHRcdC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKXtcblx0XHRcdFx0XHQvL3JldHVybiBsaW5lRnVuY3Rpb24oZC52YWx1ZXMpO1xuXHRcdFx0XHRcdHJldHVybiBsaW5lKGQudmFsdWVzKTtcblx0XHRcdFx0XHRyZXR1cm4gbGluZShnZXRQYXRoV2Vla3MoZCkpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBkO1xuXHRcdFx0XHRcdHJldHVybiBwYXRoU3Ryb2tlKGRhdGEpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRcdHZhciBkYXRhID0gZDtcblx0XHRcdFx0XHRyZXR1cm4gcGF0aE9wYWNpdHkoZGF0YSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBmdW5jdGlvbihkKXtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IGQ7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdGhTdHJva2VXaWR0aChkYXRhKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oZCxpKXtcblx0XHRcdFx0XHRpZiAoZGF0ZUFoZWFkIGluIGQubmVzdGVkRGF0ZUFycmF5KXtcblx0XHRcdFx0XHRcdHZhciByYW5rID0gZC5uZXN0ZWREYXRlQXJyYXlbZGF0ZUFoZWFkXTtcblx0XHRcdFx0XHRcdGlmKHJhbms9PTEpe1xuXHRcdFx0XHRcdFx0XHRjbG9uZShkMy5zZWxlY3QodGhpcykpLmF0dHIoJ2ZpbHRlcicsICd1cmwoI2JsdXJyZWQpJykuc3R5bGUoXCJzdHJva2VcIixjb2xvclNjaGVtZVswXSkuYXR0cihcImlkXCIsXCJnbG93XCIpLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsJzEwcHgnKS5zdHlsZShcIm9wYWNpdHlcIiwxKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZXtcblx0XHRcdFx0XHRcdFx0Y2xvbmUoZDMuc2VsZWN0KHRoaXMpKVxuXHRcdFx0XHRcdFx0XHRcdC8vLmF0dHIoJ2ZpbHRlcicsICd1cmwoI2JsdXJyZWRUd28pJylcblx0XHRcdFx0XHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIixcIiMyYTI5MmZcIikuYXR0cihcImlkXCIsXCJnbG93XCIpLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsJzZweCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0O1xuXG5cdFx0XHRkMy5zZWxlY3QoXCIucGF0aC1jb250YWluZXJcIikuc2VsZWN0QWxsKFwicGF0aFwiKVxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLDApXCIpXG5cblx0XHRcdFx0Ly8uYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiKyB4KGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1tkYXRlcy5sZW5ndGgtMV0sIDcpKSArIFwiKVwiKVxuXG5cblx0XHRcdC8vIGQzLnNlbGVjdChcIi5wYXRoLWNvbnRhaW5lclwiKS5zZWxlY3RBbGwoXCJwYXRoXCIpXG5cdFx0XHQvLyBcdC50cmFuc2l0aW9uKClcblx0XHRcdC8vIFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwwKVwiKVxuXHRcdFx0Ly8gXHQ7XG5cblxuXHQgIH07XG5cblx0XHQvLyBkMy5zZWxlY3QoXCJib2R5XCIpLm9uKFwiY2xpY2tcIixmdW5jdGlvbihkKXtcblx0XHQvLyBcdGNvbnNvbGUubG9nKFwiaGVyZVwiKTtcblx0XHQvLyBcdHRlc3RTY3JvbGwoXCJoaVwiKTtcblx0XHQvLyB9KVxuXG5cblx0XHRmdW5jdGlvbiBtb3ZlQ2hhcnQoZCl7XG5cblx0ICAgIGlmKHBsYXlpbmc9PXRydWUpe1xuXHQgICAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbi50cmFuc2l0aW9uKDApLmR1cmF0aW9uKDApO1xuXG5cdFx0XHRcdGdsb2JhbEdhaW4uZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoY29udGV4dC5jdXJyZW50VGltZSk7XG5cdFx0XHRcdGdsb2JhbEdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLGNvbnRleHQuY3VycmVudFRpbWUpXG5cblx0XHRcdFx0Ly8gaWYgKCBzb3VyY2UgKSB7XG5cdFx0XHRcdC8vIFx0aWYoIXNvdXJjZS5zdG9wKXtcblx0XHRcdFx0Ly8gXHRcdHNvdXJjZS5zdG9wID0gc291cmNlLm5vdGVPZmY7XG5cdFx0XHRcdC8vIFx0fVxuXHRcdFx0XHQvLyB9XG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGlmICggbGFzdFNvdXJjZSApIHtcblx0XHRcdFx0Ly8gXHRpZighbGFzdFNvdXJjZS5zdG9wKXtcblx0XHRcdFx0Ly8gXHRcdGxhc3RTb3VyY2Uuc3RvcCA9IGxhc3RTb3VyY2Uubm90ZU9mZjtcblx0XHRcdFx0Ly8gXHR9XG5cdFx0XHRcdC8vIFx0bGFzdFNvdXJjZS5zdG9wKDApO1xuXHRcdFx0XHQvLyB9XG5cdCAgICB9XG5cdFx0XHRpZihkID09IFwic3RvcFwiKXtcblx0XHRcdFx0cGxheWluZyA9IGZhbHNlO1xuXHRcdFx0XHRkMy5zZWxlY3QoXCIucGxheS1idXR0b25cIikuc3R5bGUoXCJkaXNwbGF5XCIsXCJibG9ja1wiKTtcblx0XHRcdFx0ZDMuc2VsZWN0KFwiLnBhdXNlLWJ1dHRvblwiKS5zdHlsZShcImRpc3BsYXlcIixcIm5vbmVcIik7XG5cdFx0XHRcdC8vIGxpbmVzLnRyYW5zaXRpb24oKS5kdXJhdGlvbigwKTtcblx0XHRcdFx0Ly8gZmFjZS50cmFuc2l0aW9uKCkuZHVyYXRpb24oMCk7XG5cdFx0XHRcdC8vIHBhdGgudHJhbnNpdGlvbigpLmR1cmF0aW9uKDApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihkICE9IFwic3RvcFwiKXtcblx0XHRcdFx0cGxheWluZyA9IHRydWU7XG5cdFx0XHRcdGQzLnNlbGVjdChcIi5wbGF5LWJ1dHRvblwiKS5zdHlsZShcImRpc3BsYXlcIixudWxsKTtcblx0XHRcdFx0ZDMuc2VsZWN0KFwiLnBhdXNlLWJ1dHRvblwiKS5zdHlsZShcImRpc3BsYXlcIixudWxsKTtcblxuXHRcdCAgICB2YXIgZGF0ZVNlbGVjdGVkID0gbmV3IERhdGUoK2QpO1xuXHRcdFx0XHR2YXIgZ29hbCA9IG51bVBhcnNlKGRhdGVTZWxlY3RlZCk7XG5cdFx0XHRcdHZhciBjbG9zZXN0ID0gd2Vla3NGb3JEYXRlTGluZXMucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cnIpIHtcblx0ICBcdFx0XHRyZXR1cm4gKE1hdGguYWJzKGN1cnIgLSBnb2FsKSA8IE1hdGguYWJzKHByZXYgLSBnb2FsKSA/IGN1cnIgOiBwcmV2KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly9pbnRlcmF0ZSB0aHJvdWdoIDE3IHdlZWtzIGJ5IGFkZGluZyA3IHRvIHRoZSBzdGFydCBkYXlcblxuXHRcdFx0XHRkYXRlcyA9IFtudW1QYXJzZURhdGUoSlNPTi5zdHJpbmdpZnkoY2xvc2VzdCkpXTtcblx0XHRcdFx0dmFyIGk7XG5cdFx0XHRcdGZvciAoaT0wOyBpPG47IGkrKyl7XG5cdFx0XHRcdCAgdmFyIGxlbmd0aCAgPSBkYXRlcy5sZW5ndGg7XG5cdFx0XHRcdCAgdmFyIGRhdGUgPSBkMy50aW1lLmRheS5vZmZzZXQoZGF0ZXNbbGVuZ3RoIC0gMV0sNyk7XG5cdFx0XHRcdCAgZGF0ZXMucHVzaChkYXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkYXRlQWhlYWQgPSB1blBhcnNlKGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1swXSwgNykpO1xuXHRcdFx0XHRsZXQgdHdvRGF0ZXNBaGVhZCA9IHVuUGFyc2UoZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzWzBdLCAxNCkpO1xuXHRcdFx0XHR2YXIgY3VycmVudERhdGUgPSB1blBhcnNlKGRhdGVzWzBdKTtcblxuXHRcdFx0XHR4LmRvbWFpbihbZGF0ZXNbMF0sIGRhdGVzW2RhdGVzLmxlbmd0aC0xXV0pO1xuXG5cdFx0ICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGlja0RlbGF5KTtcblxuXHRcdCAgICB0aWNrRGVsYXkgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cblx0XHQgICAgICBpZigxIDwgMil7XG5cblx0XHQgICAgICAgIGZvciAoaT0xOyBpPDIwOyBpKyspe1xuXHRcdCAgICAgICAgICB2YXIgdGltZU9uZSA9IGRhdGVzWzFdO1xuXHRcdCAgICAgICAgICB2YXIgdGltZVR3byA9IGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1sxXSwgNyppKTtcblxuXHRcdCAgICAgICAgICBpZihuZXN0ZWREYXRlc1R3b1t1blBhcnNlKHRpbWVPbmUpXVtcInRyYWNrXCJdICE9IG5lc3RlZERhdGVzVHdvW3VuUGFyc2UodGltZVR3byldW1widHJhY2tcIl0pe1xuXHRcdCAgICAgICAgICAgIHBsYXlMZW5ndGggPSBNYXRoLm1heCgoaS0xKSAqIHNoaWZ0RHVyYXRpb24sc2hpZnREdXJhdGlvbik7XG5cdFx0ICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblxuXHRcdCAgICAgICAgdmFyIGN1cnJUaW1lID0gY29udGV4dC5jdXJyZW50VGltZTtcblxuXHRcdCAgICAgICAgdmFyIGN1cnJTb25nO1xuXHRcdCAgICAgICAgdmFyIHByZXZpZXdJdGVtSWQgPSBuZXN0ZWREYXRlc1R3b1t1blBhcnNlKGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1sxXSwgMCkpXVtcInByZXZpZXdcIl07XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhwcmV2aWV3SXRlbUlkKVxuXHRcdCAgICAgICAgY3VyclNvbmcgPSBcImh0dHBzOi8vcC5zY2RuLmNvL21wMy1wcmV2aWV3L1wiICsgcHJldmlld0l0ZW1JZFxuXG5cdFx0ICAgICAgICBzdGFydFRpbWUgPSBjdXJyVGltZSArIDE7XG5cdFx0ICAgICAgICBsb2FkU291bmRzKGN1cnJTb25nLCBwbGF5TGVuZ3RoLCBzdGFydFRpbWUsIFwibm93XCIpO1xuXG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIHRyYW5zaXRpb24gPSBkMy5zZWxlY3Qoe30pLnRyYW5zaXRpb24oKVxuXHRcdCAgICAgICAgICAuZHVyYXRpb24oc2hpZnREdXJhdGlvbilcblx0XHQgICAgICAgICAgLmVhc2UoXCJsaW5lYXJcIik7XG5cblxuXHRcdCAgICAgIHRpY2soKTtcblxuXHRcdCAgICB9LCAxMDApO1xuXHRcdFx0fVxuXHQgIH07XG5cblxuXG5cblx0ICBmdW5jdGlvbiB0ZXh0RmlsbChkKXtcblx0ICAgIHZhciByYW5rID0gZC5uZXN0ZWREYXRlQXJyYXlbY3VycmVudERhdGVdO1xuXHQgICAgaWYgKHJhbmsgPT0gMSl7XG5cdCAgICAgIHJldHVybiBjb2xvclR3bztcblx0ICAgIH1cblx0ICAgIGVsc2V7XG5cdCAgICAgIHJldHVybiB0ZXh0Q29sb3I7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcGF0aFN0cm9rZShkKXtcblxuXHRcdFx0aWYgKGRhdGVBaGVhZCBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdFx0XHRcdHZhciByYW5rID0gZC5uZXN0ZWREYXRlQXJyYXlbZGF0ZUFoZWFkXTtcblx0XHRcdFx0cmV0dXJuIFwidXJsKCN0ZW1wZXJhdHVyZS1ncmFkaWVudClcIjtcblxuXHRcdFx0XHRpZihyYW5rPT0xKXtcblx0XHRcdFx0XHRyZXR1cm4gXCJyZWRcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNle1xuXHRcdFx0XHQgIHJldHVybiBcInVybCgjdGVtcGVyYXR1cmUtZ3JhZGllbnQpXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZihyYW5rPT0yKXtcblx0XHRcdFx0Ly8gXHRyZXR1cm4gXCJibHVlXCI7XG5cdFx0XHRcdC8vIH1cblx0XHRcdFx0Ly8gaWYocmFuaz09Myl7XG5cdFx0XHRcdC8vIFx0cmV0dXJuIFwiZ3JlZW5cIjtcblx0XHRcdFx0Ly8gfVxuXHRcdFx0XHQvLyBpZihyYW5rPT00KXtcblx0XHRcdFx0Ly8gXHRyZXR1cm4gXCJwdXJwbGVcIjtcblx0XHRcdFx0Ly8gfVxuXHRcdFx0XHQvLyByZXR1cm4gXCJ5ZWxsb3dcIjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBcIm5vbmVcIjtcblxuXHQgICAgLy8gdmFyIHJhbmsgPSBkLm5lc3RlZERhdGVBcnJheVtjdXJyZW50RGF0ZV07XG5cdCAgICAvLyBpZiAocmFuayA9PSAxKXtcblx0ICAgIC8vICAgcmV0dXJuIFwidXJsKCN0ZW1wZXJhdHVyZS1ncmFkaWVudClcIjtcblx0ICAgIC8vICAgLy8gcmV0dXJuIGNvbG9yVHdvO1xuXHQgICAgLy8gfVxuXHQgICAgLy8gZWxzZXtcblx0ICAgIC8vICAgcmV0dXJuIFwidXJsKCN0ZW1wZXJhdHVyZS1ncmFkaWVudClcIjtcblx0ICAgIC8vIH1cblx0ICB9XG5cblx0XHRmdW5jdGlvbiBmYWNlQm9yZGVyKGQpe1xuXHQgICAgaWYgKGRhdGVBaGVhZCBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdCAgICAgIHZhciByYW5rID0gZC5uZXN0ZWREYXRlQXJyYXlbZGF0ZUFoZWFkXTtcblx0XHRcdFx0cmV0dXJuIGNvbG9yU2NoZW1lWzUtcmFua107XG5cdCAgICB9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0XHRmdW5jdGlvbiBmYWNlU2hhZG93KGQpe1xuXHRcdFx0aWYgKGRhdGVBaGVhZCBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdFx0XHRcdHZhciByYW5rID0gZC5uZXN0ZWREYXRlQXJyYXlbZGF0ZUFoZWFkXTtcblx0XHRcdFx0aWYocmFuayA9PSAxKXtcblx0XHRcdFx0XHRyZXR1cm4gXCIxcHggM3B4IDZweCAjODAwMDgwLCAxcHggM3B4IDlweCAjODAwMDgwXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHQgIGZ1bmN0aW9uIHBhdGhPcGFjaXR5KGQpe1xuXHQgICAgaWYgKGRhdGVBaGVhZCBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdCAgICAgIHZhciByYW5rID0gZC5uZXN0ZWREYXRlQXJyYXlbZGF0ZUFoZWFkXTtcblx0ICAgICAgaWYocmFuaz09MSl7XG5cdCAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgIH1cblx0XHRcdFx0aWYocmFuaz09Mil7XG5cdFx0XHRcdFx0cmV0dXJuIC44XG5cdFx0XHRcdH1cblx0ICAgICAgcmV0dXJuIC42O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdFx0ZnVuY3Rpb24gcGF0aFN0cm9rZVdpZHRoKGQpe1xuXHQgICAgaWYgKGRhdGVBaGVhZCBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdCAgICAgIHZhciByYW5rID0gZC5uZXN0ZWREYXRlQXJyYXlbZGF0ZUFoZWFkXTtcblx0ICAgICAgaWYocmFuaz09MSl7XG5cdCAgICAgICAgcmV0dXJuIFwiNHB4XCI7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFwiNHB4XCI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCIxcHhcIjtcblx0ICB9XG5cblx0ICB2YXIgdHJhbnNpdGlvbiA9IGQzLnNlbGVjdCh7fSkudHJhbnNpdGlvbigpXG5cdCAgICAgIC5kdXJhdGlvbihzaGlmdER1cmF0aW9uKVxuXHQgICAgICAuZWFzZShcImxpbmVhclwiKTtcblxuXHQgIHZhciB0aWNrQ291bnQgPSAwO1xuXG5cblx0XHR2YXIgZXh0ZW50RGF0ZXMgPSBkMy5leHRlbnQobmVzdGVkRGF0ZXMsZnVuY3Rpb24oZCl7XG5cdFx0XHRyZXR1cm4gcGFyc2VEYXRlKGQua2V5KTtcblx0XHR9KVxuXG5cdFx0ZXh0ZW50RGF0ZXNbMF0gPSBwYXJzZURhdGUoXCIyMDE5LTAxLTAxXCIpXG5cblx0XHR2YXIgeWVhckFycmF5ID0gW107XG5cdFx0dmFyIHllYXJzRm9yUGlwcyA9IFtcIjIwMTktMDFcIiwgXCIyMDE5LTAzXCIsIFwiMjAxOS0wNlwiLCBcIjIwMTktMDlcIiwgXCIyMDE5LTEyXCJdXG5cblxuXHRcdGZvciAodmFyIGRhdGUgaW4geWVhcnNGb3JQaXBzKXtcblx0XHRcdHZhciBpdGVtcyA9IHRlc3REYXRlcy5nZXQoeWVhcnNGb3JQaXBzW2RhdGVdKTtcblx0XHRcdHZhciBsYXN0ID0gaXRlbXMudmFsdWVzW2l0ZW1zLnZhbHVlcy5sZW5ndGgtMV0uY2hhcnRfZGF0ZS5nZXRUaW1lKClcblx0XHRcdHllYXJBcnJheS5wdXNoKGxhc3QpO1xuXHRcdH1cblx0XHRcblx0XHRjb25zb2xlLmxvZygneWVhckFycmF5Jyx5ZWFyQXJyYXkpXG5cblx0XHRmdW5jdGlvbiB0b0Zvcm1hdFllYXIgKCB2ICkge1xuXHRcdCAgcmV0dXJuIHNpZGVCYXJQYXJzZShuZXcgRGF0ZSgrdikpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRvRm9ybWF0ICggdiApIHtcblx0XHRcdHJldHVybiBuaWNlUGFyc2UobmV3IERhdGUoK3YpKTtcblx0XHR9XG5cblx0XHQvLyBBZGQgYSBmb3JtYXR0ZXIgdG8gdGhlIHNsaWRlclxuXHRcdHZhciBvcmllbnRhdGlvbiA9IFwidmVydGljYWxcIlxuXG5cdFx0aWYodmlld3BvcnRXaWR0aCA8IDcwMCl7XG5cdFx0XHRvcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiXG5cdFx0fVxuXHRcdGNvbnNvbGUubG9nKGV4dGVudERhdGVzKVxuXHRcdHZhciBzbGlkZXJEYXRlcyA9IG5vVWlTbGlkZXIuY3JlYXRlKGQzLnNlbGVjdChcIiNzbGlkZXJcIikubm9kZSgpLCB7XG5cdFx0ICAgIHN0YXJ0OiBbc3RhcnQuZ2V0VGltZSgpXSxcblx0XHRcdFx0c3RlcDogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG5cdFx0ICAgIHJhbmdlOiB7XG5cdFx0ICAgICAgICAnbWluJzogZXh0ZW50RGF0ZXNbMF0uZ2V0VGltZSgpLFxuXHRcdCAgICAgICAgJ21heCc6IGV4dGVudERhdGVzWzFdLmdldFRpbWUoKVxuXHRcdCAgICB9LFxuXHRcdFx0XHRmb3JtYXQ6IHsgdG86IHRvRm9ybWF0LCBmcm9tOiBOdW1iZXIgfSxcblx0XHRcdFx0Y29ubmVjdDogW3RydWUsIGZhbHNlXSxcblx0XHRcdFx0dG9vbHRpcHM6IFt0cnVlXSxcblx0XHRcdFx0b3JpZW50YXRpb246IG9yaWVudGF0aW9uLFxuXHRcdFx0XHRwaXBzOiB7XG5cdFx0XHRcdFx0bW9kZTogJ3ZhbHVlcycsXG5cdFx0XHRcdFx0dmFsdWVzOiB5ZWFyQXJyYXksXG5cdFx0XHRcdFx0ZGVuc2l0eTogNCxcblx0XHRcdFx0XHRzdGVwcGVkOiB0cnVlLFxuXHRcdFx0XHRcdGZvcm1hdDogeyB0bzogdG9Gb3JtYXRZZWFyLCBmcm9tOiBOdW1iZXIgfVxuXHRcdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRzbGlkZXJEYXRlc1xuXHRcdFx0Lm9uKCdzdGFydCcsIGZ1bmN0aW9uICh2YWx1ZXMsIGhhbmRsZSkge1xuXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XG5cdFx0XHR9KTtcblxuXG5cdFx0c2xpZGVyRGF0ZXNcblx0XHRcdC5vbignY2hhbmdlJywgZnVuY3Rpb24gKHZhbHVlcywgaGFuZGxlLCB1bmVuY29kZWQsIHRhcCwgcG9zaXRpb25zKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiY2hhbmdpbmdcIik7XG5cdFx0XHRcdG1vdmVDaGFydCh1bmVuY29kZWQpXG5cdFx0XHR9KTtcblxuXHRcdHNsaWRlckRhdGVzXG5cdFx0XHQub24oJ2VuZCcsIGZ1bmN0aW9uICh2YWx1ZXMsIGhhbmRsZSwgdW5lbmNvZGVkLCB0YXAsIHBvc2l0aW9ucykge1xuXHRcdFx0XHRkcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0XHRtb3ZlQ2hhcnQodW5lbmNvZGVkKVxuXHRcdFx0fSk7XG5cblx0XHRsZXQgcGxheVZpc2libGUgPSB0cnVlO1xuXG5cdFx0ZDMuc2VsZWN0KFwiLnN0YXJ0LWJ1dHRvblwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtcblx0XHRcdGQzLnNlbGVjdChcIi5sb2FkaW5nLXNjcmVlblwiKS5zdHlsZShcIm9wYWNpdHlcIiwwKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpLnRyYW5zaXRpb24oKS5kdXJhdGlvbigwKS5kZWxheSgyMDAwKS5yZW1vdmUoKTtcblx0XHRcdGQzLnNlbGVjdChcIiNjb250ZW50XCIpLmNsYXNzZWQoXCJub3QtbG9hZGVkXCIsZmFsc2UpO1xuXHRcdFx0bW92ZUNoYXJ0KGRhdGVzWzBdLmdldFRpbWUoKSlcblxuXHRcdFx0dmFyIHBsYXlOb3cyID0gY3JlYXRlU291cmNlKHNjcmF0Y2gpO1xuXHQgICAgc291cmNlMiA9IHBsYXlOb3cyLnNvdXJjZTtcblxuXHQgICAgaWYgKCFzb3VyY2UyLnN0YXJ0KXtcblx0ICAgICAgc291cmNlMi5zdGFydCA9IHNvdXJjZS5ub3RlT247XG5cdCAgICB9XG5cdCAgICBzb3VyY2UyLnN0YXJ0KDApO1xuXG5cdFx0fSk7XG5cblx0XHRkMy5zZWxlY3QoXCIuc3RhcnQtYnV0dG9uLW11dGVkXCIpLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe1xuXHRcdFx0ZDMuc2VsZWN0KFwiLmxvYWRpbmctc2NyZWVuXCIpLnN0eWxlKFwib3BhY2l0eVwiLDApLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIixcIm5vbmVcIikudHJhbnNpdGlvbigpLmR1cmF0aW9uKDApLmRlbGF5KDIwMDApLnJlbW92ZSgpO1xuXHRcdFx0ZDMuc2VsZWN0KFwiI2NvbnRlbnRcIikuY2xhc3NlZChcIm5vdC1sb2FkZWRcIixmYWxzZSk7XG5cblx0XHRcdGQzLnNlbGVjdChcIi52b2xcIikuc2VsZWN0KFwiLm11dGUtaWNvblwiKS5zdHlsZShcImRpc3BsYXlcIixcIm5vbmVcIik7XG5cdFx0XHRkMy5zZWxlY3QoXCIudm9sXCIpLnNlbGVjdChcIi52b2wtaWNvblwiKS5zdHlsZShcImRpc3BsYXlcIixcImJsb2NrXCIpO1xuXG5cdFx0XHR2YXIgcGxheU5vdzIgPSBjcmVhdGVTb3VyY2Uoc2NyYXRjaCk7XG5cdCAgICBzb3VyY2UyID0gcGxheU5vdzIuc291cmNlO1xuXG5cdCAgICBpZiAoIXNvdXJjZTIuc3RhcnQpe1xuXHQgICAgICBzb3VyY2UyLnN0YXJ0ID0gc291cmNlLm5vdGVPbjtcblx0ICAgIH1cblx0XHRcdHZhciBnYWluTm9kZSA9IHBsYXlOb3cyLmdhaW5Ob2RlO1xuXHRcdFx0Z2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IDA7XG5cdFx0XHRzb3VyY2UyLnN0YXJ0KDApO1xuXG5cblx0XHRcdC8vIHZhciBwbGF5Tm93ID0gY3JlYXRlU291cmNlKGJ1ZmZlck5vdyk7XG5cdFx0XHQvLyBzb3VyY2UgPSBwbGF5Tm93LnNvdXJjZTtcblx0XHRcdC8vIHNvdXJjZS5sb29wID0gdHJ1ZTtcblx0XHRcdC8vIHZhciBnYWluTm9kZSA9IHBsYXlOb3cuZ2Fpbk5vZGU7XG5cdFx0XHQvLyB2YXIgZHVyYXRpb24gPSBwbGF5aW5nTGVuZ3RoLzEwMDAgKyAyO1xuXHRcdFx0Ly9cblx0XHRcdC8vXG5cdFx0XHQvLyBpZighbXV0ZWQpe1xuXHRcdFx0Ly8gXHRnYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHN0YXJ0aW5nVGltZSk7XG5cdFx0XHQvLyBcdGdhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMSwgc3RhcnRpbmdUaW1lICsgMSk7XG5cdFx0XHQvLyB9XG5cdFx0XHQvLyBlbHNlIHtcblx0XHRcdC8vIFx0Z2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IDA7XG5cdFx0XHQvLyB9XG5cdFx0XHQvL1xuXHRcdFx0Ly8gaWYgKCFzb3VyY2Uuc3RhcnQpe1xuXHRcdFx0Ly8gXHRzb3VyY2Uuc3RhcnQgPSBzb3VyY2Uubm90ZU9uO1xuXHRcdFx0Ly8gfVxuXHRcdFx0Ly9cblx0XHRcdC8vIHNvdXJjZS5zdGFydChjb250ZXh0LmN1cnJlbnRUaW1lICsgKHN0YXJ0aW5nVGltZSAtIGNvbnRleHQuY3VycmVudFRpbWUpKTtcblx0XHRcdC8vXG5cdFx0XHQvLyBpZighbXV0ZWQpe1xuXHRcdFx0Ly8gXHRnYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDEsIHN0YXJ0aW5nVGltZSArIGR1cmF0aW9uLTEpO1xuXHRcdFx0Ly8gXHRnYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHN0YXJ0aW5nVGltZSArIGR1cmF0aW9uKTtcblx0XHRcdC8vIH1cblx0XHRcdC8vXG5cdFx0XHQvLyBzb3VyY2Uuc3RvcChjb250ZXh0LmN1cnJlbnRUaW1lICsgKHN0YXJ0aW5nVGltZSAtIGNvbnRleHQuY3VycmVudFRpbWUpICsgZHVyYXRpb24gKyAuMSlcblx0XHRcdC8vXG5cdFx0XHQvLyBnbG9iYWxHYWluID0gZ2Fpbk5vZGU7XG5cblx0XHRcdG11dGVkID0gdHJ1ZTtcblx0XHRcdG1vdmVDaGFydChkYXRlc1swXS5nZXRUaW1lKCkpXG5cdFx0fSk7XG5cblx0XHRkMy5zZWxlY3QoXCIucGxheS1wYXVzZVwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtcblx0XHRcdGlmKHBsYXlpbmcpe1xuXHRcdFx0XHRtb3ZlQ2hhcnQoXCJzdG9wXCIpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG1vdmVDaGFydChkYXRlc1swXS5nZXRUaW1lKCkpXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdGQzLnNlbGVjdChcIi52b2xcIikub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7XG5cdFx0XHRpZihtdXRlZCl7XG5cdFx0XHRcdG11dGVkID0gZmFsc2U7XG5cdFx0XHRcdGdsb2JhbEdhaW4uZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoY29udGV4dC5jdXJyZW50VGltZSk7XG5cdFx0XHRcdGdsb2JhbEdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLGNvbnRleHQuY3VycmVudFRpbWUpXG5cblx0XHRcdFx0ZDMuc2VsZWN0KFwiLnZvbFwiKS5zZWxlY3QoXCIubXV0ZS1pY29uXCIpLnN0eWxlKFwiZGlzcGxheVwiLG51bGwpO1xuXHRcdFx0XHRkMy5zZWxlY3QoXCIudm9sXCIpLnNlbGVjdChcIi52b2wtaWNvblwiKS5zdHlsZShcImRpc3BsYXlcIixudWxsKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRtdXRlZCA9IHRydWU7XG5cdFx0XHRcdC8vZ2xvYmFsR2Fpbi5nYWluLnZhbHVlID0gMDtcblx0XHRcdFx0Z2xvYmFsR2Fpbi5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhjb250ZXh0LmN1cnJlbnRUaW1lKTtcblx0XHRcdFx0Z2xvYmFsR2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKDAsY29udGV4dC5jdXJyZW50VGltZSlcblxuXHRcdFx0XHRkMy5zZWxlY3QoXCIudm9sXCIpLnNlbGVjdChcIi5tdXRlLWljb25cIikuc3R5bGUoXCJkaXNwbGF5XCIsXCJub25lXCIpO1xuXHRcdFx0XHRkMy5zZWxlY3QoXCIudm9sXCIpLnNlbGVjdChcIi52b2wtaWNvblwiKS5zdHlsZShcImRpc3BsYXlcIixcImJsb2NrXCIpO1xuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRkMy5zZWxlY3RBbGwoXCIubm9VaS12YWx1ZVwiKS50ZXh0KGZ1bmN0aW9uKGQpe1xuXHRcdFx0cmV0dXJuIHllYXJQYXJzZShuZXcgRGF0ZSgrZDMuc2VsZWN0KHRoaXMpLnRleHQoKSkpO1xuXHRcdH0pXG5cblx0XHRmdW5jdGlvbiBjbGlja09uUGlwKCkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKTtcblx0XHRcdHNsaWRlckRhdGVzLnNldChOdW1iZXIodmFsdWUpKTtcblx0XHRcdG1vdmVDaGFydChOdW1iZXIodmFsdWUpKVxuXHRcdH1cblxuXHRcdHZhciBwaXBzID0gZDMuc2VsZWN0KFwiI3NsaWRlclwiKS5zZWxlY3RBbGwoJy5ub1VpLXZhbHVlJykuZWFjaChmdW5jdGlvbihkKXtcblx0XHRcdGQzLnNlbGVjdCh0aGlzKS5ub2RlKCkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja09uUGlwKTtcblx0XHR9KTtcblxuXG5cdCAgZnVuY3Rpb24gdGljaygpIHtcblx0XHRcdGlmKHVuUGFyc2UoZGF0ZXNbMF0pID09IFwiMjAxOS0wMy0zMFwiKXtcblx0XHRcdFx0bW92ZUNoYXJ0KFwic3RvcFwiKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0ICAgIHZhciBjdXJyVGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XG5cblx0ICAgIGZvciAodmFyIGkgaW4gZGF0ZXMpe1xuXHQgICAgICBkYXRlc1tpXSA9IGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1tpXSwgNyk7XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgbmV4dFNvbmc7XG5cblx0ICAgIGlmKG5lc3RlZERhdGVzVHdvW3VuUGFyc2UoZGF0ZXNbMF0pXVtcInRyYWNrXCJdICE9IG5lc3RlZERhdGVzVHdvW3VuUGFyc2UoZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzWzBdLCA3KSldW1widHJhY2tcIl0gJiYgMSA8IDIpe1xuXG5cdCAgICAgIGZvciAoaT0yOyBpPDIwOyBpKyspe1xuXHQgICAgICAgIHZhciB0aW1lT25lID0gZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzWzBdLCA3KTtcblx0ICAgICAgICB2YXIgdGltZVR3byA9IGQzLnRpbWUuZGF5Lm9mZnNldChkYXRlc1swXSwgNyppKTtcblx0ICAgICAgICBpZihuZXN0ZWREYXRlc1R3b1t1blBhcnNlKHRpbWVPbmUpXVtcInRyYWNrXCJdICE9IG5lc3RlZERhdGVzVHdvW3VuUGFyc2UodGltZVR3byldW1widHJhY2tcIl0pe1xuXHQgICAgICAgICAgcGxheUxlbmd0aCA9IChpLTEpICogc2hpZnREdXJhdGlvbjtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBwcmV2aWV3SXRlbUlkID0gbmVzdGVkRGF0ZXNUd29bdW5QYXJzZShkMy50aW1lLmRheS5vZmZzZXQoZGF0ZXNbMF0sIDcpKV1bXCJwcmV2aWV3XCJdO1xuXG5cdCAgICAgIG5leHRTb25nID0gXCJodHRwczovL3Auc2Nkbi5jby9tcDMtcHJldmlldy9cIiArIHByZXZpZXdJdGVtSWRcblx0XHRcdFx0aWYocHJldmlld0l0ZW1JZCA9PT0gJycpe1xuXHRcdFx0XHRcdG5leHRTb25nID0gXCJodHRwczovL3Auc2Nkbi5jby9tcDMtcHJldmlldy9cIiArIFwiTlVMTFwiXG5cdFx0XHRcdH1cblx0ICAgICAgaWYocHJldmlld0l0ZW1JZCA9PSBcIm1hbnVhbFwiKXtcblx0ICAgICAgICB2YXIgaG9zdFVybCA9IGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbjtcblx0ICAgICAgICB2YXIgcGF0aFVybCA9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoXCJpbmRleC5odG1sXCIsXCJcIik7XG5cdCAgICAgICAgdmFyIGlkU29uZyA9IG5lc3RlZERhdGVzVHdvW3VuUGFyc2UoZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzWzBdLCA3KSldW1widHJhY2tcIl07XG5cdCAgICAgICAgbmV4dFNvbmcgPSBob3N0VXJsK3BhdGhVcmwrXCJ1cmwvXCIraWRTb25nICsgXCIubTRhXCJcblx0ICAgICAgfVxuXHQgICAgICBzdGFydFRpbWUgPSBjdXJyVGltZSArIHNoaWZ0RHVyYXRpb24vMTAwMDtcblxuXHQgICAgICBsb2FkU291bmRzKG5leHRTb25nLCBwbGF5TGVuZ3RoLCBzdGFydFRpbWUsIFwic2NoZWR1bGVkXCIpO1xuXHQgICAgfTtcblxuXHRcdFx0Y3VycmVudERhdGUgPSB1blBhcnNlKGRhdGVzWzBdKTtcblx0ICAgIGRhdGVBaGVhZCA9IHVuUGFyc2UoZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzWzBdLCA3KSk7XG5cdFx0XHR0d29EYXRlc0FoZWFkID0gdW5QYXJzZShkMy50aW1lLmRheS5vZmZzZXQoZGF0ZXNbMF0sIDE0KSk7XG5cblx0XHRcdGNvbnNvbGUubG9nKGN1cnJlbnREYXRlKTtcblxuXHQgICAgY2hhbmdlWWVhcihjdXJyZW50WWVhcik7XG5cblx0ICAgIHZhciBudW1iZXJPbmVEYXRlcyA9IFtkYXRlc1swXV07XG5cblx0ICAgIGZvciAoaT0wOyBpPDg7IGkrKyl7XG5cdCAgICAgIHZhciBsZW5ndGggPSBudW1iZXJPbmVEYXRlcy5sZW5ndGg7XG5cdCAgICAgIHZhciBkYXRlID0gZDMudGltZS5kYXkub2Zmc2V0KG51bWJlck9uZURhdGVzW2xlbmd0aCAtIDFdLDEpO1xuXHQgICAgICBudW1iZXJPbmVEYXRlcy5wdXNoKGRhdGUpO1xuXHQgICAgfVxuXG5cdFx0XHRpZighZHJhZ2dpbmcpe1xuXHRcdFx0XHRzbGlkZXJEYXRlcy5zZXQoTnVtYmVyKGRhdGVzWzBdLmdldFRpbWUoKSkpO1xuXHRcdFx0fVxuXG5cdCAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbi5lYWNoKGZ1bmN0aW9uKCkge1xuXG5cdCAgICAgIC8vIHZhciBudW1iZXJTaGlmdER1cmF0aW9uID0gc2hpZnREdXJhdGlvbi83O1xuXG5cdCAgICAgIC8vIGQzLnNlbGVjdChcIi55ZWFyLWRyb3AtZG93bi10ZXh0XCIpLnRleHQoY3VycmVudERhdGUuc2xpY2UoMCw0KSk7XG5cblx0ICAgICAgLy8gZDMuc2VsZWN0KFwiI3RvcC1kYXRlLXN1YlwiKVxuXHQgICAgICAvLyAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24obnVtYmVyU2hpZnREdXJhdGlvbikudGV4dChmdW5jdGlvbihkKXtcblx0ICAgICAgLy8gICAgIHJldHVybiBuaWNlUGFyc2VUd28obnVtYmVyT25lRGF0ZXNbMF0pO1xuXHQgICAgICAvLyAgIH0pXG5cdCAgICAgIC8vICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbihudW1iZXJTaGlmdER1cmF0aW9uKS50ZXh0KGZ1bmN0aW9uKGQpe1xuXHQgICAgICAvLyAgICAgcmV0dXJuIG5pY2VQYXJzZVR3byhudW1iZXJPbmVEYXRlc1sxXSk7XG5cdCAgICAgIC8vICAgfSlcblx0ICAgICAgLy8gICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKG51bWJlclNoaWZ0RHVyYXRpb24pLnRleHQoZnVuY3Rpb24oZCl7XG5cdCAgICAgIC8vICAgICByZXR1cm4gbmljZVBhcnNlVHdvKG51bWJlck9uZURhdGVzWzJdKTtcblx0ICAgICAgLy8gICB9KVxuXHQgICAgICAvLyAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24obnVtYmVyU2hpZnREdXJhdGlvbikudGV4dChmdW5jdGlvbihkKXtcblx0ICAgICAgLy8gICAgIHJldHVybiBuaWNlUGFyc2VUd28obnVtYmVyT25lRGF0ZXNbM10pO1xuXHQgICAgICAvLyAgIH0pXG5cdCAgICAgIC8vICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbihudW1iZXJTaGlmdER1cmF0aW9uKS50ZXh0KGZ1bmN0aW9uKGQpe1xuXHQgICAgICAvLyAgICAgcmV0dXJuIG5pY2VQYXJzZVR3byhudW1iZXJPbmVEYXRlc1s0XSk7XG5cdCAgICAgIC8vICAgfSlcblx0ICAgICAgLy8gICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKG51bWJlclNoaWZ0RHVyYXRpb24pLnRleHQoZnVuY3Rpb24oZCl7XG5cdCAgICAgIC8vICAgICByZXR1cm4gbmljZVBhcnNlVHdvKG51bWJlck9uZURhdGVzWzVdKTtcblx0ICAgICAgLy8gICB9KVxuXHQgICAgICAvLyAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24obnVtYmVyU2hpZnREdXJhdGlvbikudGV4dChmdW5jdGlvbihkKXtcblx0ICAgICAgLy8gICAgIHJldHVybiBuaWNlUGFyc2VUd28obnVtYmVyT25lRGF0ZXNbNl0pO1xuXHQgICAgICAvLyAgIH0pXG5cdCAgICAgIC8vICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbihudW1iZXJTaGlmdER1cmF0aW9uKS50ZXh0KGZ1bmN0aW9uKGQpe1xuXHQgICAgICAvLyAgICAgcmV0dXJuIG5pY2VQYXJzZVR3byhudW1iZXJPbmVEYXRlc1s3XSk7XG5cdCAgICAgIC8vICAgfSlcblx0ICAgICAgLy8gICA7XG5cblx0XHRcdFx0ZDMuc2VsZWN0KFwiI3RvcC10aXRsZS1zdWJcIikudGV4dChmdW5jdGlvbihkKXtcblx0XHRcdFx0XHR2YXIgdGl0bGUgPSBuZXN0ZWREYXRlc1R3b1t1blBhcnNlKGRhdGVzWzBdKV0udGl0bGU7XG5cdFx0XHRcdFx0aWYodGl0bGUubGVuZ3RoID4gMjUgJiYgbW9iaWxlKXtcblx0XHRcdFx0XHRcdHJldHVybiB0aXRsZS5zbGljZSgwLDIyKStcIi4uLlwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBuZXN0ZWREYXRlc1R3b1t1blBhcnNlKGRhdGVzWzBdKV0udGl0bGU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRkMy5zZWxlY3QoXCIjdG9wLWFydGlzdC1zdWJcIikudGV4dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHJldHVybiBhcnRpc3RDbGVhbihuZXN0ZWREYXRlc1R3b1t1blBhcnNlKGRhdGVzWzBdKV0uYXJ0aXN0KTtcblx0XHRcdFx0fSk7XG5cblxuXHQgICAgICBpZihuZXN0ZWREYXRlc1R3b1t1blBhcnNlKGRhdGVzWzBdKV1bXCJ0cmFja1wiXSAhPSBuZXN0ZWREYXRlc1R3b1t1blBhcnNlKGRhdGVzWzFdKV1bXCJ0cmFja1wiXSkge1xuXHQgICAgICAgIGNvdW50U3RyZWFrID0gMTtcblx0XHRcdFx0XHQvLyBkMy5zZWxlY3QoXCIjdG9wLXRpdGxlLXN1YlwiKS50ZXh0KG5lc3RlZERhdGVzVHdvW3VuUGFyc2UoZGF0ZXNbMF0pXS50aXRsZSk7XG5cblx0XHRcdFx0XHQvL3ZhciB0b3BBcnRpc3ROYW1lID0gbmVzdGVkRGF0ZXNUd29bY3VycmVudERhdGVdLmFydGlzdC5zcGxpdChcIiBGZWF0XCIpWzBdO1xuXG5cdFx0XHRcdFx0ZDMuc2VsZWN0KFwiLnN0cmVha1wiKS5zdHlsZShcIm9wYWNpdHlcIiwwKTtcblxuXHRcdFx0XHRcdC8vZDMuc2VsZWN0KFwiLnN0cmVha1wiKS5zZWxlY3QoXCIuYmlnXCIpLnRleHQoY291bnRTdHJlYWspXG5cblx0ICAgICAgfSBlbHNle1xuXHRcdFx0XHRcdGNvdW50U3RyZWFrID0gY291bnRTdHJlYWsgKyAxO1xuXHRcdFx0XHRcdGlmKGNvdW50U3RyZWFrID4gMil7XG5cdFx0XHRcdFx0XHRkMy5zZWxlY3QoXCIuc3RyZWFrXCIpLnN0eWxlKFwib3BhY2l0eVwiLDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkMy5zZWxlY3QoXCIuc3RyZWFrXCIpLnNlbGVjdChcIi5iaWdcIilcblx0XHRcdFx0XHRcdC50ZXh0KGNvdW50U3RyZWFrKS8vLnN0eWxlKFwiZm9udC1zaXplXCIsXCI3MHB4XCIpXG5cblx0XHRcdFx0XHRcdC8vIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHQvLyBcdGQzLnNlbGVjdChcIi5zdHJlYWtcIikuc2VsZWN0KFwiLmJpZ1wiKVxuXHRcdFx0XHRcdFx0Ly8gXHRcdC5zdHlsZShcImZvbnQtc2l6ZVwiLG51bGwpXG5cdFx0XHRcdFx0XHQvLyB9LDEwMClcblx0XHRcdFx0fVxuXG5cdCAgICAgIHguZG9tYWluKFtkYXRlc1swXSwgZGF0ZXNbZGF0ZXMubGVuZ3RoLTFdXSk7XG5cblx0ICAgICAgZmFjZVxuXHRcdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIixmdW5jdGlvbihkKXtcblx0XHRcdFx0XHRcdHJldHVybiBmYWNlT3BhY2l0eShkKVxuXHQgICAgICAgIH0pXG5cdFx0XHRcdFx0Ly8gLnN0eWxlKFwiZGlzcGxheVwiLGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRcdC8vIFx0cmV0dXJuIGZhY2VEaXNwbGF5KGQpXG5cdCAgICAgICAgLy8gfSlcblx0XHRcdFx0XHQuc3R5bGUoXCJ3aWR0aFwiLGZhY2VTaXplK1wicHhcIilcblx0XHRcdFx0XHQuc3R5bGUoXCJoZWlnaHRcIixmYWNlU2l6ZStcInB4XCIpXG5cdFx0XHRcdFx0LnN0eWxlKFwiYm9yZGVyLWNvbG9yXCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFjZUJvcmRlcihkKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC8vIC5zdHlsZShcImJveC1zaGFkb3dcIixmdW5jdGlvbihkKXtcblx0XHRcdFx0XHQvLyBcdHJldHVybiBmYWNlU2hhZG93KGQpO1xuXHRcdFx0XHRcdC8vIH0pXG5cdCAgICAgICAgLnRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdC5zdHlsZShcInRvcFwiLGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhY2VUb3AoZCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuc3R5bGUoXCJsZWZ0XCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0XHR2YXIgZGF0YSA9IGQ7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFjZUxlZnQoZGF0YSk7XG5cdFx0XHRcdFx0fSlcblx0ICAgICAgICA7XG5cblx0XHRcdFx0bGluZXNcblx0XHRcdFx0XHQuc3R5bGUoXCJ0b3BcIixmdW5jdGlvbihkKXtcblx0XHRcdFx0XHRcdHJldHVybiB4KGQpK1wicHhcIjtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsZnVuY3Rpb24oZCxpKXtcblx0XHRcdFx0XHRcdGlmKGk9PTApe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXG5cdFx0XHRcdGQzLnNlbGVjdChcIi5kYXRlLWxpbmVzLWNvbnRhaW5lclwiKVxuXHRcdFx0XHRcdC5zdHlsZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwcHgsXCIrIHgoZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzW2RhdGVzLmxlbmd0aC0xXSwgNykpICsgXCJweClcIilcblx0XHRcdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHRcdFx0LnN0eWxlVHdlZW4oJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBkMy5pbnRlcnBvbGF0ZVN0cmluZyhcInRyYW5zbGF0ZSgwcHgsXCIrIHgoZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzW2RhdGVzLmxlbmd0aC0xXSwgNykpICsgXCJweClcIiwgXCJ0cmFuc2xhdGUoMHB4LDBweClcIik7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQ7XG5cblx0ICAgICBwYXRoXG5cdFx0XHRcdC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKXtcblx0XHRcdFx0XHRcdC8vcmV0dXJuIGxpbmVGdW5jdGlvbihkLnZhbHVlcyk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGluZShkLnZhbHVlcyk7XG5cdCAgICAgICAgICByZXR1cm4gbGluZShnZXRQYXRoV2Vla3MoZCkpO1xuXHQgICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICB2YXIgZGF0YSA9IGQ7XG4gICAgICAgICAgcmV0dXJuIHBhdGhTdHJva2UoZGF0YSk7XG4gICAgICAgIH0pXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBkO1xuXHRcdFx0XHRcdHJldHVybiBwYXRoT3BhY2l0eShkYXRhKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Ly8gLnN0eWxlKFwiZGlzcGxheVwiLGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHQvLyBcdHJldHVybiBmYWNlRGlzcGxheShkKVxuXHRcdFx0XHQvLyB9KVxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBkO1xuXHRcdFx0XHRcdHJldHVybiBwYXRoU3Ryb2tlV2lkdGgoZGF0YSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsaSl7XG5cdFx0XHRcdFx0aWYgKGRhdGVBaGVhZCBpbiBkLm5lc3RlZERhdGVBcnJheSl7XG5cdFx0XHRcdFx0XHR2YXIgcmFuayA9IGQubmVzdGVkRGF0ZUFycmF5W2RhdGVBaGVhZF07XG5cdFx0XHRcdFx0XHRpZihyYW5rPT0xKXtcblx0XHRcdFx0XHRcdFx0Y2xvbmUoZDMuc2VsZWN0KHRoaXMpKS5hdHRyKCdmaWx0ZXInLCAndXJsKCNibHVycmVkKScpLnN0eWxlKFwic3Ryb2tlXCIsY29sb3JTY2hlbWVbMF0pLmF0dHIoXCJpZFwiLFwiZ2xvd1wiKS5zdHlsZShcInN0cm9rZS13aWR0aFwiLCcxMHB4Jykuc3R5bGUoXCJvcGFjaXR5XCIsMSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2V7XG5cdFx0XHRcdFx0XHRcdGNsb25lKGQzLnNlbGVjdCh0aGlzKSlcblx0XHRcdFx0XHRcdFx0XHQvLy5hdHRyKCdmaWx0ZXInLCAndXJsKCNibHVycmVkVHdvKScpXG5cdFx0XHRcdFx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsXCIjMmEyOTJmXCIpLmF0dHIoXCJpZFwiLFwiZ2xvd1wiKS5zdHlsZShcInN0cm9rZS13aWR0aFwiLCc2cHgnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdDtcblxuXHRcdFx0XHRkMy5zZWxlY3QoXCIucGF0aC1jb250YWluZXJcIikuc2VsZWN0QWxsKFwicGF0aFwiKVxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIrIHgoZDMudGltZS5kYXkub2Zmc2V0KGRhdGVzW2RhdGVzLmxlbmd0aC0xXSwgNykpICsgXCIpXCIpXG5cblxuXHRcdFx0XHRkMy5zZWxlY3QoXCIucGF0aC1jb250YWluZXJcIikuc2VsZWN0QWxsKFwicGF0aFwiKVxuXHQgICAgICAgIC50cmFuc2l0aW9uKClcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLDApXCIpXG5cdCAgICAgICAgO1xuXG5cdCAgICAgIC8vIH0pLnRyYW5zaXRpb24oKS5lYWNoKFwic3RhcnRcIiwgdGljayk7XG5cdCAgICAgIH0pLnRyYW5zaXRpb24oKS5lYWNoKFwic3RhcnRcIiwgZnVuY3Rpb24oKXtcblx0ICAgICAgICBpZiAodGhpcy5fX3RyYW5zaXRpb25fXy5jb3VudCA8IDIpIHRpY2soKTtcblx0ICAgICAgLy8gICAvL3RpY2soKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIC8vIH0pO1xuXHQgICAgfTtcblxuXHQgIChmdW5jdGlvbigpIHtcblx0ICAgIGhpZGRlbiA9IFwiaGlkZGVuXCI7XG5cblx0ICAgIC8vIFN0YW5kYXJkczpcblx0ICAgIGlmIChoaWRkZW4gaW4gZG9jdW1lbnQpXG5cdCAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uY2hhbmdlKTtcblx0ICAgIGVsc2UgaWYgKChoaWRkZW4gPSBcIm1vekhpZGRlblwiKSBpbiBkb2N1bWVudClcblx0ICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1venZpc2liaWxpdHljaGFuZ2VcIiwgb25jaGFuZ2UpO1xuXHQgICAgZWxzZSBpZiAoKGhpZGRlbiA9IFwid2Via2l0SGlkZGVuXCIpIGluIGRvY3VtZW50KVxuXHQgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwid2Via2l0dmlzaWJpbGl0eWNoYW5nZVwiLCBvbmNoYW5nZSk7XG5cdCAgICBlbHNlIGlmICgoaGlkZGVuID0gXCJtc0hpZGRlblwiKSBpbiBkb2N1bWVudClcblx0ICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1zdmlzaWJpbGl0eWNoYW5nZVwiLCBvbmNoYW5nZSk7XG5cdCAgICAvLyBJRSA5IGFuZCBsb3dlcjpcblx0ICAgIGVsc2UgaWYgKFwib25mb2N1c2luXCIgaW4gZG9jdW1lbnQpXG5cdCAgICAgIGRvY3VtZW50Lm9uZm9jdXNpbiA9IGRvY3VtZW50Lm9uZm9jdXNvdXQgPSBvbmNoYW5nZTtcblx0ICAgIC8vIEFsbCBvdGhlcnM6XG5cdCAgICBlbHNlXG5cdCAgICAgIHdpbmRvdy5vbnBhZ2VzaG93ID0gd2luZG93Lm9ucGFnZWhpZGVcblx0ICAgICAgPSB3aW5kb3cub25mb2N1cyA9IHdpbmRvdy5vbmJsdXIgPSBvbmNoYW5nZTtcblxuXHQgICAgZnVuY3Rpb24gb25jaGFuZ2UgKGV2dCkge1xuXHQgICAgICB2YXIgdiA9IFwidmlzaWJsZVwiLCBoID0gXCJoaWRkZW5cIixcblx0ICAgICAgICAgIGV2dE1hcCA9IHtcblx0ICAgICAgICAgICAgZm9jdXM6diwgZm9jdXNpbjp2LCBwYWdlc2hvdzp2LCBibHVyOmgsIGZvY3Vzb3V0OmgsIHBhZ2VoaWRlOmhcblx0ICAgICAgICAgIH07XG5cblx0ICAgICAgZXZ0ID0gZXZ0IHx8IHdpbmRvdy5ldmVudDtcblx0ICAgICAgaWYgKGV2dC50eXBlIGluIGV2dE1hcCl7XG5cdCAgICAgIH1cblx0ICAgICAgZWxzZSB7XG5cdCAgICAgICAgaWYodGhpc1toaWRkZW5dID09IHRydWUpe1xuXHQgICAgICAgICAgaWYocGxheWluZyl7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwic3RvcHBlZCBmb3IgaGlkZGVuXCIpO1xuXHQgICAgICAgICAgICBtb3ZlQ2hhcnQoXCJzdG9wXCIpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1lbHNle1xuXHQgICAgICAgICAgaWYocGxheWluZyl7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiY29udGludWluZ1wiKVxuXHQgICAgICAgICAgICBtb3ZlQ2hhcnQoZGF0ZXNbMF0uZ2V0VGltZSgpKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gc2V0IHRoZSBpbml0aWFsIHN0YXRlIChidXQgb25seSBpZiBicm93c2VyIHN1cHBvcnRzIHRoZSBQYWdlIFZpc2liaWxpdHkgQVBJKVxuXHQgICAgaWYoIGRvY3VtZW50W2hpZGRlbl0gIT09IHVuZGVmaW5lZCApXG5cdCAgICAgIG9uY2hhbmdlKHt0eXBlOiBkb2N1bWVudFtoaWRkZW5dID8gXCJibHVyXCIgOiBcImZvY3VzXCJ9KTtcblx0ICB9KSgpO1xuXG5cblxuXG5cblxuXG5cblxuXHR9KTtcblx0fSk7XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIEJ1ZmZlckxvYWRlcihjb250ZXh0LCB1cmxMaXN0LCBjYWxsYmFjaywgcGxheWluZ0xlbmd0aCwgc3RhcnRpbmdUaW1lLCB0aGluZykge1xuXHQgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cdCAgdGhpcy51cmxMaXN0ID0gdXJsTGlzdDtcblx0ICB0aGlzLm9ubG9hZCA9IGNhbGxiYWNrO1xuXHQgIHRoaXMuYnVmZmVyTGlzdCA9IG5ldyBBcnJheSgpO1xuXHQgIHRoaXMubG9hZENvdW50ID0gMDtcblx0ICB0aGlzLnN0YXJ0aW5nVGltZSA9IHN0YXJ0aW5nVGltZTtcblx0ICB0aGlzLnBsYXlpbmdMZW5ndGggPSBwbGF5aW5nTGVuZ3RoO1xuXHQgIHRoaXMudGhpbmcgPSB0aGluZztcblx0fVxuXG5cdEJ1ZmZlckxvYWRlci5wcm90b3R5cGUubG9hZEJ1ZmZlciA9IGZ1bmN0aW9uKHVybCwgaW5kZXgpIHtcblx0ICAvLyBMb2FkIGJ1ZmZlciBhc3luY2hyb25vdXNseVxuXHQgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XG5cdCAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG5cblx0ICB2YXIgbG9hZGVyID0gdGhpcztcblxuXHQgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdCAgICAvLyBBc3luY2hyb25vdXNseSBkZWNvZGUgdGhlIGF1ZGlvIGZpbGUgZGF0YSBpbiByZXF1ZXN0LnJlc3BvbnNlXG5cdCAgICBsb2FkZXIuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoXG5cdCAgICAgIHJlcXVlc3QucmVzcG9uc2UsXG5cdCAgICAgIGZ1bmN0aW9uKGJ1ZmZlcikge1xuXHQgICAgICAgIGlmICghYnVmZmVyKSB7XG5cdCAgICAgICAgICBhbGVydCgnZXJyb3IgZGVjb2RpbmcgZmlsZSBkYXRhOiAnICsgdXJsKTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbG9hZGVyLmJ1ZmZlckxpc3RbaW5kZXhdID0gYnVmZmVyO1xuXHQgICAgICAgIGlmICgrK2xvYWRlci5sb2FkQ291bnQgPT0gbG9hZGVyLnVybExpc3QubGVuZ3RoKVxuXHQgICAgICAgICAgbG9hZGVyLm9ubG9hZChsb2FkZXIuYnVmZmVyTGlzdCwgbG9hZGVyLnBsYXlpbmdMZW5ndGgsIGxvYWRlci5zdGFydGluZ1RpbWUsIGxvYWRlci50aGluZyk7XG5cdCAgICAgIH0sXG5cdCAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgY29uc29sZS5lcnJvcignZGVjb2RlQXVkaW9EYXRhIGVycm9yJywgZXJyb3IpO1xuXHQgICAgICB9XG5cdCAgICApO1xuXHQgIH1cblxuXHQgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgYWxlcnQoJ0J1ZmZlckxvYWRlcjogWEhSIGVycm9yJyk7XG5cdCAgfVxuXG5cdCAgcmVxdWVzdC5zZW5kKCk7XG5cdH1cblxuXHRCdWZmZXJMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudXJsTGlzdC5sZW5ndGg7ICsraSlcblx0ICB0aGlzLmxvYWRCdWZmZXIodGhpcy51cmxMaXN0W2ldLCBpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWRTY3JhdGNoKHVybCkge1xuXHQgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0ICByZXEub3BlbihcIkdFVFwiLHVybCx0cnVlKTtcblx0ICByZXEucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuXHQgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgLy9kZWNvZGUgdGhlIGxvYWRlZCBkYXRhXG5cdCAgICAgIGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHJlcS5yZXNwb25zZSwgZnVuY3Rpb24oYnVmZmVyKSB7XG5cdCAgICAgICAgICBzY3JhdGNoID0gYnVmZmVyO1xuXHQgICAgICB9KTtcblx0ICB9O1xuXHQgIHJlcS5zZW5kKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBsb2FkSGl0KHVybCkge1xuXHQgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0ICByZXEub3BlbihcIkdFVFwiLHVybCx0cnVlKTtcblx0ICByZXEucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuXHQgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgLy9kZWNvZGUgdGhlIGxvYWRlZCBkYXRhXG5cdCAgICAgIGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHJlcS5yZXNwb25zZSwgZnVuY3Rpb24oYnVmZmVyKSB7XG5cdCAgICAgICAgICBoaXQgPSBidWZmZXI7XG5cdCAgICAgIH0pO1xuXHQgIH07XG5cdCAgcmVxLnNlbmQoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBsYXkoKSB7XG5cdCAgICAvL2NyZWF0ZSBhIHNvdXJjZSBub2RlIGZyb20gdGhlIGJ1ZmZlclxuXHQgICAgdmFyIHNyYyA9IGNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdCAgICBzcmMuYnVmZmVyID0gYnVmO1xuXHQgICAgLy9jb25uZWN0IHRvIHRoZSBmaW5hbCBvdXRwdXQgbm9kZSAodGhlIHNwZWFrZXJzKVxuXHQgICAgc3JjLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdCAgICAvL3BsYXkgaW1tZWRpYXRlbHlcblx0ICAgIHNyYy5ub3RlT24oMCk7XG5cdH1cblxuXHR3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xuXHRjb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuXHRsb2FkU2NyYXRjaChcImFzc2V0cy9pX3dpc2gubXAzXCIpO1xuXHQvLyBsb2FkSGl0KFwidXJsL3NjcmF0Y2gud2F2XCIpO1xuXG5cdGZ1bmN0aW9uIGxvYWRTb3VuZHModXJsLHBsYXlpbmdMZW5ndGgsc3RhcnRpbmdUaW1lLHRoaW5nKXtcblx0ICBpZih1cmwgPT0gXCJodHRwczovL3Auc2Nkbi5jby9tcDMtcHJldmlldy9OVUxMXCIpe1xuXHQgIH1cblx0ICBlbHNle1xuXHQgICAgdmFyIGJ1ZmZlckxvYWRlciA9IG5ldyBCdWZmZXJMb2FkZXIoXG5cdCAgICAgIGNvbnRleHQsXG5cdCAgICAgIFtcblx0ICAgICAgICB1cmxcblx0ICAgICAgXSxcblx0ICAgICAgZmluaXNoZWRMb2FkaW5nLHBsYXlpbmdMZW5ndGgsc3RhcnRpbmdUaW1lLHRoaW5nXG5cdCAgICAgICk7XG5cblx0ICAgIGJ1ZmZlckxvYWRlci5sb2FkKCk7XG5cdCAgfVxuXG5cdH1cblxuXHRmdW5jdGlvbiBmaW5pc2hlZExvYWRpbmcoYnVmZmVyTGlzdCxwbGF5aW5nTGVuZ3RoLHN0YXJ0aW5nVGltZSx0aGluZykge1xuXHQgIHBsYXlIZWxwZXIoYnVmZmVyTGlzdFswXSxwbGF5aW5nTGVuZ3RoLHN0YXJ0aW5nVGltZSx0aGluZyk7XG5cdH07XG5cblxuXHRmdW5jdGlvbiBjcmVhdGVTb3VyY2UoYnVmZmVyKSB7XG5cdCAgdmFyIHNvdXJjZSA9IGNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdCAgdmFyIGdhaW5Ob2RlID0gY29udGV4dC5jcmVhdGVHYWluID8gY29udGV4dC5jcmVhdGVHYWluKCkgOiBjb250ZXh0LmNyZWF0ZUdhaW5Ob2RlKCk7XG5cdCAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcblx0ICAvLyBDb25uZWN0IHNvdXJjZSB0byBnYWluLlxuXHQgIHNvdXJjZS5jb25uZWN0KGdhaW5Ob2RlKTtcblx0ICAvLyBDb25uZWN0IGdhaW4gdG8gZGVzdGluYXRpb24uXG5cdCAgZ2Fpbk5vZGUuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcblxuXHQgIHJldHVybiB7XG5cdCAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgIGdhaW5Ob2RlOiBnYWluTm9kZVxuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBwbGF5SGVscGVyKGJ1ZmZlck5vdyxwbGF5aW5nTGVuZ3RoLHN0YXJ0aW5nVGltZSx0aGluZykge1xuXG5cdCAgICB2YXIgY3VyclRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuXG5cdCAgICBsYXN0U291cmNlID0gc291cmNlO1xuXG5cdCAgICB2YXIgcGxheU5vdyA9IGNyZWF0ZVNvdXJjZShidWZmZXJOb3cpO1xuXHQgICAgc291cmNlID0gcGxheU5vdy5zb3VyY2U7XG5cdCAgICBzb3VyY2UubG9vcCA9IHRydWU7XG5cdCAgICB2YXIgZ2Fpbk5vZGUgPSBwbGF5Tm93LmdhaW5Ob2RlO1xuXHQgICAgdmFyIGR1cmF0aW9uID0gcGxheWluZ0xlbmd0aC8xMDAwICsgMjtcblxuXG5cdFx0XHRpZighbXV0ZWQpe1xuXHRcdFx0XHRnYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHN0YXJ0aW5nVGltZSk7XG5cdFx0ICAgIGdhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMSwgc3RhcnRpbmdUaW1lICsgMSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Z2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IDA7XG5cdFx0XHR9XG5cblx0ICAgIGlmICghc291cmNlLnN0YXJ0KXtcblx0ICAgICAgc291cmNlLnN0YXJ0ID0gc291cmNlLm5vdGVPbjtcblx0ICAgIH1cblxuXHQgICAgc291cmNlLnN0YXJ0KGNvbnRleHQuY3VycmVudFRpbWUgKyAoc3RhcnRpbmdUaW1lIC0gY29udGV4dC5jdXJyZW50VGltZSkpO1xuXG5cdFx0XHRpZighbXV0ZWQpe1xuXHRcdFx0XHRnYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDEsIHN0YXJ0aW5nVGltZSArIGR1cmF0aW9uLTEpO1xuXHRcdCAgICBnYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHN0YXJ0aW5nVGltZSArIGR1cmF0aW9uKTtcblx0XHRcdH1cblxuXHRcdFx0c291cmNlLnN0b3AoY29udGV4dC5jdXJyZW50VGltZSArIChzdGFydGluZ1RpbWUgLSBjb250ZXh0LmN1cnJlbnRUaW1lKSArIGR1cmF0aW9uICsgLjEpXG5cblx0XHRcdGdsb2JhbEdhaW4gPSBnYWluTm9kZTtcblx0fVxuXG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUtBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBSUE7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQVdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFRQTtBQUFBO0FBS0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBU0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBS0E7QUFDQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBSUE7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUxBO0FBWEE7QUFvQkE7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFOQTtBQVVBO0FBQ0E7QUFFQTtBQUNBO0FBZEE7QUFpQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFNQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFHQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUlBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/graphic.js\n");

/***/ }),

/***/ "./src/js/utils/is-mobile.js":
/*!***********************************!*\
  !*** ./src/js/utils/is-mobile.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// device sniffing for mobile\nvar isMobile = {\n  android: function android() {\n    return navigator.userAgent.match(/Android/i);\n  },\n  blackberry: function blackberry() {\n    return navigator.userAgent.match(/BlackBerry/i);\n  },\n  ios: function ios() {\n    return navigator.userAgent.match(/iPhone|iPad|iPod/i);\n  },\n  opera: function opera() {\n    return navigator.userAgent.match(/Opera Mini/i);\n  },\n  windows: function windows() {\n    return navigator.userAgent.match(/IEMobile/i);\n  },\n  any: function any() {\n    return isMobile.android() || isMobile.blackberry() || isMobile.ios() || isMobile.opera() || isMobile.windows();\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (isMobile);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvdXRpbHMvaXMtbW9iaWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL2lzLW1vYmlsZS5qcz9jMzcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGRldmljZSBzbmlmZmluZyBmb3IgbW9iaWxlXG5cbmNvbnN0IGlzTW9iaWxlID0ge1xuXHRhbmRyb2lkOiAoKSA9PiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpLFxuXG5cdGJsYWNrYmVycnk6ICgpID0+IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0JsYWNrQmVycnkvaSksXG5cblx0aW9zOiAoKSA9PiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUGhvbmV8aVBhZHxpUG9kL2kpLFxuXG5cdG9wZXJhOiAoKSA9PiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9PcGVyYSBNaW5pL2kpLFxuXG5cdHdpbmRvd3M6ICgpID0+IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0lFTW9iaWxlL2kpLFxuXG5cdGFueTogKCkgPT4gKFxuXHRcdGlzTW9iaWxlLmFuZHJvaWQoKSB8fFxuXHRcdGlzTW9iaWxlLmJsYWNrYmVycnkoKSB8fFxuXHRcdGlzTW9iaWxlLmlvcygpIHx8XG5cdFx0aXNNb2JpbGUub3BlcmEoKSB8fFxuXHRcdGlzTW9iaWxlLndpbmRvd3MoKVxuXHQpLFxufVxuXG5leHBvcnQgZGVmYXVsdCBpc01vYmlsZVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFYQTtBQW9CQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/utils/is-mobile.js\n");

/***/ })

/******/ });